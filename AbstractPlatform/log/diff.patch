diff --git a/.gitignore b/.gitignore
new file mode 100755
index 0000000..7d6631e
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,10 @@
+.history/
+help/
+*.log
+*.out
+*.dot
+*.xml
+diff.txt
+AbstractPlatform/backup
+AbstractPlatform/boogie2.5
+Sanctum/backup
\ No newline at end of file
diff --git a/.vscode/settings.json b/.vscode/settings.json
new file mode 100755
index 0000000..6107323
--- /dev/null
+++ b/.vscode/settings.json
@@ -0,0 +1,3 @@
+{
+    "editor.fontSize": 16
+}
\ No newline at end of file
diff --git a/AbstractPlatform/CPU.bpl b/AbstractPlatform/CPU.bpl
old mode 100644
new mode 100755
index 76a5821..56b2cc2
--- a/AbstractPlatform/CPU.bpl
+++ b/AbstractPlatform/CPU.bpl
@@ -7,7 +7,7 @@ var cpu_pc         : vaddr_t;
 var cpu_enclave_id : tap_enclave_id_t;
 var cpu_addr_valid : addr_valid_t;
 var cpu_addr_map   : addr_map_t;
-var cpu_owner_map  : owner_map_t;
+var cpu_owner_map  : owner_map_t;   // pa -> eid
 
 // -------------------------------------------------------------------- //
 // CPU uarch state                                                      //
@@ -17,12 +17,14 @@ const block_os_ev_read  : bool;
 
 // -------------------------------------------------------------------- //
 // State of the untrusted code (OS and its minions).                    //
+// Merged into tap_enclave_metadata                                     //
 // -------------------------------------------------------------------- //
 // the untrusted pages
-var untrusted_addr_valid : addr_valid_t;
-var untrusted_addr_map   : addr_map_t;
-var untrusted_regs       : regs_t;
-var untrusted_pc         : vaddr_t;
+
+// var untrusted_addr_valid : addr_valid_t;
+// var untrusted_addr_map   : addr_map_t;
+// var untrusted_regs       : regs_t;
+// var untrusted_pc         : vaddr_t;
 
 // -------------------------------------------------------------------- //
 // The enclaves in the system                                           //
@@ -37,7 +39,10 @@ var tap_enclave_metadata_pc             : tap_enclave_metadata_pc_t;
 var tap_enclave_metadata_regs           : tap_enclave_metadata_regs_t;
 var tap_enclave_metadata_paused         : tap_enclave_metadata_paused_t;
 var tap_enclave_metadata_cache_conflict : tap_enclave_metadata_cache_conflict_t;
-
+// privileged enclave symbol
+var tap_enclave_metadata_privileged     : tap_enclave_metadata_privileged_t;
+// enclave control relationships
+var tap_enclave_metadata_owner_map      : tap_enclave_metadata_owner_map_t;     // eid(child) -> eid(parent)
 // -------------------------------------------------------------------- //
 // Utility functions.                                                   //
 // -------------------------------------------------------------------- //
@@ -48,21 +53,23 @@ procedure initialize_tap();
   modifies cpu_enclave_id,
            cpu_addr_map,
            cpu_addr_valid,
-           untrusted_addr_map,
-           untrusted_addr_valid,
-           untrusted_pc,
-           untrusted_regs,
            cpu_pc,
            cpu_regs,
            cpu_owner_map,
            cpu_mem,
            cache_valid_map,
-           tap_enclave_metadata_valid;
+           tap_enclave_metadata_valid,
+           tap_enclave_metadata_addr_valid,
+           tap_enclave_metadata_addr_map,
+           tap_enclave_metadata_pc,
+           tap_enclave_metadata_regs;
   ensures cpu_enclave_id == tap_null_enc_id;
-  ensures cpu_addr_map == untrusted_addr_map;
-  ensures cpu_addr_valid == untrusted_addr_valid;
-  ensures cpu_pc == untrusted_pc;
-  ensures cpu_regs == untrusted_regs;
+  ensures tap_enclave_metadata_valid[tap_null_enc_id];
+  ensures cpu_addr_valid == tap_enclave_metadata_addr_valid[tap_null_enc_id];
+  ensures cpu_addr_map   == tap_enclave_metadata_addr_map[tap_null_enc_id];
+  ensures cpu_pc         == tap_enclave_metadata_pc[tap_null_enc_id];
+  ensures cpu_regs       == tap_enclave_metadata_regs[tap_null_enc_id];
+
   ensures (forall p : wap_addr_t :: cpu_mem[p] == k0_word_t);
   ensures (forall p : wap_addr_t :: cpu_owner_map[p] == tap_null_enc_id);
   ensures (forall e : tap_enclave_id_t :: !tap_enclave_metadata_valid[e]);
@@ -77,19 +84,21 @@ procedure update_cache(pa : wap_addr_t);
 
 
 procedure {:inline 1} set_addr_map(va: vaddr_t, pa: wap_addr_t, valid: addr_perm_t)
-  modifies untrusted_addr_valid, untrusted_addr_map,
+  modifies tap_enclave_metadata_addr_valid, tap_enclave_metadata_addr_map,
            cpu_addr_valid, cpu_addr_map;
 {
   if (cpu_enclave_id == tap_null_enc_id) {
-    untrusted_addr_valid[va] := valid;
-    cpu_addr_valid := untrusted_addr_valid;
+    tap_enclave_metadata_addr_valid[tap_null_enc_id][va] := valid;
+    cpu_addr_valid := tap_enclave_metadata_addr_valid[tap_null_enc_id];
     if (tap_addr_perm_v(valid)) {
-        untrusted_addr_map[va] := pa;
-        cpu_addr_map := untrusted_addr_map;
+        tap_enclave_metadata_addr_map[tap_null_enc_id][va] := pa;
+        cpu_addr_map := tap_enclave_metadata_addr_map[tap_null_enc_id];
     }
   }
 }
-
+// read value from enclave shared memory 
+// or
+// read Page Table Mapping (observation)
 procedure {:inline 1} get_enclave_addr_map(
     /* eid */ eid : tap_enclave_id_t,
     /* va  */ va  : vaddr_t
@@ -108,7 +117,7 @@ procedure {:inline 1} get_enclave_addr_map(
         }
     }
 }
-
+// set enclave shared memory mapping
 procedure {:inline 1} set_enclave_addr_map(
     /* eid   */ eid   : tap_enclave_id_t,
     /* va    */ va    : vaddr_t,
@@ -118,20 +127,51 @@ procedure {:inline 1} set_enclave_addr_map(
    returns (status : enclave_op_result_t)
    modifies tap_enclave_metadata_addr_valid;
    modifies tap_enclave_metadata_addr_map;
+   ensures (status == enclave_op_success  && 
+    (tap_enclave_metadata_privileged[eid] || 
+     tap_enclave_metadata_privileged[tap_enclave_metadata_owner_map[eid]])) ==> 
+    (tap_enclave_metadata_addr_excl[eid][va] <==> cpu_owner_map[paddr] == eid);
 {
-    // default values.
+    // // include NE setup.
+    // if (tap_enclave_metadata_owner_map[eid] == cpu_enclave_id && 
+    //     tap_enclave_metadata_valid[eid]) {
+    //     if (!tap_enclave_metadata_addr_excl[eid][va]) {
+    //         tap_enclave_metadata_addr_valid[eid][va] := valid;
+    //         tap_enclave_metadata_addr_map[eid][va] := paddr;
+    //         status := enclave_op_success;
+    //         return;
+    //     }
+    // }
+    // status := enclave_op_invalid_arg;
+
+    // default values && add eid-blocking
     if (cpu_enclave_id == tap_null_enc_id &&
         tap_enclave_metadata_valid[eid]) 
     {
-        if (!tap_enclave_metadata_addr_excl[eid][va]) {
-            tap_enclave_metadata_addr_valid[eid][va] := valid;
-            tap_enclave_metadata_addr_map[eid][va] := paddr;
-            status := enclave_op_success;
-            return;
+        if (!tap_enclave_metadata_privileged[tap_enclave_metadata_owner_map[eid]] && 
+            !tap_enclave_metadata_privileged[eid]) {
+            if (!tap_enclave_metadata_addr_excl[eid][va]) {
+                tap_enclave_metadata_addr_valid[eid][va] := valid;
+                tap_enclave_metadata_addr_map[eid][va] := paddr;
+                status := enclave_op_success;
+                return;
+            }
         }
     }
     status := enclave_op_invalid_arg;
 }
+// // set current process memory mapping
+// procedure {:inline 1} set_cpu_addr_map (
+//     /* va    */ va    : vaddr_t,
+//     /* valid */ valid : addr_perm_t,
+//     /* paddr */ paddr : wap_addr_t
+// )
+//     returns (status : enclave_op_result_t)
+//     modifies tap_enclave_metadata_addr_valid;
+//     modifies tap_enclave_metadata_addr_map;
+// {
+//     if (tap_enclave_metadata_privileged[cpu_enclave_id] || )
+// }
 
 procedure {:inline 1} fetch_va(vaddr : vaddr_t, repl_way : cache_way_index_t)
     returns (data: word_t, excp: exception_t, hit : bool)
@@ -166,41 +206,62 @@ procedure {:inline 1} fetch_va(vaddr : vaddr_t, repl_way : cache_way_index_t)
         call hit, hit_way := query_cache(paddr, repl_way); 
     }
 }
-
-procedure {:inline 1} load_va(vaddr : vaddr_t, repl_way : cache_way_index_t)
+// Reinterpreted load_va: PE can load from children NE.
+// If we make introspection, 
+procedure {:inline 1} load_va(eid : tap_enclave_id_t , vaddr : vaddr_t, repl_way : cache_way_index_t)
     returns (data: word_t, excp: exception_t, hit : bool)
     requires valid_cache_way_index(repl_way);
     modifies cache_valid_map, cache_tag_map, cpu_addr_valid;
+    // modifies tap_enclave_metadata_addr_valid;
 {
     var paddr : wap_addr_t;
     var owner_eid : tap_enclave_id_t;
     var hit_way : cache_way_index_t;
-
+    var introspection : bool;     // Is this a inspection operation? 
+    var inspect_data : word_t;
+    
     // default.
     data := k0_word_t;
     hit := false; 
+    introspection := false;
+    inspect_data := k0_word_t;
 
     // translate VA -> PA.
-    if (!tap_addr_perm_r(cpu_addr_valid[vaddr])) { 
+    if (!tap_addr_perm_r(tap_enclave_metadata_addr_valid[eid][vaddr])) { 
         excp := excp_os_protection_fault; return; 
     }
-    paddr := cpu_addr_map[vaddr];
+    paddr := tap_enclave_metadata_addr_map[eid][vaddr];
     // are we not allowed to access this memory
     owner_eid := cpu_owner_map[paddr];
+
     if (owner_eid != tap_null_enc_id && owner_eid != cpu_enclave_id) {
-        excp := excp_tp_protection_fault; return;
+        if (tap_enclave_metadata_owner_map[owner_eid] == cpu_enclave_id) {
+            introspection := true;
+        } else {
+            excp := excp_tp_protection_fault; 
+            return;
+        }
     }
     // update accessed bit.
-    cpu_addr_valid[vaddr] := tap_set_addr_perm_a(cpu_addr_valid[vaddr]);
-    // perform load.
-    data := cpu_mem[paddr];
+    // introspection: doesn't guarantee the load data be the same.
+    if (!introspection) {
+        cpu_addr_valid[vaddr] := tap_set_addr_perm_a(cpu_addr_valid[vaddr]);
+        data := cpu_mem[paddr];
+    } else {
+        // time-consuming
+        // tap_enclave_metadata_addr_valid[eid][vaddr] := tap_set_addr_perm_a(tap_enclave_metadata_addr_valid[eid][vaddr]);
+        inspect_data := cpu_mem[paddr];
+        data := k0_word_t;
+    }
     excp := excp_none;
+
     // update cache.
     if (cpu_cache_enabled) { 
         call hit, hit_way := query_cache(paddr, repl_way); 
     }
 }
 
+// We leave the reinterpreted store operation to the future model.
 procedure {:inline 1} store_va(vaddr : vaddr_t, data : word_t, repl_way : cache_way_index_t)
     returns (excp: exception_t, hit : bool)
     modifies cpu_mem;
@@ -253,16 +314,19 @@ function {:inline} vaddr_alias(
  /* address    */ va1  : vaddr_t, va2 : vaddr_t) : bool
 { (va1 != va2 && av[va1] && av[va2] && am[va1] == am[va2]) }
 
+
 // -------------------------------------------------------------------- //
 // Launch an enclave                                                    //
 // -------------------------------------------------------------------- //
+
 procedure launch(
   /* eid.              */ eid             : tap_enclave_id_t,
   /* VA to PA. mapping */ addr_valid      : addr_valid_t,
   /* VA to PA mapping  */ addr_map        : addr_map_t,
   /* excl vaddr        */ excl_vaddr      : excl_vaddr_t,
   /* excl addr         */ excl_paddr      : excl_map_t,
-  /* entrypoint.       */ entrypoint      : vaddr_t
+  /* entrypoint.       */ entrypoint      : vaddr_t,
+  /* privileged        */ privileged      : bool
 )
     returns (status : enclave_op_result_t);
 
@@ -276,13 +340,19 @@ procedure launch(
     modifies tap_enclave_metadata_regs;
     modifies tap_enclave_metadata_paused;
     modifies tap_enclave_metadata_cache_conflict;
-
+    modifies tap_enclave_metadata_privileged;
+    modifies tap_enclave_metadata_owner_map;
     //----------------------------------------------------------------------//
     // global TAP invariants.                                               //
     //----------------------------------------------------------------------//
     requires (forall pa : wap_addr_t, e : tap_enclave_id_t ::
                 (valid_enclave_id(e) && !tap_enclave_metadata_valid[e]) ==>
                     (cpu_owner_map[pa] != e));
+
+    requires (!tap_enclave_metadata_privileged[tap_null_enc_id]);
+    // add non-valid demand into requires. Apr 6, 2023.
+    requires (!tap_enclave_metadata_valid[eid]);
+
     ensures  (forall pa : wap_addr_t, e : tap_enclave_id_t ::
                 (valid_enclave_id(e) && !tap_enclave_metadata_valid[e]) ==>
                     (cpu_owner_map[pa] != e));
@@ -300,7 +370,8 @@ procedure launch(
     ensures (status != enclave_op_success ==> tap_enclave_metadata_regs == old(tap_enclave_metadata_regs));
     ensures (status != enclave_op_success ==> tap_enclave_metadata_paused == old(tap_enclave_metadata_paused));
     ensures (status != enclave_op_success ==> tap_enclave_metadata_cache_conflict == old(tap_enclave_metadata_cache_conflict));
-
+    ensures (status != enclave_op_success ==> tap_enclave_metadata_privileged == old(tap_enclave_metadata_privileged));
+    ensures (status != enclave_op_success ==> tap_enclave_metadata_owner_map == old(tap_enclave_metadata_owner_map));
     //----------------------------------------------------------------------//
     // these postconditions say that only entry [eid] changes in the maps.  //
     //----------------------------------------------------------------------//
@@ -340,12 +411,20 @@ procedure launch(
     ensures (forall e : tap_enclave_id_t ::
                 (e != eid) ==> 
                     tap_enclave_metadata_cache_conflict[e] == old(tap_enclave_metadata_cache_conflict)[e]);
-    
+    ensures (forall e : tap_enclave_id_t ::
+                (e != eid) ==> 
+                    tap_enclave_metadata_privileged[e] == old(tap_enclave_metadata_privileged)[e]);
+    ensures (forall e : tap_enclave_id_t :: 
+                (e != eid) ==> 
+                    tap_enclave_metadata_owner_map[e] == old(tap_enclave_metadata_owner_map)[e]);
     //---------------------------------------------------------------------//
     // conditions which specify when we fail.                              //
     //---------------------------------------------------------------------//
+
+    /* bug fixed: We shouldn't add post-condition requirement into result ensure clause. */
     ensures
-        ((cpu_enclave_id == tap_null_enc_id)                                                        &&   
+        (((cpu_enclave_id == tap_null_enc_id ) ||
+                (old(tap_enclave_metadata_privileged)[cpu_enclave_id] && !privileged))              &&   
          (valid_enclave_id(eid))                                                                    &&   
          (!old(tap_enclave_metadata_valid)[eid])                                                    &&   
          (tap_addr_perm_x(addr_valid[entrypoint]))                                                  &&   
@@ -385,7 +464,11 @@ procedure launch(
                 (tap_enclave_metadata_addr_excl[eid] == excl_vaddr);
     ensures (status == enclave_op_success) ==> 
                 (tap_enclave_metadata_addr_map[eid] == addr_map);
-
+    
+    ensures (status == enclave_op_success) ==> 
+                (tap_enclave_metadata_privileged[eid] == privileged);
+    ensures (status == enclave_op_success) ==>
+                (tap_enclave_metadata_owner_map[eid] == cpu_enclave_id);
     // additional invariants that hold upon success.
     ensures (status == enclave_op_success) ==>
          (forall v1, v2 : vaddr_t :: 
@@ -399,6 +482,11 @@ procedure launch(
          (forall v : vaddr_t :: 
             tap_enclave_metadata_addr_excl[eid][v] ==>
             tap_addr_perm_v(tap_enclave_metadata_addr_valid[eid][v]));
+    // TODO: we can improve this. Apr 8, 2023.
+    ensures (forall e : tap_enclave_id_t, v : vaddr_t :: 
+        ((tap_enclave_metadata_valid[e] && (tap_enclave_metadata_privileged[e] || tap_enclave_metadata_privileged[tap_enclave_metadata_owner_map[e]])) ==> 
+            tap_enclave_metadata_addr_excl[e][v] <==> cpu_owner_map[tap_enclave_metadata_addr_map[e][v]] == e)); 
+
 
 // -------------------------------------------------------------------- //
 // Enter an enclave                                                     //
@@ -407,10 +495,10 @@ procedure enter(eid: tap_enclave_id_t)
     returns (status : enclave_op_result_t);
 
     modifies cpu_enclave_id;
-    modifies untrusted_regs;
-    modifies cpu_addr_valid, untrusted_addr_valid;
-    modifies cpu_addr_map, untrusted_addr_map;
-    modifies cpu_pc, untrusted_pc;
+    modifies tap_enclave_metadata_regs;
+    modifies cpu_addr_valid, tap_enclave_metadata_addr_valid;
+    modifies cpu_addr_map, tap_enclave_metadata_addr_map;
+    modifies cpu_pc, tap_enclave_metadata_pc;
 
     //----------------------------------------------------------------------//
     // global TAP invariants.                                               //
@@ -418,6 +506,7 @@ procedure enter(eid: tap_enclave_id_t)
     requires (forall pa : wap_addr_t, e : tap_enclave_id_t ::
                 (valid_enclave_id(e) && !tap_enclave_metadata_valid[e]) ==> 
                     (cpu_owner_map[pa] != e));
+    
     ensures  (forall pa : wap_addr_t, e : tap_enclave_id_t ::
                 (valid_enclave_id(e) && !tap_enclave_metadata_valid[e]) ==> 
                     (cpu_owner_map[pa] != e));
@@ -425,39 +514,69 @@ procedure enter(eid: tap_enclave_id_t)
     //----------------------------------------------------------------------//
     // conditions for success or failure.                                   //
     //----------------------------------------------------------------------//
-    ensures ((valid_enclave_id(eid))                   &&
-             (tap_enclave_metadata_valid[eid])         &&
-             (old(cpu_enclave_id) == tap_null_enc_id)) ==> (status == enclave_op_success);
-    ensures ((!valid_enclave_id(eid))                  ||
-             (!tap_enclave_metadata_valid[eid])        ||
-             (old(cpu_enclave_id) != tap_null_enc_id)) ==> (status == enclave_op_invalid_arg);
+    ensures ((valid_enclave_id(eid)) &&
+             (tap_enclave_metadata_valid[eid]) && 
+             ((old(cpu_enclave_id) == tap_null_enc_id) || (tap_enclave_metadata_privileged[old(cpu_enclave_id)])) &&
+             (tap_enclave_metadata_owner_map[eid] == old(cpu_enclave_id))) ==> (status == enclave_op_success);
+    
+    ensures ((!valid_enclave_id(eid)) ||
+             (!tap_enclave_metadata_valid[eid]) ||
+             ((old(cpu_enclave_id) != tap_null_enc_id) && (!tap_enclave_metadata_privileged[old(cpu_enclave_id)])) ||
+             (tap_enclave_metadata_owner_map[eid] != old(cpu_enclave_id))) ==> (status == enclave_op_invalid_arg);
+    
     ensures (status == enclave_op_success || status == enclave_op_invalid_arg);
                 
     //----------------------------------------------------------------------//
     // nothing changes on failure.                                          //
     //----------------------------------------------------------------------//
     ensures (status != enclave_op_success ==> cpu_enclave_id == old(cpu_enclave_id));
+    ensures (status != enclave_op_success ==> cpu_pc         == old(cpu_pc));
     ensures (status != enclave_op_success ==> cpu_addr_valid == old(cpu_addr_valid));
-    ensures (status != enclave_op_success ==> cpu_addr_map == old(cpu_addr_map));
-    ensures (status != enclave_op_success ==> cpu_pc == old(cpu_pc));
-    ensures (status != enclave_op_success ==> untrusted_regs == old(untrusted_regs));
-    ensures (status != enclave_op_success ==> untrusted_addr_valid == old(untrusted_addr_valid));
-    ensures (status != enclave_op_success ==> untrusted_addr_map == old(untrusted_addr_map));
-    ensures (status != enclave_op_success ==> untrusted_pc == old(untrusted_pc));
+    ensures (status != enclave_op_success ==> cpu_addr_map   == old(cpu_addr_map));
 
+    ensures (status != enclave_op_success ==> tap_enclave_metadata_pc           == old(tap_enclave_metadata_pc));
+    ensures (status != enclave_op_success ==> tap_enclave_metadata_regs         == old(tap_enclave_metadata_regs));
+    ensures (status != enclave_op_success ==> tap_enclave_metadata_addr_valid   == old(tap_enclave_metadata_addr_valid));
+    ensures (status != enclave_op_success ==> tap_enclave_metadata_addr_map     == old(tap_enclave_metadata_addr_map));
     //----------------------------------------------------------------------//
     // state updates on success.                                            //
     //----------------------------------------------------------------------//
-    ensures (status == enclave_op_success) ==> (untrusted_pc == old(cpu_pc));
+    // ensures (status == enclave_op_success) ==> ((tap_enclave_metadata_owner_map[eid] == tap_null_enc_id) ||
+    //                                             (tap_enclave_metadata_valid[tap_enclave_metadata_owner_map[eid]]));
+    // save owner context: property 
+    ensures (status == enclave_op_success) ==> (tap_enclave_metadata_pc[old(cpu_enclave_id)] == old(cpu_pc));
+    ensures (status == enclave_op_success) ==> (tap_enclave_metadata_regs[old(cpu_enclave_id)] == old(cpu_regs));
+    ensures (status == enclave_op_success) ==> (tap_enclave_metadata_addr_valid[old(cpu_enclave_id)] == old(cpu_addr_valid));
+    ensures (status == enclave_op_success) ==> (tap_enclave_metadata_addr_map[old(cpu_enclave_id)] == old(cpu_addr_map));
+    
+    // restore enclave context: property
     ensures (status == enclave_op_success) ==> (cpu_enclave_id == eid);
     ensures (status == enclave_op_success) ==> (cpu_pc == tap_enclave_metadata_entrypoint[eid]);
-    ensures (status == enclave_op_success) ==> (untrusted_regs == old(cpu_regs));
-    ensures (status == enclave_op_success) ==> (untrusted_addr_valid == old(cpu_addr_valid));
-    ensures (status == enclave_op_success) ==> (untrusted_addr_map == old(cpu_addr_map));
     ensures (status == enclave_op_success) ==> (cpu_addr_valid == tap_enclave_metadata_addr_valid[eid]);
     ensures (status == enclave_op_success) ==> (cpu_addr_map == tap_enclave_metadata_addr_map[eid]);
 
+    // additional features: 
+    // ensures eid != old(cpu_enclave_id);
+    //--------------------------------------------------------------------------------------//
+    // these postconditions say that only entry [old(cpu_enclave_id)] changes in the maps.  //
+    //--------------------------------------------------------------------------------------//
+    ensures (status == enclave_op_success) ==> (forall e : tap_enclave_id_t ::
+                (e != old(cpu_enclave_id) ==> 
+                    tap_enclave_metadata_pc[e] == old(tap_enclave_metadata_pc)[e]));
+    ensures (status == enclave_op_success) ==> (forall e : tap_enclave_id_t ::
+                (e != old(cpu_enclave_id) ==> 
+                    tap_enclave_metadata_regs[e] == old(tap_enclave_metadata_regs)[e]));
+    ensures (status == enclave_op_success) ==> (forall e : tap_enclave_id_t ::
+                (e != old(cpu_enclave_id) ==> 
+                    tap_enclave_metadata_addr_valid[e] == old(tap_enclave_metadata_addr_valid)[e]));
+    ensures (status == enclave_op_success) ==> (forall e : tap_enclave_id_t ::
+                (e != old(cpu_enclave_id) ==> 
+                    tap_enclave_metadata_addr_map[e] == old(tap_enclave_metadata_addr_map)[e]));        
+    ensures (status == enclave_op_success && tap_enclave_metadata_privileged[old(cpu_enclave_id)]) ==> 
+        (forall v : vaddr_t :: 
+            tap_enclave_metadata_addr_excl[old(cpu_enclave_id)][v] <==> cpu_owner_map[old(cpu_addr_map)[v]] == old(cpu_enclave_id));
 
+    
 // -------------------------------------------------------------------- //
 // Resume an enclave                                                    //
 // -------------------------------------------------------------------- //
@@ -465,10 +584,10 @@ procedure resume(eid: tap_enclave_id_t)
     returns (status : enclave_op_result_t);
 
     modifies cpu_enclave_id;
-    modifies cpu_regs, untrusted_regs;
-    modifies cpu_addr_valid, untrusted_addr_valid;
-    modifies cpu_addr_map, untrusted_addr_map;
-    modifies cpu_pc, untrusted_pc;
+    modifies cpu_regs, tap_enclave_metadata_regs;
+    modifies cpu_addr_valid, tap_enclave_metadata_addr_valid;
+    modifies cpu_addr_map, tap_enclave_metadata_addr_map;
+    modifies cpu_pc, tap_enclave_metadata_pc;
 
     //----------------------------------------------------------------------//
     // global TAP invariants.                                               //
@@ -476,6 +595,11 @@ procedure resume(eid: tap_enclave_id_t)
     requires (forall pa : wap_addr_t, e : tap_enclave_id_t ::
                 (valid_enclave_id(e) && !tap_enclave_metadata_valid[e]) ==> 
                     (cpu_owner_map[pa] != e));
+
+    // /* TODO: redundant? why running enclave cannot be invalid? */
+    // requires ((cpu_enclave_id != tap_null_enc_id) ==> 
+    //                 (tap_enclave_metadata_valid[cpu_enclave_id]));
+
     ensures  (forall pa : wap_addr_t, e : tap_enclave_id_t ::
                 (valid_enclave_id(e) && !tap_enclave_metadata_valid[e]) ==> 
                     (cpu_owner_map[pa] != e));
@@ -483,42 +607,70 @@ procedure resume(eid: tap_enclave_id_t)
     //----------------------------------------------------------------------//
     // conditions for success or failure.                                   //
     //----------------------------------------------------------------------//
-    ensures ((valid_enclave_id(eid))                      &&
-             (tap_enclave_metadata_valid[eid])            && 
-             (tap_enclave_metadata_paused[eid])           &&
-             (old(cpu_enclave_id) == tap_null_enc_id))    ==> (status == enclave_op_success);
-    ensures ((!valid_enclave_id(eid))                     ||
-             (!tap_enclave_metadata_valid[eid])           || 
-             (!tap_enclave_metadata_paused[eid])          ||
-             (old(cpu_enclave_id) != tap_null_enc_id))    ==> (status == enclave_op_invalid_arg);
+    ensures ((valid_enclave_id(eid)) &&
+             (tap_enclave_metadata_valid[eid]) && 
+             (tap_enclave_metadata_paused[eid]) &&
+             ((old(cpu_enclave_id) == tap_null_enc_id) || (tap_enclave_metadata_privileged[old(cpu_enclave_id)])) &&
+             (tap_enclave_metadata_owner_map[eid] == old(cpu_enclave_id))) ==> (status == enclave_op_success);
+
+    ensures ((!valid_enclave_id(eid)) ||
+             (!tap_enclave_metadata_valid[eid]) ||
+             (!tap_enclave_metadata_paused[eid]) ||
+             ((old(cpu_enclave_id) != tap_null_enc_id) && (!tap_enclave_metadata_privileged[old(cpu_enclave_id)])) ||
+             (tap_enclave_metadata_owner_map[eid] != old(cpu_enclave_id))) ==> (status == enclave_op_invalid_arg);
+    
     ensures (status == enclave_op_success || status == enclave_op_invalid_arg);
 
     //----------------------------------------------------------------------//
     // nothing changes on failure.                                          //
     //----------------------------------------------------------------------//
-    ensures (status != enclave_op_success ==> cpu_regs == old(cpu_regs));
     ensures (status != enclave_op_success ==> cpu_enclave_id == old(cpu_enclave_id));
+
+    ensures (status != enclave_op_success ==> cpu_pc == old(cpu_pc));
+    ensures (status != enclave_op_success ==> cpu_regs == old(cpu_regs));
     ensures (status != enclave_op_success ==> cpu_addr_valid == old(cpu_addr_valid));
     ensures (status != enclave_op_success ==> cpu_addr_map == old(cpu_addr_map));
-    ensures (status != enclave_op_success ==> cpu_pc == old(cpu_pc));
-    ensures (status != enclave_op_success ==> untrusted_regs == old(untrusted_regs));
-    ensures (status != enclave_op_success ==> untrusted_addr_valid == old(untrusted_addr_valid));
-    ensures (status != enclave_op_success ==> untrusted_addr_map == old(untrusted_addr_map));
-    ensures (status != enclave_op_success ==> untrusted_pc == old(untrusted_pc));
 
+    ensures (status != enclave_op_success ==> tap_enclave_metadata_pc           == old(tap_enclave_metadata_pc));
+    ensures (status != enclave_op_success ==> tap_enclave_metadata_regs         == old(tap_enclave_metadata_regs));
+    ensures (status != enclave_op_success ==> tap_enclave_metadata_addr_valid   == old(tap_enclave_metadata_addr_valid));
+    ensures (status != enclave_op_success ==> tap_enclave_metadata_addr_map     == old(tap_enclave_metadata_addr_map));
+    
     //----------------------------------------------------------------------//
     // state updates on success.                                            //
     //----------------------------------------------------------------------//
-    ensures (status == enclave_op_success) ==> (untrusted_pc == old(cpu_pc));
+    // save owner context: property (the 2 branches can be merged!)
+    ensures (status == enclave_op_success) ==> (tap_enclave_metadata_pc[old(cpu_enclave_id)] == old(cpu_pc));
+    ensures (status == enclave_op_success) ==> (tap_enclave_metadata_regs[old(cpu_enclave_id)] == old(cpu_regs));
+    ensures (status == enclave_op_success) ==> (tap_enclave_metadata_addr_valid[old(cpu_enclave_id)] == old(cpu_addr_valid));
+    ensures (status == enclave_op_success) ==> (tap_enclave_metadata_addr_map[old(cpu_enclave_id)] == old(cpu_addr_map));
+    
+    // restore enclave context: property
     ensures (status == enclave_op_success) ==> (cpu_enclave_id == eid);
     ensures (status == enclave_op_success) ==> (cpu_pc == tap_enclave_metadata_pc[eid]);
-    ensures (status == enclave_op_success) ==> (untrusted_regs == old(cpu_regs));
-    ensures (status == enclave_op_success) ==> (untrusted_addr_valid == old(cpu_addr_valid));
-    ensures (status == enclave_op_success) ==> (untrusted_addr_map == old(cpu_addr_map));
     ensures (status == enclave_op_success) ==> (cpu_regs == tap_enclave_metadata_regs[eid]);
     ensures (status == enclave_op_success) ==> (cpu_addr_valid == tap_enclave_metadata_addr_valid[eid]);
     ensures (status == enclave_op_success) ==> (cpu_addr_map == tap_enclave_metadata_addr_map[eid]);
+    //--------------------------------------------------------------------------------------//
+    // these postconditions say that only entry [old(cpu_enclave_id)] changes in the maps.  //
+    //--------------------------------------------------------------------------------------//
+    ensures (status == enclave_op_success) ==> (forall e : tap_enclave_id_t ::
+                (e != old(cpu_enclave_id) ==> 
+                    tap_enclave_metadata_pc[e] == old(tap_enclave_metadata_pc)[e]));
+    ensures (status == enclave_op_success) ==> (forall e : tap_enclave_id_t ::
+                (e != old(cpu_enclave_id) ==> 
+                    tap_enclave_metadata_regs[e] == old(tap_enclave_metadata_regs)[e]));
+    ensures (status == enclave_op_success) ==> (forall e : tap_enclave_id_t ::
+                (e != old(cpu_enclave_id) ==> 
+                    tap_enclave_metadata_addr_valid[e] == old(tap_enclave_metadata_addr_valid)[e]));
+    ensures (status == enclave_op_success) ==> (forall e : tap_enclave_id_t ::
+                (e != old(cpu_enclave_id) ==> 
+                    tap_enclave_metadata_addr_map[e] == old(tap_enclave_metadata_addr_map)[e]));        
+    ensures (status == enclave_op_success && tap_enclave_metadata_privileged[old(cpu_enclave_id)]) ==> 
+        (forall v : vaddr_t :: 
+            tap_enclave_metadata_addr_excl[old(cpu_enclave_id)][v] <==> cpu_owner_map[old(cpu_addr_map)[v]] == old(cpu_enclave_id));
 
+    
 
 
 // -------------------------------------------------------------------- //
@@ -543,6 +695,12 @@ procedure exit()
     requires (forall pa : wap_addr_t, e : tap_enclave_id_t ::
                 (valid_enclave_id(e) && !tap_enclave_metadata_valid[e]) ==> 
                     (cpu_owner_map[pa] != e));
+
+    requires (tap_enclave_metadata_valid[tap_enclave_metadata_owner_map[cpu_enclave_id]]);
+    
+    requires ((tap_enclave_metadata_owner_map[cpu_enclave_id] == tap_null_enc_id) || 
+              (tap_enclave_metadata_privileged[tap_enclave_metadata_owner_map[cpu_enclave_id]]));
+
     ensures  (forall pa : wap_addr_t, e : tap_enclave_id_t ::
                 (valid_enclave_id(e) && !tap_enclave_metadata_valid[e]) ==> 
                     (cpu_owner_map[pa] != e));
@@ -583,19 +741,28 @@ procedure exit()
     //----------------------------------------------------------------------//
     // state updates on success.                                            //
     //----------------------------------------------------------------------//
-    ensures (status == enclave_op_success) ==> (cpu_pc == old(untrusted_pc));
-    ensures (status == enclave_op_success) ==> (cpu_enclave_id == tap_null_enc_id);
-    ensures (status == enclave_op_success) ==> (!tap_enclave_metadata_paused[old(cpu_enclave_id)]);
     ensures (status == enclave_op_success) ==> 
-            (tap_enclave_metadata_pc[old(cpu_enclave_id)] == tap_enclave_metadata_entrypoint[old(cpu_enclave_id)]);
+                    (!tap_enclave_metadata_paused[old(cpu_enclave_id)]);
+    ensures (status == enclave_op_success) ==> 
+                    (tap_enclave_metadata_pc[old(cpu_enclave_id)] == tap_enclave_metadata_entrypoint[old(cpu_enclave_id)]);
     ensures (status == enclave_op_success) ==>
-              (tap_enclave_metadata_addr_valid[old(cpu_enclave_id)] == old(cpu_addr_valid));
+                    (tap_enclave_metadata_addr_valid[old(cpu_enclave_id)] == old(cpu_addr_valid));
     ensures (status == enclave_op_success) ==>
-              (tap_enclave_metadata_addr_map[old(cpu_enclave_id)] == old(cpu_addr_map));
-    ensures (status == enclave_op_success) ==> (cpu_regs == untrusted_regs);
-    ensures (status == enclave_op_success) ==> (cpu_addr_valid == untrusted_addr_valid);
-    ensures (status == enclave_op_success) ==> (cpu_addr_map == untrusted_addr_map);
+                    (tap_enclave_metadata_addr_map[old(cpu_enclave_id)] == old(cpu_addr_map));
 
+    ensures (status == enclave_op_success) ==> 
+                    (cpu_enclave_id == tap_enclave_metadata_owner_map[old(cpu_enclave_id)]);
+    ensures (status == enclave_op_success) ==> 
+                    (cpu_pc == tap_enclave_metadata_pc[tap_enclave_metadata_owner_map[old(cpu_enclave_id)]]);
+    ensures (status == enclave_op_success) ==> 
+                    (cpu_regs == tap_enclave_metadata_regs[tap_enclave_metadata_owner_map[old(cpu_enclave_id)]]);
+    ensures (status == enclave_op_success) ==> 
+                    (cpu_addr_valid == tap_enclave_metadata_addr_valid[tap_enclave_metadata_owner_map[old(cpu_enclave_id)]]);
+    ensures (status == enclave_op_success) ==> 
+                    (cpu_addr_map == tap_enclave_metadata_addr_map[tap_enclave_metadata_owner_map[old(cpu_enclave_id)]]);
+    ensures (status == enclave_op_success && (tap_enclave_metadata_privileged[old(cpu_enclave_id)] || tap_enclave_metadata_privileged[tap_enclave_metadata_owner_map[old(cpu_enclave_id)]])) ==> 
+        (forall v : vaddr_t :: 
+            tap_enclave_metadata_addr_excl[old(cpu_enclave_id)][v] <==> cpu_owner_map[old(cpu_addr_map)[v]] == old(cpu_enclave_id));
 
 // -------------------------------------------------------------------- //
 // Pause an enclave.                                                    //
@@ -663,23 +830,32 @@ procedure pause()
     //----------------------------------------------------------------------//
     // state updates on success.                                            //
     //----------------------------------------------------------------------//
-    ensures (status == enclave_op_success) ==> (cpu_pc == old(untrusted_pc));
-    ensures (status == enclave_op_success) ==> (cpu_enclave_id == tap_null_enc_id);
-    ensures (status == enclave_op_success) ==> (tap_enclave_metadata_paused[old(cpu_enclave_id)]);
     ensures (status == enclave_op_success) ==> 
-            (tap_enclave_metadata_pc[old(cpu_enclave_id)] == old(cpu_pc));
-    ensures (status == enclave_op_success) ==>
-            (tap_enclave_metadata_regs[old(cpu_enclave_id)] == old(cpu_regs));
-    ensures (status == enclave_op_success) ==>
-              (tap_enclave_metadata_addr_valid[old(cpu_enclave_id)] == old(cpu_addr_valid));
-    ensures (status == enclave_op_success) ==>
-              (tap_enclave_metadata_addr_map[old(cpu_enclave_id)] == old(cpu_addr_map));
+                    (tap_enclave_metadata_paused[old(cpu_enclave_id)]);
+    ensures (status == enclave_op_success) ==> 
+                    (tap_enclave_metadata_pc[old(cpu_enclave_id)] == old(cpu_pc));
     ensures (status == enclave_op_success) ==>
-            (cpu_regs == untrusted_regs);
+                    (tap_enclave_metadata_regs[old(cpu_enclave_id)] == old(cpu_regs));
     ensures (status == enclave_op_success) ==>
-            (cpu_addr_valid == untrusted_addr_valid);
+                    (tap_enclave_metadata_addr_valid[old(cpu_enclave_id)] == old(cpu_addr_valid));
     ensures (status == enclave_op_success) ==>
-            (cpu_addr_map == untrusted_addr_map);
+                    (tap_enclave_metadata_addr_map[old(cpu_enclave_id)] == old(cpu_addr_map));
+
+    ensures (status == enclave_op_success) ==> 
+                    (cpu_enclave_id == tap_enclave_metadata_owner_map[old(cpu_enclave_id)]);
+    ensures (status == enclave_op_success) ==> 
+                    (cpu_pc == tap_enclave_metadata_pc[tap_enclave_metadata_owner_map[old(cpu_enclave_id)]]);
+    ensures (status == enclave_op_success) ==> 
+                    (cpu_regs == tap_enclave_metadata_regs[tap_enclave_metadata_owner_map[old(cpu_enclave_id)]]);
+    ensures (status == enclave_op_success) ==> 
+                    (cpu_addr_valid == tap_enclave_metadata_addr_valid[tap_enclave_metadata_owner_map[old(cpu_enclave_id)]]);
+    ensures (status == enclave_op_success) ==> 
+                    (cpu_addr_map == tap_enclave_metadata_addr_map[tap_enclave_metadata_owner_map[old(cpu_enclave_id)]]);
+    ensures (status == enclave_op_success && (tap_enclave_metadata_privileged[old(cpu_enclave_id)] || tap_enclave_metadata_privileged[tap_enclave_metadata_owner_map[old(cpu_enclave_id)]])) ==> 
+        (forall v : vaddr_t :: 
+            tap_enclave_metadata_addr_excl[old(cpu_enclave_id)][v] <==> cpu_owner_map[old(cpu_addr_map)[v]] == old(cpu_enclave_id));
+
+    
 
 
 // -------------------------------------------------------------------- //
@@ -706,12 +882,22 @@ procedure destroy(eid: tap_enclave_id_t)
     //----------------------------------------------------------------------//
     // success/failure conditions.                                          //
     //----------------------------------------------------------------------//
-    ensures (!valid_enclave_id(eid)                 || 
-             !old(tap_enclave_metadata_valid)[eid]  || 
-             cpu_enclave_id != tap_null_enc_id) ==> (status == enclave_op_invalid_arg);
-    ensures (valid_enclave_id(eid)                  && 
-             old(tap_enclave_metadata_valid)[eid]   && 
-             cpu_enclave_id == tap_null_enc_id) ==> (status == enclave_op_success);
+    // destroy target must be current enclave/OS's children
+    // destroy target must have no children enclave
+    ensures (!valid_enclave_id(eid)                                         ||
+             !old(tap_enclave_metadata_valid)[eid]                          ||
+             tap_enclave_metadata_owner_map[eid] != cpu_enclave_id          ||
+             (exists e : tap_enclave_id_t :: 
+                (old(tap_enclave_metadata_valid)[eid] && 
+                    tap_enclave_metadata_owner_map[eid] == cpu_enclave_id)) ==> (status == enclave_op_invalid_arg));
+
+    ensures (valid_enclave_id(eid)                                          &&
+             old(tap_enclave_metadata_valid)[eid]                           &&
+             tap_enclave_metadata_owner_map[eid] == cpu_enclave_id          &&
+             (forall e : tap_enclave_id_t :: 
+                (old(tap_enclave_metadata_valid)[eid] ==> 
+                    tap_enclave_metadata_owner_map[eid] != cpu_enclave_id)) ==> (status == enclave_op_success));
+
     ensures (status == enclave_op_success || status == enclave_op_invalid_arg);
 
     //----------------------------------------------------------------------//
@@ -785,8 +971,17 @@ procedure block_memory_region(bmap : excl_map_t)
                     else cpu_owner_map[p] == old(cpu_owner_map)[p]);
     ensures (status != enclave_op_success) ==> 
                 old(cpu_owner_map) == cpu_owner_map;
-                 
-     
+    ensures (forall e : tap_enclave_id_t, v : vaddr_t :: 
+        (tap_enclave_metadata_valid[e] ==> 
+            tap_enclave_metadata_addr_excl[e][v] <==> cpu_owner_map[tap_enclave_metadata_addr_map[e][v]] == e)); 
+    ensures (forall e : tap_enclave_id_t, v : vaddr_t :: 
+        tap_enclave_metadata_valid[e] && 
+        (tap_enclave_metadata_privileged[e] || tap_enclave_metadata_privileged[tap_enclave_metadata_owner_map[e]]) ==> 
+            tap_enclave_metadata_addr_excl[e][v] <==> cpu_owner_map[tap_enclave_metadata_addr_map[e][v]] == e);
+    ensures (forall v : vaddr_t :: 
+        tap_enclave_metadata_valid[cpu_enclave_id] && 
+        (tap_enclave_metadata_privileged[cpu_enclave_id] || tap_enclave_metadata_privileged[tap_enclave_metadata_owner_map[cpu_enclave_id]]) ==> 
+            tap_enclave_metadata_addr_excl[cpu_enclave_id][v] <==> cpu_owner_map[cpu_addr_map[v]] == cpu_enclave_id);
 
    
 // -------------------------------------------------------------------- //
@@ -824,3 +1019,11 @@ procedure release_blocked_memory(bmap : excl_map_t)
     ensures (status != enclave_op_success) ==> 
                 (old(cpu_owner_map) == cpu_owner_map &&
                  old(cpu_mem) == cpu_mem);
+    ensures (forall e : tap_enclave_id_t, v : vaddr_t :: 
+        tap_enclave_metadata_valid[e] && 
+        (tap_enclave_metadata_privileged[e] || tap_enclave_metadata_privileged[tap_enclave_metadata_owner_map[e]]) ==> 
+            tap_enclave_metadata_addr_excl[e][v] <==> cpu_owner_map[tap_enclave_metadata_addr_map[e][v]] == e);
+    ensures (forall v : vaddr_t :: 
+        tap_enclave_metadata_valid[cpu_enclave_id] && 
+        (tap_enclave_metadata_privileged[cpu_enclave_id] || tap_enclave_metadata_privileged[tap_enclave_metadata_owner_map[cpu_enclave_id]]) ==> 
+            tap_enclave_metadata_addr_excl[cpu_enclave_id][v] <==> cpu_owner_map[cpu_addr_map[v]] == cpu_enclave_id);
diff --git a/AbstractPlatform/CPUImpl.bpl b/AbstractPlatform/CPUImpl.bpl
old mode 100644
new mode 100755
index 714e1f1..65f68f3
--- a/AbstractPlatform/CPUImpl.bpl
+++ b/AbstractPlatform/CPUImpl.bpl
@@ -3,17 +3,26 @@
 // -------------------------------------------------------------------- // 
 implementation initialize_tap()
 {
+  var untrusted_addr_valid : addr_valid_t;
+  var untrusted_addr_map   : addr_map_t;
+  var untrusted_pc         : vaddr_t;
+  var untrusted_regs       : regs_t;
+
   havoc untrusted_addr_map;
   havoc untrusted_addr_valid;
-  havoc untrusted_addr_map;
   havoc untrusted_pc;
   havoc untrusted_regs;
 
-  cpu_enclave_id := tap_null_enc_id;
-  cpu_addr_map := untrusted_addr_map;
-  cpu_addr_valid := untrusted_addr_valid;
-  cpu_pc := untrusted_pc;
-  cpu_regs := untrusted_regs;
+  tap_enclave_metadata_addr_valid[tap_null_enc_id]  := untrusted_addr_valid;
+  tap_enclave_metadata_addr_map[tap_null_enc_id]    := untrusted_addr_map;
+  tap_enclave_metadata_pc[tap_null_enc_id]          := untrusted_pc;
+  tap_enclave_metadata_regs[tap_null_enc_id]        := untrusted_regs;
+
+  cpu_enclave_id    := tap_null_enc_id;
+  cpu_addr_valid    := untrusted_addr_valid;
+  cpu_addr_map      := untrusted_addr_map;
+  cpu_pc            := untrusted_pc;
+  cpu_regs          := untrusted_regs;
   
   // memory is all zero'd out.
   havoc cpu_mem;
@@ -23,11 +32,18 @@ implementation initialize_tap()
   havoc cpu_owner_map;
   assume (forall pa : wap_addr_t :: cpu_owner_map[pa] == tap_null_enc_id);
   havoc tap_enclave_metadata_valid;
-  assume (forall e : tap_enclave_id_t :: !tap_enclave_metadata_valid[e]);
+  assume (tap_enclave_metadata_valid[tap_null_enc_id]);
+  assume (forall e : tap_enclave_id_t :: 
+            !valid_enclave_id(e) ==> !tap_enclave_metadata_valid[e]);
   // and that the PC is in sane state.
   assume (tap_addr_perm_x(cpu_addr_valid[cpu_pc]));
   assume (cpu_owner_map[cpu_addr_map[cpu_pc]] == cpu_enclave_id);
 
+  assume (forall e : tap_enclave_id_t :: 
+            (!valid_enclave_id(e) ==> !tap_enclave_metadata_privileged[e]));
+
+  assume tap_enclave_metadata_owner_map[tap_null_enc_id] == tap_null_enc_id;
+
   if (cpu_cache_enabled) {
       call init_cache();
   }
@@ -222,7 +238,8 @@ implementation launch(
   /* VA to PA mapping  */ addr_map        : addr_map_t,
   /* excl vaddr        */ excl_vaddr      : excl_vaddr_t,
   /* excl paddr        */ excl_paddr      : excl_map_t,
-  /* entrypoint.       */ entrypoint      : vaddr_t
+  /* entrypoint.       */ entrypoint      : vaddr_t,
+  /* privileged        */ privileged      : bool
 )
     returns (status : enclave_op_result_t)
 {
@@ -231,15 +248,24 @@ implementation launch(
     var paddr            : wap_addr_t;
     var va               : vaddr_t;
     var cache_conflict   : bool;
+    var launch_enable    : bool;
 
 
-    // ensure cpu mode is valid.
-    if (cpu_enclave_id != tap_null_enc_id) {
+    // ensures cpu mode is valid.
+    launch_enable := (cpu_enclave_id == tap_null_enc_id) || (tap_enclave_metadata_privileged[cpu_enclave_id]);
+    // launch_enable := (cpu_enclave_id == tap_null_enc_id);
+    if (!launch_enable) {
+        status := enclave_op_invalid_arg;
+        return;
+    }
+    
+    // do not support P-P launch for now
+    if (tap_enclave_metadata_privileged[cpu_enclave_id] && privileged) {
         status := enclave_op_invalid_arg;
         return;
     }
 
-    // ensure eid is valid.
+    // ensures eid is valid.
     if (!valid_enclave_id(eid) || tap_enclave_metadata_valid[eid]) {
         status := enclave_op_invalid_arg;
         return;
@@ -254,7 +280,7 @@ implementation launch(
         return;
     }
 
-    // Ensure none of the paddr's are already exclusive.
+    // Ensures none of the paddr's are already exclusive.
     paddr := k0_wap_addr_t;
     while (LT_wapa(paddr, kmax_wap_addr_t))
         invariant (forall pa : wap_addr_t ::
@@ -346,7 +372,8 @@ implementation launch(
     tap_enclave_metadata_regs[eid]           := kzero_regs_t;
     tap_enclave_metadata_paused[eid]         := false;
     tap_enclave_metadata_cache_conflict[eid] := cache_conflict;
-
+    tap_enclave_metadata_privileged[eid]     := privileged;
+    tap_enclave_metadata_owner_map[eid]      := cpu_enclave_id;
     status := enclave_op_success;
 }
 
@@ -359,25 +386,28 @@ implementation enter(eid: tap_enclave_id_t)
     // no enclave  no enclave id is null.
     // enclave must be valid and not paused.
     // cpu must be ready to execute enclaves.
-    if (!valid_enclave_id(eid)              ||
-        !tap_enclave_metadata_valid[eid]    ||
-        cpu_enclave_id != tap_null_enc_id)
+
+    if ((!valid_enclave_id(eid)) ||
+        (!tap_enclave_metadata_valid[eid]) ||
+        ((cpu_enclave_id != tap_null_enc_id) && (!tap_enclave_metadata_privileged[cpu_enclave_id])) ||
+        (tap_enclave_metadata_owner_map[eid] != cpu_enclave_id))
     {
         status := enclave_op_invalid_arg;
         return;
     }
 
-    status                      := enclave_op_success;
-    // save context.
-    untrusted_regs              := cpu_regs;
-    untrusted_addr_valid        := cpu_addr_valid;
-    untrusted_addr_map          := cpu_addr_map;
-    untrusted_pc                := cpu_pc;
+    status      := enclave_op_success;
+    // save owner context.
+    tap_enclave_metadata_pc[cpu_enclave_id]          := cpu_pc;
+    tap_enclave_metadata_regs[cpu_enclave_id]        := cpu_regs;
+    tap_enclave_metadata_addr_valid[cpu_enclave_id]  := cpu_addr_valid;
+    tap_enclave_metadata_addr_map[cpu_enclave_id]    := cpu_addr_map;
+
     // restore enclave context.
     cpu_enclave_id              := eid;
+    cpu_pc                      := tap_enclave_metadata_entrypoint[eid];
     cpu_addr_valid              := tap_enclave_metadata_addr_valid[eid];
     cpu_addr_map                := tap_enclave_metadata_addr_map[eid];
-    cpu_pc                      := tap_enclave_metadata_entrypoint[eid];
 }
 
 // -------------------------------------------------------------------- //
@@ -387,27 +417,30 @@ implementation resume(eid: tap_enclave_id_t)
     returns (status : enclave_op_result_t)
 
 {
-    if (!valid_enclave_id(eid)              ||
-        !tap_enclave_metadata_valid[eid]    || 
-        !tap_enclave_metadata_paused[eid]   ||
-        cpu_enclave_id != tap_null_enc_id)
+    if ((!valid_enclave_id(eid)) ||
+        (!tap_enclave_metadata_valid[eid]) ||
+        (!tap_enclave_metadata_paused[eid]) ||
+        ((cpu_enclave_id != tap_null_enc_id) && (!tap_enclave_metadata_privileged[cpu_enclave_id])) ||
+        (tap_enclave_metadata_owner_map[eid] != cpu_enclave_id))
     {
         status := enclave_op_invalid_arg;
         return;
     }
 
+    status := enclave_op_success;
+    // save owner context.
+    tap_enclave_metadata_pc[cpu_enclave_id]          := cpu_pc;
+    tap_enclave_metadata_regs[cpu_enclave_id]        := cpu_regs;
+    tap_enclave_metadata_addr_valid[cpu_enclave_id]  := cpu_addr_valid;
+    tap_enclave_metadata_addr_map[cpu_enclave_id]    := cpu_addr_map;
+
     // save context.
-    untrusted_regs                   := cpu_regs;
-    untrusted_addr_valid             := cpu_addr_valid;
-    untrusted_addr_map               := cpu_addr_map;
-    untrusted_pc                     := cpu_pc;
     // restore enclave context.
     cpu_enclave_id                   := eid;
-    cpu_addr_valid                   := tap_enclave_metadata_addr_valid[eid];
-    cpu_addr_map                     := tap_enclave_metadata_addr_map[eid];
     cpu_pc                           := tap_enclave_metadata_pc[eid];
     cpu_regs                         := tap_enclave_metadata_regs[eid];
-    status                           := enclave_op_success;
+    cpu_addr_valid                   := tap_enclave_metadata_addr_valid[eid];
+    cpu_addr_map                     := tap_enclave_metadata_addr_map[eid];
 }
 // -------------------------------------------------------------------- //
 // Exit an enclave.                                                     //
@@ -416,7 +449,7 @@ implementation exit()
     returns (status : enclave_op_result_t)
 {
     var eid : tap_enclave_id_t;
-
+    var owner_eid : tap_enclave_id_t;
     if (cpu_enclave_id == tap_null_enc_id) {
         status := enclave_op_failed;
         return;
@@ -430,12 +463,13 @@ implementation exit()
     tap_enclave_metadata_pc[eid]         := tap_enclave_metadata_entrypoint[eid];
     tap_enclave_metadata_paused[eid]     := false;
 
-    cpu_enclave_id := tap_null_enc_id;
-    cpu_regs       := untrusted_regs;
-    cpu_addr_valid := untrusted_addr_valid;
-    cpu_addr_map   := untrusted_addr_map;
-    cpu_pc         := untrusted_pc;
-    status         := enclave_op_success;
+    owner_eid := tap_enclave_metadata_owner_map[eid];
+    cpu_enclave_id := owner_eid;
+
+    cpu_pc         := tap_enclave_metadata_pc[owner_eid];
+    cpu_regs       := tap_enclave_metadata_regs[owner_eid];
+    cpu_addr_valid := tap_enclave_metadata_addr_valid[owner_eid];
+    cpu_addr_map   := tap_enclave_metadata_addr_map[owner_eid];
 }
 
 // -------------------------------------------------------------------- //
@@ -445,6 +479,7 @@ implementation pause()
     returns (status : enclave_op_result_t)
 {
     var eid : tap_enclave_id_t;
+    var owner_eid : tap_enclave_id_t;
 
     if (cpu_enclave_id == tap_null_enc_id) {
         status := enclave_op_failed;
@@ -459,12 +494,13 @@ implementation pause()
     tap_enclave_metadata_pc[eid]         := cpu_pc;
     tap_enclave_metadata_paused[eid]     := true;
 
-    cpu_enclave_id := tap_null_enc_id;
-    cpu_regs       := untrusted_regs;
-    cpu_addr_valid := untrusted_addr_valid;
-    cpu_addr_map   := untrusted_addr_map;
-    cpu_pc         := untrusted_pc;
-    status         := enclave_op_success;
+    owner_eid := tap_enclave_metadata_owner_map[eid];
+    cpu_enclave_id := owner_eid;
+    
+    cpu_pc         := tap_enclave_metadata_pc[owner_eid];
+    cpu_regs       := tap_enclave_metadata_regs[owner_eid];
+    cpu_addr_valid := tap_enclave_metadata_addr_valid[owner_eid];
+    cpu_addr_map   := tap_enclave_metadata_addr_map[owner_eid];
 }
 
 // -------------------------------------------------------------------- //
@@ -476,14 +512,18 @@ implementation destroy(eid: tap_enclave_id_t)
 {
     var pa : wap_addr_t;
     // no enclave id is null.
-    if (!valid_enclave_id(eid) || !tap_enclave_metadata_valid[eid] || cpu_enclave_id != tap_null_enc_id) {
+    if (!valid_enclave_id(eid) || 
+        !tap_enclave_metadata_valid[eid] || 
+         tap_enclave_metadata_owner_map[eid] != cpu_enclave_id || 
+        (exists e : tap_enclave_id_t :: 
+                (tap_enclave_metadata_valid[eid] &&
+                    tap_enclave_metadata_owner_map[eid] == cpu_enclave_id))) {
         status := enclave_op_invalid_arg;
         return;
     }
 
     assert (cpu_enclave_id != eid);
     assert tap_enclave_metadata_valid[eid];
-
     // we have to clear out the enclaves registers and memory.
     pa := k0_wap_addr_t;
     while (LT_wapa(pa, kmax_wap_addr_t))
diff --git a/AbstractPlatform/CacheConfidentialityProof.bpl b/AbstractPlatform/CacheConfidentialityProof.bpl
old mode 100644
new mode 100755
index b904b70..8a772a7
--- a/AbstractPlatform/CacheConfidentialityProof.bpl
+++ b/AbstractPlatform/CacheConfidentialityProof.bpl
@@ -14,10 +14,6 @@ procedure ProveConfidentialityCache(
     modifies cache_valid_map, cache_tag_map;
     modifies cache_valid_map_1, cache_tag_map_1;
     modifies cache_valid_map_2, cache_tag_map_2;
-    modifies untrusted_addr_valid;
-    modifies untrusted_addr_map;
-    modifies untrusted_regs;
-    modifies untrusted_pc;
     modifies tap_enclave_metadata_valid;
     modifies tap_enclave_metadata_addr_map;
     modifies tap_enclave_metadata_addr_valid;
@@ -27,6 +23,8 @@ procedure ProveConfidentialityCache(
     modifies tap_enclave_metadata_regs;
     modifies tap_enclave_metadata_paused;
     modifies tap_enclave_metadata_cache_conflict;
+    modifies tap_enclave_metadata_privileged;
+    modifies tap_enclave_metadata_owner_map;
     modifies cpu_mem_1;
     modifies cpu_regs_1;
     modifies cpu_pc_1;
@@ -34,10 +32,6 @@ procedure ProveConfidentialityCache(
     modifies cpu_addr_valid_1;
     modifies cpu_addr_map_1;
     modifies cpu_owner_map_1;
-    modifies untrusted_addr_valid_1;
-    modifies untrusted_addr_map_1;
-    modifies untrusted_regs_1;
-    modifies untrusted_pc_1;
     modifies tap_enclave_metadata_valid_1;
     modifies tap_enclave_metadata_addr_map_1;
     modifies tap_enclave_metadata_addr_valid_1;
@@ -47,6 +41,8 @@ procedure ProveConfidentialityCache(
     modifies tap_enclave_metadata_regs_1;
     modifies tap_enclave_metadata_paused_1;
     modifies tap_enclave_metadata_cache_conflict_1;
+    modifies tap_enclave_metadata_privileged_1;
+    modifies tap_enclave_metadata_owner_map_1;
     modifies cpu_mem_2;
     modifies cpu_regs_2;
     modifies cpu_pc_2;
@@ -54,10 +50,6 @@ procedure ProveConfidentialityCache(
     modifies cpu_addr_valid_2;
     modifies cpu_addr_map_2;
     modifies cpu_owner_map_2;
-    modifies untrusted_addr_valid_2;
-    modifies untrusted_addr_map_2;
-    modifies untrusted_regs_2;
-    modifies untrusted_pc_2;
     modifies tap_enclave_metadata_valid_2;
     modifies tap_enclave_metadata_addr_map_2;
     modifies tap_enclave_metadata_addr_valid_2;
@@ -67,6 +59,8 @@ procedure ProveConfidentialityCache(
     modifies tap_enclave_metadata_regs_2;
     modifies tap_enclave_metadata_paused_2;
     modifies tap_enclave_metadata_cache_conflict_2;
+    modifies tap_enclave_metadata_privileged_2;
+    modifies tap_enclave_metadata_owner_map_2;
 {
     var eid, r_eid                                   : tap_enclave_id_t;
     var status, status_1, status_2                   : enclave_op_result_t;
@@ -76,6 +70,7 @@ procedure ProveConfidentialityCache(
     var e_excl_map                                   : excl_map_t;
     var e_container_data_1, e_container_data_2       : container_data_t;
     var e_entrypoint_1, e_entrypoint_2               : vaddr_t;
+    var e_privileged                                 : bool;
     var current_mode, current_mode_1, current_mode_2 : mode_t;
     var enclave_dead, enclave_dead_1, enclave_dead_2 : bool;
     var observation_1, observation_2                 : word_t;
@@ -93,7 +88,9 @@ procedure ProveConfidentialityCache(
     var r_container_valid                            : container_valid_t;
     var r_container_data                             : container_data_t;
     var r_entrypoint                                 : vaddr_t;
+    var r_privileged                                 : bool;
     var r_pc                                         : vaddr_t;
+    var r_regs                                       : regs_t;
     var r_read                                       : regindex_t;
     var r_write                                      : regindex_t;
     var r_data                                       : word_t;
@@ -111,14 +108,14 @@ procedure ProveConfidentialityCache(
     var l_way_2, s_way_2                             : cache_way_index_t;
 
     // initial state.
-    call current_mode := InitialHavoc();
+    call current_mode := InitialHavoc(eid);
     assert tap_addr_perm_x(cpu_addr_valid[cpu_pc]);
     assert cpu_owner_map[cpu_addr_map[cpu_pc]] == cpu_enclave_id;
     assert cpu_enclave_id == tap_null_enc_id;
     // initialize the untrusted (OS) state with sane values.
-    untrusted_addr_valid := cpu_addr_valid;
-    untrusted_addr_map := cpu_addr_map;
-    untrusted_pc := cpu_pc;
+    tap_enclave_metadata_addr_valid[tap_null_enc_id] := cpu_addr_valid;
+    tap_enclave_metadata_addr_map[tap_null_enc_id] := cpu_addr_map;
+    tap_enclave_metadata_pc[tap_null_enc_id] := cpu_pc;
 
     // create two copies of state.
     call SaveContext_1();
@@ -130,7 +127,7 @@ procedure ProveConfidentialityCache(
     call RestoreContext_1();
     call InitOSMem(e_excl_map, e_container_data_1);
     call status := launch(eid, e_addr_valid_1, e_addr_map_1,
-                          e_excl_vaddr_1, e_excl_map, e_entrypoint_1);
+                          e_excl_vaddr_1, e_excl_map, e_entrypoint_1, e_privileged);
     assume tap_enclave_metadata_cache_conflict[eid] == cache_conflict;
     assume status == enclave_op_success;
     call SaveContext_1();
@@ -138,32 +135,99 @@ procedure ProveConfidentialityCache(
     call RestoreContext_2();
     call InitOSMem(e_excl_map, e_container_data_2);
     call status := launch(eid, e_addr_valid_2, e_addr_map_2,
-                          e_excl_vaddr_2, e_excl_map, e_entrypoint_2);
+                          e_excl_vaddr_2, e_excl_map, e_entrypoint_2, e_privileged);
     assume status == enclave_op_success;
     assume tap_enclave_metadata_cache_conflict[eid] == cache_conflict;
     call SaveContext_2();
 
+    assert valid_enclave_id(eid);
+
+
     // initial value of the observations.
     observation_1 := k0_word_t;
     observation_2 := k0_word_t;
 
     current_mode := mode_untrusted;
-    while (!enclave_dead)
-        //// The property ////
+    current_mode_1 := current_mode;
+    current_mode_2 := current_mode;
+
+    while (*)
+        // C Adversary: no cache set sharing
         invariant (!cache_conflict) ==> (observation_1 == observation_2);
         //// Cache ////
         // state that trusted cache lines do not conflict with untrusted lines.
+        // The cache between enclave and untrusted region is physically isolated.
+        // No tag-sync requirement:  do inspection on non-exclusive region is permitted.
+        // by Anonymous Author @ Apr 18, 2023.
         invariant (cpu_cache_enabled && !cache_conflict) ==>
                     (forall p1, p2 : wap_addr_t ::
                       (e_excl_map[p1] && !e_excl_map[p2]) ==>
                           (paddr2set(p1) != paddr2set(p2)));
-        invariant (!enclave_dead && cpu_cache_enabled && !cache_conflict) ==>
-                    (forall p : wap_addr_t, w : cache_way_index_t ::
-                      (!e_excl_map[p] && valid_cache_way_index(w)) ==>
-                        ((cache_valid_map_1[paddr2set(p), w] == cache_valid_map_2[paddr2set(p), w]) &&
-                         (cache_valid_map_1[paddr2set(p), w] && cache_valid_map_2[paddr2set(p), w] ==>
-                          (cache_tag_map_1[paddr2set(p), w] == cache_tag_map_2[paddr2set(p), w]))));
         //// General invariants /////
+        invariant !tap_enclave_metadata_privileged_1[tap_null_enc_id];
+        invariant !tap_enclave_metadata_privileged_2[tap_null_enc_id];
+        invariant tap_enclave_metadata_privileged_1[eid] == e_privileged;
+        invariant tap_enclave_metadata_privileged_2[eid] == e_privileged;
+
+        //  Apr 19, 2023
+        //  privileged relationship: multiple PE
+        invariant (forall e : tap_enclave_id_t :: 
+                (tap_enclave_metadata_valid_1[e] && tap_enclave_metadata_privileged_1[e]) ==> 
+                        (tap_enclave_metadata_owner_map_1[e] == tap_null_enc_id));
+        invariant (forall e : tap_enclave_id_t :: 
+                (tap_enclave_metadata_valid_2[e] && tap_enclave_metadata_privileged_2[e]) ==> 
+                        (tap_enclave_metadata_owner_map_2[e] == tap_null_enc_id));
+
+        // valid guarantee
+        invariant tap_enclave_metadata_valid_1[tap_null_enc_id];
+        invariant tap_enclave_metadata_valid_2[tap_null_enc_id];
+        invariant (forall e : tap_enclave_id_t :: 
+                    special_enclave_id(e) ==> !tap_enclave_metadata_valid_1[e]);
+        invariant (forall e: tap_enclave_id_t :: 
+                    special_enclave_id(e) ==> !tap_enclave_metadata_valid_2[e]);
+
+        // enclave ownermap relationship: valid enclave's parent must be valid
+        invariant (forall e : tap_enclave_id_t :: tap_enclave_metadata_valid_1[e] ==>
+                    (tap_enclave_metadata_valid_1[tap_enclave_metadata_owner_map_1[e]]));
+        invariant (forall e : tap_enclave_id_t :: tap_enclave_metadata_valid_2[e] ==> 
+                    (tap_enclave_metadata_valid_2[tap_enclave_metadata_owner_map_2[e]]));
+
+        // enclave ownermap relationship: special children
+        invariant tap_enclave_metadata_owner_map_1[eid] == tap_null_enc_id;
+        invariant tap_enclave_metadata_owner_map_2[eid] == tap_null_enc_id;
+        invariant tap_enclave_metadata_owner_map_1[tap_null_enc_id] == tap_null_enc_id;
+        invariant tap_enclave_metadata_owner_map_2[tap_null_enc_id] == tap_null_enc_id;
+
+        // enclave ownermap relationship: the maximal parent-tree depth is 2 
+        invariant (forall e : tap_enclave_id_t :: (tap_enclave_metadata_valid_1[e]) ==> 
+                    (tap_enclave_metadata_owner_map_1[tap_enclave_metadata_owner_map_1[e]] == tap_null_enc_id));
+        invariant (forall e : tap_enclave_id_t :: (tap_enclave_metadata_valid_2[e]) ==> 
+                    (tap_enclave_metadata_owner_map_2[tap_enclave_metadata_owner_map_2[e]] == tap_null_enc_id));
+
+        // enclave ownermap relationship: enclave with chidren must be privileged 
+        invariant (forall e : tap_enclave_id_t :: 
+                    (tap_enclave_metadata_valid_1[e] && tap_enclave_metadata_owner_map_1[e] != tap_null_enc_id) ==> 
+                        (tap_enclave_metadata_privileged_1[tap_enclave_metadata_owner_map_1[e]]));
+        invariant (forall e : tap_enclave_id_t :: 
+                    (tap_enclave_metadata_valid_2[e] && tap_enclave_metadata_owner_map_2[e] != tap_null_enc_id) ==> 
+                        (tap_enclave_metadata_privileged_2[tap_enclave_metadata_owner_map_2[e]]));
+        
+        // extend the exclusive-memory consistency to PE and NE children.
+        // 1.   constrain this consistency to PE-controlled enclave.
+        invariant (forall e : tap_enclave_id_t, v : vaddr_t :: 
+                    (tap_enclave_metadata_valid_1[e] && (tap_enclave_metadata_privileged_1[e] || tap_enclave_metadata_privileged_1[tap_enclave_metadata_owner_map_1[e]]) ==> 
+                        (tap_enclave_metadata_addr_excl_1[e][v] <==> cpu_owner_map_1[tap_enclave_metadata_addr_map_1[e][v]] == e)));
+        invariant (forall e : tap_enclave_id_t, v : vaddr_t :: 
+                    (tap_enclave_metadata_valid_2[e] && (tap_enclave_metadata_privileged_2[e] || tap_enclave_metadata_privileged_2[tap_enclave_metadata_owner_map_2[e]]) ==> 
+                        (tap_enclave_metadata_addr_excl_2[e][v] <==> cpu_owner_map_2[tap_enclave_metadata_addr_map_2[e][v]] == e)));
+        // 2.   constraint this consistency to PE.
+        invariant (forall v : vaddr_t :: 
+                    (tap_enclave_metadata_privileged_1[cpu_enclave_id_1] || tap_enclave_metadata_privileged_1[tap_enclave_metadata_owner_map_1[cpu_enclave_id_1]]) ==> 
+                        (tap_enclave_metadata_addr_excl_1[cpu_enclave_id_1][v] <==> cpu_owner_map_1[cpu_addr_map_1[v]] == cpu_enclave_id_1));
+        invariant (forall v : vaddr_t :: 
+                    (tap_enclave_metadata_privileged_2[cpu_enclave_id_2] || tap_enclave_metadata_privileged_2[tap_enclave_metadata_owner_map_2[cpu_enclave_id_2]]) ==> 
+                        (tap_enclave_metadata_addr_excl_2[cpu_enclave_id_2][v] <==> cpu_owner_map_2[cpu_addr_map_2[v]] == cpu_enclave_id_2));
+        
         invariant current_mode == mode_untrusted || current_mode == mode_enclave;
         // memory is not assigned to an enclave that doesn't exist.
         invariant (forall pa : wap_addr_t, e : tap_enclave_id_t ::
@@ -175,44 +239,38 @@ procedure ProveConfidentialityCache(
         //-------------------------------------------------------------------//
         // CPU mode and CPU enclave ID must be consistent.
         //-------------------------------------------------------------------//
-        invariant (forall e : tap_enclave_id_t :: 
-                    !valid_enclave_id(e) ==> !tap_enclave_metadata_valid_1[tap_null_enc_id]);
-        invariant (forall e : tap_enclave_id_t ::
-                    !valid_enclave_id(e) ==> !tap_enclave_metadata_valid_2[tap_null_enc_id]);
-        invariant (current_mode == mode_untrusted) ==> cpu_enclave_id_1 != eid;
-        invariant (current_mode == mode_untrusted) ==> cpu_enclave_id_2 != eid;
+        invariant (current_mode == mode_untrusted) ==> (cpu_enclave_id_1 != eid);
+        invariant (current_mode == mode_untrusted) ==> (cpu_enclave_id_2 != eid);
         invariant (current_mode == mode_enclave) ==> (cpu_enclave_id_1 == eid);
         invariant (current_mode == mode_enclave) ==> (cpu_enclave_id_2 == eid);
         //-------------------------------------------------------------------//
         // Enclave 'eid' is mostly alive                                     //
         //-------------------------------------------------------------------//
+        invariant (valid_enclave_id(eid));
         invariant (cpu_enclave_id_1 != tap_blocked_enc_id);
         invariant (cpu_enclave_id_2 != tap_blocked_enc_id);
-        invariant (valid_enclave_id(eid));
-        invariant (!enclave_dead ==> tap_enclave_metadata_valid_1[eid]);
-        invariant (!enclave_dead ==> tap_enclave_metadata_valid_2[eid]);
+        invariant (tap_enclave_metadata_valid_1[eid]);
+        invariant (tap_enclave_metadata_valid_2[eid]);
         // maintain invariants about excl_vaddr.
-        invariant (!enclave_dead) ==>
-                        (tap_enclave_metadata_addr_excl_1[eid] == e_excl_vaddr_1);
-        invariant (!enclave_dead) ==>
-                        (tap_enclave_metadata_addr_excl_2[eid] == e_excl_vaddr_2);
+        invariant tap_enclave_metadata_addr_excl_1[eid] == e_excl_vaddr_1;
+        invariant tap_enclave_metadata_addr_excl_2[eid] == e_excl_vaddr_2;
         // invariants about addr_map
         invariant (forall v : vaddr_t ::
-                      (!enclave_dead && e_excl_vaddr_1[v]) ==>
-                          (tap_enclave_metadata_addr_map_1[eid][v] == e_addr_map_1[v]));
+                      e_excl_vaddr_1[v] ==>
+                          tap_enclave_metadata_addr_map_1[eid][v] == e_addr_map_1[v]);
         invariant (forall v : vaddr_t ::
-                      (!enclave_dead && e_excl_vaddr_2[v]) ==>
-                          (tap_enclave_metadata_addr_map_2[eid][v] == e_addr_map_2[v]));
+                      e_excl_vaddr_2[v] ==>
+                          tap_enclave_metadata_addr_map_2[eid][v] == e_addr_map_2[v]);
         // invariants about e_excl_addr
         invariant (forall p : wap_addr_t ::
-                    (!enclave_dead) ==> ((cpu_owner_map_1[p] == eid) <==> e_excl_map[p]));
+                    (cpu_owner_map_1[p] == eid) <==> e_excl_map[p]);
         invariant (forall p : wap_addr_t ::
-                    (!enclave_dead) ==> ((cpu_owner_map_2[p] == eid) <==> e_excl_map[p]));
+                    (cpu_owner_map_2[p] == eid) <==> e_excl_map[p]);
         invariant (forall v : vaddr_t, p : wap_addr_t ::
-                        (!enclave_dead && e_excl_vaddr_1[v] && p == e_addr_map_1[v])
+                        (e_excl_vaddr_1[v] && p == e_addr_map_1[v])
                             ==> e_excl_map[p]);
         invariant (forall v : vaddr_t, p : wap_addr_t ::
-                        (!enclave_dead && e_excl_vaddr_2[v] && p == e_addr_map_2[v])
+                        (e_excl_vaddr_2[v] && p == e_addr_map_2[v])
                             ==> e_excl_map[p]);
         //-------------------------------------------------------------------//
         // Now deal with the enclaves.
@@ -226,6 +284,7 @@ procedure ProveConfidentialityCache(
         //-------------------------------------------------------------------//
         // CPU state is the same                                             //
         //-------------------------------------------------------------------//
+        invariant (current_mode_1 == current_mode_2);
         // same PC.
         invariant (current_mode == mode_untrusted) ==> (cpu_pc_1 == cpu_pc_2);
         // same mode of operation.
@@ -233,30 +292,48 @@ procedure ProveConfidentialityCache(
         // same regs.
         invariant (current_mode == mode_untrusted) ==> (cpu_regs_1 == cpu_regs_2);
         // same va->pa.
-        invariant (current_mode == mode_untrusted) ==>
-                    (cpu_addr_valid_1 == cpu_addr_valid_2);
-        invariant (current_mode == mode_untrusted) ==>
-                        (cpu_addr_map_1 == cpu_addr_map_2);
+        invariant (current_mode == mode_untrusted) ==> (cpu_addr_valid_1 == cpu_addr_valid_2);
+        invariant (current_mode == mode_untrusted) ==> (cpu_addr_map_1 == cpu_addr_map_2);
         // owner map is the same.
         invariant (forall pa : wap_addr_t :: (cpu_owner_map_1[pa] == cpu_owner_map_2[pa]));
         // memory is the same except for the enclave memory.
         invariant (forall pa : wap_addr_t :: !e_excl_map[pa] ==> (cpu_mem_1[pa] == cpu_mem_2[pa]));
+
+        invariant (current_mode == mode_untrusted) ==> (tap_enclave_metadata_valid_1[cpu_enclave_id_1]);
+        invariant (current_mode == mode_untrusted) ==> (tap_enclave_metadata_valid_2[cpu_enclave_id_2]);
+
+        invariant (tap_enclave_metadata_valid_1[eid] && tap_enclave_metadata_valid_2[eid]);
         //-------------------------------------------------------------------//
-        //// OS state is the same ////
+        // OS state is the same                                              //
         //-------------------------------------------------------------------//
-        // OS va->pa
-        invariant (untrusted_addr_valid_1 == untrusted_addr_valid_2);
-        invariant (untrusted_addr_map_1 == untrusted_addr_map_2);
+        // OS va->pa 
+        invariant (tap_enclave_metadata_addr_valid_1[tap_null_enc_id] == tap_enclave_metadata_addr_valid_2[tap_null_enc_id]);
+        invariant (tap_enclave_metadata_addr_map_1[tap_null_enc_id] == tap_enclave_metadata_addr_map_2[tap_null_enc_id]);
         // OS regs.
-        invariant (untrusted_regs_1 == untrusted_regs_2);
-        invariant (untrusted_pc_1 == untrusted_pc_2);
+        invariant (tap_enclave_metadata_regs_1[tap_null_enc_id] == tap_enclave_metadata_regs_2[tap_null_enc_id]);
+        invariant (tap_enclave_metadata_pc_1[tap_null_enc_id] == tap_enclave_metadata_pc_2[tap_null_enc_id]);
+        
+        // Stronger: applied for OS and all other NE
+        invariant (forall e : tap_enclave_id_t :: (tap_enclave_metadata_valid[e] && e != eid) ==> 
+            (tap_enclave_metadata_addr_valid_1[e] == tap_enclave_metadata_addr_valid_2[e]));
+        invariant (forall e : tap_enclave_id_t :: (tap_enclave_metadata_valid[e] && e != eid) ==>
+            (tap_enclave_metadata_addr_map_1[e] == tap_enclave_metadata_addr_map_2[e]));
+        invariant (forall e : tap_enclave_id_t :: (tap_enclave_metadata_valid[e] && e != eid) ==> 
+            (tap_enclave_metadata_regs_1[e] == tap_enclave_metadata_regs_2[e]));
+        invariant (forall e : tap_enclave_id_t :: (tap_enclave_metadata_valid[e] && e != eid) ==> 
+            (tap_enclave_metadata_pc_1[e] == tap_enclave_metadata_pc_2[e]));
+
+
         //-------------------------------------------------------------------//
         // Enclave state is the same except for eid (mostly). Some it is the //
         // the same for eid as well (addr_map and addr_excl).                //
         //-------------------------------------------------------------------//
+
         // valid is the same except for eid.
         invariant (forall e : tap_enclave_id_t :: (e != eid) ==>
                     (tap_enclave_metadata_valid_1[e] == tap_enclave_metadata_valid_2[e]));
+
+
         // addr valid is the same except for eid.
         invariant (forall e : tap_enclave_id_t ::
                     (tap_enclave_metadata_valid_1[e] && tap_enclave_metadata_valid_2[e] && e != eid) ==>
@@ -285,66 +362,112 @@ procedure ProveConfidentialityCache(
         invariant (forall e : tap_enclave_id_t ::
                     (tap_enclave_metadata_valid_1[e] && tap_enclave_metadata_valid_2[e]) ==>
                         (tap_enclave_metadata_paused_1[e] == tap_enclave_metadata_paused_2[e]));
+                
+        // invariants about state sync between 2 traces.
+        // OS/NE sync.
+        invariant (current_mode == mode_untrusted) ==> 
+                    (cpu_enclave_id_1 == tap_null_enc_id ==> 
+                        cpu_enclave_id_2 == tap_null_enc_id);
+        invariant (current_mode == mode_untrusted) ==> 
+            ((cpu_enclave_id_1 != tap_null_enc_id && tap_enclave_metadata_owner_map_1[cpu_enclave_id_1] == tap_null_enc_id) ==> 
+                tap_enclave_metadata_owner_map_2[cpu_enclave_id_2] == tap_null_enc_id);
+        // due to Z3 prover's features, we add some trivial claims in the precondition of this claim.
+        invariant (current_mode == mode_untrusted && cpu_enclave_id_1 != tap_null_enc_id && cpu_enclave_id_1 != eid && tap_enclave_metadata_owner_map_1[cpu_enclave_id_1] == eid) ==> 
+            (cpu_enclave_id_1 == cpu_enclave_id_2);
+
+        // OS/NE & PE sync: stronger.
+        invariant (forall e : tap_enclave_id_t :: 
+            (tap_enclave_metadata_valid_1[e] && tap_enclave_metadata_valid_2[e]) ==> 
+                tap_enclave_metadata_owner_map_1[e] == tap_enclave_metadata_owner_map_2[e]);
+        // In confidentiality, we keep the adversary be same.
+        invariant (forall e: tap_enclave_id_t ::
+            tap_enclave_metadata_privileged_1[e] <==> tap_enclave_metadata_privileged_2[e]);        
+        // PE sync. the PE's structure must be same.
+        // invariant (forall e : tap_enclave_id_t :: 
+        //     (tap_enclave_metadata_valid_1[e] && tap_enclave_metadata_owner_map_1[e] == eid) <==> 
+        //         (tap_enclave_metadata_valid_2[e] && tap_enclave_metadata_owner_map_2[e] == eid));
+
+        invariant (forall e : tap_enclave_id_t :: 
+                    (tap_enclave_metadata_valid_1[e] && tap_enclave_metadata_owner_map_1[e] == eid) ==> 
+                        tap_enclave_metadata_paused_1[e] == tap_enclave_metadata_paused_2[e]);
+
     {
-        if (current_mode == mode_untrusted) {
-            havoc r_proof_op, r_eid, r_pc, r_read, r_write, r_data,
-                  l_vaddr, s_vaddr, s_data, r_pt_eid, r_pt_va,
-                  pt_eid, pt_vaddr, pt_valid, pt_paddr, r_addr_valid,
-                  r_addr_map, r_excl_vaddr, r_excl_map, r_bmap,
-                  r_container_valid, r_container_data, r_entrypoint, r_l_way, r_s_way;
+        havoc r_proof_op, r_eid, r_pc, r_regs, r_read, r_write, r_data, 
+                l_vaddr, s_vaddr, s_data, r_pt_eid, r_pt_va, 
+                pt_eid, pt_vaddr, pt_valid, pt_paddr, r_addr_valid, 
+                r_addr_map, r_excl_vaddr, r_excl_map, r_bmap,
+                r_container_valid, r_container_data, r_entrypoint, r_privileged, r_l_way, r_s_way;
 
+        if (current_mode == mode_untrusted) {
+            // assume false;
+            assume tap_proof_op_valid(r_proof_op);
             assume valid_regindex(r_read);
             assume valid_regindex(r_write);
             assume valid_cache_way_index(r_l_way);
             assume valid_cache_way_index(r_s_way);
+
+            call r_addr_valid, r_addr_map, r_excl_vaddr, r_excl_map, r_entrypoint, r_privileged := LaunchInputHavoc(r_eid);
+
             // trace_1
             call RestoreContext_1();
             call observation_1, current_mode_1, enclave_dead_1, status_1 :=
-                                    ObserverStep(k_cache_observer_t, current_mode, eid, r_eid, r_proof_op,
-                                                r_pc, r_read, r_write, r_data,
+                                    ObserverStep(k_mem_observer_t, current_mode, eid, r_eid, 
+                                                r_addr_valid, r_addr_map, r_excl_vaddr, r_excl_map, r_entrypoint, r_privileged, 
+                                                r_proof_op, 
+                                                r_pc, r_read, r_write, r_data, 
                                                 l_vaddr, s_vaddr, s_data,
                                                 r_pt_eid, r_pt_va,
                                                 pt_eid, pt_vaddr, pt_valid, pt_paddr,
-                                                r_addr_valid, r_addr_map, r_excl_vaddr,
-                                                r_excl_map, r_container_valid, r_container_data,
-                                                r_entrypoint, r_bmap,
+                                                r_container_valid, r_container_data, r_bmap,
                                                 r_l_way, r_s_way);
             call SaveContext_1();
 
             // trace_2
             call RestoreContext_2();
             call observation_2, current_mode_2, enclave_dead_2, status_2 :=
-                                    ObserverStep(k_cache_observer_t, current_mode, eid, r_eid, r_proof_op,
-                                                r_pc, r_read, r_write, r_data,
+                                    ObserverStep(k_mem_observer_t, current_mode, eid, r_eid, 
+                                                r_addr_valid, r_addr_map, r_excl_vaddr, r_excl_map, r_entrypoint, r_privileged, 
+                                                r_proof_op, 
+                                                r_pc, r_read, r_write, r_data, 
                                                 l_vaddr, s_vaddr, s_data,
                                                 r_pt_eid, r_pt_va,
                                                 pt_eid, pt_vaddr, pt_valid, pt_paddr,
-                                                r_addr_valid, r_addr_map, r_excl_vaddr,
-                                                r_excl_map, r_container_valid, r_container_data,
-                                                r_entrypoint, r_bmap,
+                                                r_container_valid, r_container_data, r_bmap,
                                                 r_l_way, r_s_way);
             call SaveContext_2();
 
             // some sanity checks.
             assert status_1 == status_2;
             assert current_mode_1 == current_mode_2;
-            assert enclave_dead_1 == enclave_dead_2;
             current_mode := current_mode_1;
-            enclave_dead := enclave_dead_2;
         } else {
-            havoc e_proof_op;
-            assume tap_proof_op_valid_in_enclave(e_proof_op);
+            // assume false;
+            havoc e_proof_op;            
+            if (e_privileged) {
+                assume tap_proof_op_valid_in_privileged(e_proof_op);
+
+            } else {
+                assume tap_proof_op_valid_in_enclave(e_proof_op);
 
+            }
+
+            call r_addr_valid, r_addr_map, r_excl_vaddr, r_excl_map, r_entrypoint, r_privileged := LaunchInputHavoc(r_eid);
             // trace_1
             call RestoreContext_1();
-            call current_mode_1, load_addr_1, l_way_1, store_addr_1, store_data_1, s_way_1 :=
-                            EnclaveStep(current_mode, eid, e_proof_op);
+            call current_mode_1, load_addr_1, l_way_1, store_addr_1, store_data_1, s_way_1, status_1 := 
+                            EnclaveStep(current_mode, eid, r_eid, 
+                                        r_addr_valid, r_addr_map, r_excl_vaddr, r_excl_map, r_entrypoint, r_privileged, 
+                                        r_container_valid, r_container_data,
+                                        r_regs, e_proof_op);
             call SaveContext_1();
 
             // trace_1
             call RestoreContext_2();
-            call current_mode_2, load_addr_2, l_way_2, store_addr_2, store_data_2, s_way_2 :=
-                            EnclaveStep(current_mode, eid, e_proof_op);
+            call current_mode_2, load_addr_2, l_way_2, store_addr_2, store_data_2, s_way_2, status_2 :=
+                            EnclaveStep(current_mode, eid, r_eid, 
+                                        r_addr_valid, r_addr_map, r_excl_vaddr, r_excl_map, r_entrypoint, r_privileged,
+                                        r_container_valid, r_container_data,
+                                        r_regs, e_proof_op);
             call SaveContext_2();
 
             // some sanity checks.
@@ -355,6 +478,7 @@ procedure ProveConfidentialityCache(
             assume (!e_excl_vaddr_1[load_addr_1] || !e_excl_vaddr_2[load_addr_2]) ==>
                        (load_addr_1 == load_addr_2 && l_way_1 == l_way_2 &&
                         cpu_addr_map_1[load_addr_1] == cpu_addr_map_2[load_addr_2]);
+
             assume (!e_excl_vaddr_1[store_addr_1] || !e_excl_vaddr_2[store_addr_2]) ==>
                        (store_addr_1 == store_addr_2 && store_data_1 == store_data_2 && s_way_1 == s_way_2 &&
                         cpu_addr_map_1[store_addr_1] == cpu_addr_map_2[store_addr_2]);
diff --git a/AbstractPlatform/ConfidentialityProof.bpl b/AbstractPlatform/ConfidentialityProof.bpl
old mode 100644
new mode 100755
index 3bf7f84..29d1deb
--- a/AbstractPlatform/ConfidentialityProof.bpl
+++ b/AbstractPlatform/ConfidentialityProof.bpl
@@ -18,12 +18,10 @@ procedure {:inline 1} MemObserverComputation(
     modifies cpu_regs;
     modifies cpu_pc;
     modifies cache_valid_map, cache_tag_map;
-    modifies untrusted_addr_valid;
     modifies cpu_addr_valid;
     modifies cpu_addr_map;
     modifies tap_enclave_metadata_addr_valid;
     modifies tap_enclave_metadata_addr_map;
-    modifies untrusted_addr_map;
 {
     var excp         : exception_t;
     var l_word       : word_t;
@@ -42,7 +40,7 @@ procedure {:inline 1} MemObserverComputation(
     // store
     call excp, hit_1 := store_va(s_vaddr, s_data, s_way);
     // load
-    call l_word, excp, hit_2 := load_va(l_vaddr, l_way);
+    call l_word, excp, hit_2 := load_va(cpu_enclave_id, l_vaddr, l_way);
     r_word := cpu_regs[r_read];
     observation := uf_observation_mem(cpu_pc, l_word, r_word);
 
@@ -73,10 +71,8 @@ procedure {:inline 1} CacheObserverComputation(
     modifies cache_valid_map, cache_tag_map;
     modifies tap_enclave_metadata_addr_valid;
     modifies tap_enclave_metadata_addr_map;
-    modifies untrusted_addr_valid;
     modifies cpu_addr_valid;
     modifies cpu_addr_map;
-    modifies untrusted_addr_map;
 {
     var excp         : exception_t;
     var l_word       : word_t;
@@ -90,7 +86,7 @@ procedure {:inline 1} CacheObserverComputation(
     cpu_regs[r_write] := r_data;
     call excp, hit_1 := store_va(s_vaddr, s_data, s_way);
     call valid, paddr := get_enclave_addr_map(r_pt_eid, r_pt_va);
-    call l_word, excp, hit_2 := load_va(l_vaddr, l_way);
+    call l_word, excp, hit_2 := load_va(cpu_enclave_id, l_vaddr, l_way);
     r_word := cpu_regs[r_read];
     observation := uf_observation_cache(hit_1, hit_2);
 
@@ -116,12 +112,10 @@ procedure {:inline 1} PTObserverComputation(
     modifies cpu_regs;
     modifies cpu_pc;
     modifies cache_valid_map, cache_tag_map;
-    modifies untrusted_addr_valid;
     modifies tap_enclave_metadata_addr_valid;
     modifies tap_enclave_metadata_addr_map;
     modifies cpu_addr_valid;
     modifies cpu_addr_map;
-    modifies untrusted_addr_map;
 {
     var excp         : exception_t;
     var l_word       : word_t;
@@ -155,6 +149,12 @@ procedure {:inline 1} ObserverStep(
     /* Current mode      */ mode              : mode_t,
     /* Secret Enclave    */ eid               : tap_enclave_id_t,
     /* Adversary Enclave */ r_eid             : tap_enclave_id_t,
+                            r_addr_valid      : addr_valid_t,
+                            r_addr_map        : addr_map_t,
+                            r_excl_vaddr      : excl_vaddr_t,
+                            r_excl_map        : excl_map_t,
+                            r_entrypoint      : vaddr_t,
+                            r_privileged      : bool,
     /* Operation.        */ op                : tap_proof_op_t,
     /* next PC value.    */ r_pc              : vaddr_t,
     /* reg to read.      */ r_read            : regindex_t,
@@ -169,13 +169,8 @@ procedure {:inline 1} ObserverStep(
     /* pt vaddr          */ pt_vaddr          : vaddr_t,
     /* pt valid          */ pt_valid          : addr_perm_t,
     /* pt paddr          */ pt_paddr          : wap_addr_t,
-    /* VA->PA valid      */ r_addr_valid      : addr_valid_t,
-    /* VA->PA map        */ r_addr_map        : addr_map_t,
-    /* VA->excl map      */ r_excl_vaddr      : excl_vaddr_t,
-    /* Private Mem Map   */ r_excl_map        : excl_map_t,
     /* Container Valid   */ r_container_valid : container_valid_t,
     /* Container Data    */ r_container_data  : container_data_t,
-    /* Entrypoint        */ r_entrypoint      : vaddr_t,
     /* blocked mem       */ r_bmap            : excl_map_t,
     /* ways to change.   */ l_way, s_way      : cache_way_index_t)
 
@@ -199,10 +194,6 @@ procedure {:inline 1} ObserverStep(
     modifies cpu_addr_map;
     modifies cpu_owner_map;
     modifies cache_valid_map, cache_tag_map;
-    modifies untrusted_addr_valid;
-    modifies untrusted_addr_map;
-    modifies untrusted_regs;
-    modifies untrusted_pc;
     modifies tap_enclave_metadata_valid;
     modifies tap_enclave_metadata_addr_map;
     modifies tap_enclave_metadata_addr_valid;
@@ -212,6 +203,8 @@ procedure {:inline 1} ObserverStep(
     modifies tap_enclave_metadata_regs;
     modifies tap_enclave_metadata_paused;
     modifies tap_enclave_metadata_cache_conflict;
+    modifies tap_enclave_metadata_privileged;
+    modifies tap_enclave_metadata_owner_map;
 {
     // "default" for the next mode.
     next_mode := mode;
@@ -240,18 +233,20 @@ procedure {:inline 1} ObserverStep(
                                                       pt_eid, pt_vaddr, pt_valid, pt_paddr);
         }
     } else if (op == tap_proof_op_launch) {
-        // can't put current pc inside the enclave.
-        assume !r_excl_map[cpu_addr_map[cpu_pc]];
+        assume !tap_enclave_metadata_valid[r_eid];
         call InitOSMem(r_container_valid, r_container_data);
+        // can't put current pc inside the enclave.
         call status := launch(r_eid, r_addr_valid, r_addr_map, 
-                              r_excl_vaddr, r_excl_map, r_entrypoint);
+                              r_excl_vaddr, r_excl_map, r_entrypoint, r_privileged);
         assert (r_eid == eid) ==> (status != enclave_op_success);
+
     } else if (op == tap_proof_op_destroy) {
         call status := destroy(r_eid);
         // the enclave has been destroyed.
         if (r_eid == eid && status == enclave_op_success) {
             enclave_dead := true;
         }
+
     } else if (op == tap_proof_op_enter) {
         call status := enter(r_eid);
         assert (cpu_enclave_id == tap_null_enc_id && r_eid == eid) ==> 
@@ -260,8 +255,14 @@ procedure {:inline 1} ObserverStep(
         if (r_eid == eid && status == enclave_op_success) {
             next_mode := mode_enclave;
         }
+
     } else if (op == tap_proof_op_exit) {
         call status := exit();
+        if (status == enclave_op_success && cpu_enclave_id == eid) {
+            next_mode := mode_enclave;
+        }
+        assert (cpu_enclave_id == tap_null_enc_id) || tap_enclave_metadata_privileged[cpu_enclave_id];
+
     } else if (op == tap_proof_op_resume) {
         call status := resume(r_eid);
         // switch to enclave mode.
@@ -270,24 +271,43 @@ procedure {:inline 1} ObserverStep(
         if (r_eid == eid && status == enclave_op_success) {
             next_mode := mode_enclave;
         }
+
     } else if (op == tap_proof_op_pause) {
         call status := pause();
+        if (status == enclave_op_success && cpu_enclave_id == eid) {
+            next_mode := mode_enclave;
+        }
+        assert (cpu_enclave_id == tap_null_enc_id) || tap_enclave_metadata_privileged[cpu_enclave_id];
+
     } else if (op == tap_proof_op_release) {
         call status := release_blocked_memory(r_bmap);
+
     } else if (op == tap_proof_op_block) {
         call status := block_memory_region(r_bmap);
+
     }
 }
 
 procedure {:inline 1} EnclaveStep(
     /* Current mode */      mode              : mode_t,
     /* Secret Enclave */    eid               : tap_enclave_id_t,
+    /* primtive target */   r_eid             : tap_enclave_id_t,
+    /* launch inputs   */   r_addr_valid      : addr_valid_t,
+                            r_addr_map        : addr_map_t,
+                            r_excl_vaddr      : excl_vaddr_t,
+                            r_excl_map        : excl_map_t,
+                            r_entrypoint      : vaddr_t,
+                            r_privileged      : bool,
+                            r_container_valid : container_valid_t,
+                            r_container_data  : container_data_t,
+    /* enter inputs   */    r_regs            : regs_t,
     /* Operation. */        op                : tap_proof_op_t)
 
     returns (
         /* mode     */  next_mode : mode_t, 
         /* read     */  load_addr : vaddr_t, l_way : cache_way_index_t,
-        /* store    */  store_addr : vaddr_t, store_data : word_t, s_way : cache_way_index_t
+        /* store    */  store_addr : vaddr_t, store_data : word_t, s_way : cache_way_index_t,
+        /* status   */  status : enclave_op_result_t
     )
     
     modifies cpu_mem;
@@ -302,62 +322,166 @@ procedure {:inline 1} EnclaveStep(
     modifies tap_enclave_metadata_addr_map;
     modifies tap_enclave_metadata_addr_valid;
     modifies tap_enclave_metadata_addr_excl;
+    modifies tap_enclave_metadata_entrypoint;
     modifies tap_enclave_metadata_pc;
     modifies tap_enclave_metadata_regs;
     modifies tap_enclave_metadata_paused;
     modifies tap_enclave_metadata_cache_conflict;
+    modifies tap_enclave_metadata_privileged;
+    modifies tap_enclave_metadata_owner_map;
 {
     var vaddr  : vaddr_t;
     var word   : word_t;
     var excp   : exception_t;
-    var status : enclave_op_result_t;
+    // var status : enclave_op_result_t;
     var hit    : bool;
     var owner  : tap_enclave_id_t;
     var way    : cache_way_index_t;
+    var i_eid   : tap_enclave_id_t;
+    var is_invalid_id : bool;
+    var regs   : regs_t;
 
-    if (op == tap_proof_op_compute) {
-        // do whatever.
-        havoc cpu_regs;
-        havoc cpu_pc;
-
-        // fetch from whereever inside the enclave.
-        assume tap_enclave_metadata_addr_excl[eid][cpu_pc];
-        assume tap_addr_perm_x(cpu_addr_valid[cpu_pc]);
-        assert cpu_owner_map[cpu_addr_map[cpu_pc]] == eid;
-        havoc way; assume valid_cache_way_index(way);
-        call word, excp, hit := fetch_va(cpu_pc, way);
-        assert (excp == excp_none);
-
-        // load from whereever inside the enclave.
-        havoc load_addr;
-        assume tap_addr_perm_r(cpu_addr_valid[load_addr]);
-        owner := cpu_owner_map[cpu_addr_map[load_addr]];
-        assume owner == eid || owner == tap_null_enc_id;
-        havoc l_way; assume valid_cache_way_index(l_way);
-        call word, excp, hit := load_va(load_addr, l_way);
-        assert (excp == excp_none);
-
-        // store whatever inside the enclave.
-        havoc store_addr, store_data;
-        assume tap_addr_perm_w(cpu_addr_valid[store_addr]);
-        owner := cpu_owner_map[cpu_addr_map[store_addr]];
-        assume owner == eid || owner == tap_null_enc_id;
-        havoc s_way; assume valid_cache_way_index(s_way);
-        call excp, hit := store_va(store_addr, store_data, s_way);
-        assert excp == excp_none;
-        store_data := store_data;
-
-        // stay in the same mode.
-        next_mode := mode;
-    } else if (op == tap_proof_op_exit) {
-        call status := exit();
-        assert status == enclave_op_success;
-        // switch back to the observer. 
-        next_mode := mode_untrusted;
-    } else if (op == tap_proof_op_pause) {
-        call status := exit();
-        assert status == enclave_op_success;
-        // switch back to the observer. 
-        next_mode := mode_untrusted;
+    
+
+    // reserve previous regs
+    regs  := cpu_regs;
+
+    if (tap_enclave_metadata_privileged[cpu_enclave_id]) {
+        if (op == tap_proof_op_compute) {
+            // Updated ver. Apr 17, 2023.
+            // do whatever.
+            havoc cpu_regs;
+            havoc cpu_pc;
+            havoc i_eid;
+            // fetch from whereever inside the enclave.
+            assume tap_enclave_metadata_addr_excl[eid][cpu_pc];
+            assume tap_addr_perm_x(cpu_addr_valid[cpu_pc]);
+            assert cpu_owner_map[cpu_addr_map[cpu_pc]] == eid;
+            havoc way; assume valid_cache_way_index(way);
+            call word, excp, hit := fetch_va(cpu_pc, way);
+            assert (excp == excp_none);
+
+            is_invalid_id :=    ((!tap_enclave_metadata_valid[i_eid]) || 
+                                (tap_enclave_metadata_privileged[cpu_enclave_id]  && i_eid != cpu_enclave_id && tap_enclave_metadata_owner_map[i_eid] != cpu_enclave_id) || 
+                                (!tap_enclave_metadata_privileged[cpu_enclave_id] && i_eid != cpu_enclave_id));
+
+            havoc load_addr;
+            assume tap_addr_perm_r(tap_enclave_metadata_addr_valid[i_eid][load_addr]) && tap_enclave_metadata_addr_excl[i_eid][load_addr];
+            havoc l_way; assume valid_cache_way_index(l_way);
+            if (!is_invalid_id) {
+                // load from whereever inside the enclave / Child Enclave
+                call word, excp, hit := load_va(i_eid, load_addr, l_way);
+                assert (excp == excp_none);
+
+            } 
+            // store whatever inside the enclave.
+            havoc store_addr, store_data;
+            assume tap_addr_perm_w(cpu_addr_valid[store_addr]);
+            owner := cpu_owner_map[cpu_addr_map[store_addr]];
+            assume owner == eid || owner == tap_null_enc_id;
+            havoc s_way; assume valid_cache_way_index(s_way);
+            call excp, hit := store_va(store_addr, store_data, s_way);
+            assert excp == excp_none;
+            store_data := store_data;
+
+            // stay in the same mode.
+            next_mode := mode;
+            status := enclave_op_success;
+
+        } else if (op == tap_proof_op_launch) {
+            assume !tap_enclave_metadata_valid[r_eid];
+            call InitOSMem(r_container_valid, r_container_data);
+            call status := launch(r_eid, r_addr_valid, r_addr_map,
+                                  r_excl_vaddr, r_excl_map, r_entrypoint, r_privileged);
+            next_mode := mode_enclave;
+
+        } else if (op == tap_proof_op_destroy) {
+            call status := destroy(r_eid);
+            next_mode := mode_enclave;
+
+        } else if (op == tap_proof_op_enter) {
+            call status := enter(r_eid);
+            cpu_regs := r_regs;
+            
+            if (status == enclave_op_success) {
+                next_mode := mode_untrusted;
+            } else {
+                cpu_regs  := regs;
+                next_mode := mode_enclave;
+            }
+            
+        } else if (op == tap_proof_op_exit) {
+            call status := exit();
+            assert status == enclave_op_success;
+            next_mode := mode_untrusted;
+
+        } else if (op == tap_proof_op_resume) {
+            call status := resume(r_eid);
+            if (status == enclave_op_success) {
+                next_mode := mode_untrusted;
+            } else {
+                next_mode := mode_enclave;
+            }
+            
+        } else if (op == tap_proof_op_pause) {
+            call status := pause();
+            assert status == enclave_op_success;
+            next_mode := mode_untrusted;
+
+        } 
+    } else {
+        if (op == tap_proof_op_compute) {
+            // Updated ver. Apr 17, 2023.
+            // do whatever.
+            havoc cpu_regs;
+            havoc cpu_pc;
+            havoc i_eid;
+            // fetch from whereever inside the enclave.
+            assume tap_enclave_metadata_addr_excl[eid][cpu_pc];
+            assume tap_addr_perm_x(cpu_addr_valid[cpu_pc]);
+            assert cpu_owner_map[cpu_addr_map[cpu_pc]] == eid;
+            havoc way; assume valid_cache_way_index(way);
+            call word, excp, hit := fetch_va(cpu_pc, way);
+            assert (excp == excp_none);
+
+            is_invalid_id :=    ((!tap_enclave_metadata_valid[i_eid]) || 
+                                (tap_enclave_metadata_privileged[cpu_enclave_id]  && i_eid != cpu_enclave_id && tap_enclave_metadata_owner_map[i_eid] != cpu_enclave_id) || 
+                                (!tap_enclave_metadata_privileged[cpu_enclave_id] && i_eid != cpu_enclave_id));
+            if (is_invalid_id) {
+                i_eid := cpu_enclave_id;
+            } 
+            // load from whereever inside the enclave.
+            havoc load_addr;
+            assume tap_addr_perm_r(tap_enclave_metadata_addr_valid[i_eid][load_addr]) && tap_enclave_metadata_addr_excl[i_eid][load_addr];            
+            havoc l_way; assume valid_cache_way_index(l_way);
+            call word, excp, hit := load_va(i_eid, load_addr, l_way);
+            assert (excp == excp_none);
+            // store whatever inside the enclave.
+            havoc store_addr, store_data;
+            assume tap_addr_perm_w(cpu_addr_valid[store_addr]);
+            owner := cpu_owner_map[cpu_addr_map[store_addr]];
+            assume owner == eid || owner == tap_null_enc_id;
+            havoc s_way; assume valid_cache_way_index(s_way);
+            call excp, hit := store_va(store_addr, store_data, s_way);
+            assert excp == excp_none;
+            store_data := store_data;
+
+            // stay in the same mode.
+            next_mode := mode;
+            status := enclave_op_success;
+
+        } else if (op == tap_proof_op_exit) {
+            call status := exit();
+            assert status == enclave_op_success;
+            // switch back to the observer. 
+            next_mode := mode_untrusted;
+
+        } else if (op == tap_proof_op_pause) {
+            call status := pause();
+            assert status == enclave_op_success;
+            next_mode := mode_untrusted;
+
+        }
     }
+
 }
diff --git a/AbstractPlatform/ImplCommon.bpl b/AbstractPlatform/ImplCommon.bpl
old mode 100644
new mode 100755
index 67f9118..a33ffb0
--- a/AbstractPlatform/ImplCommon.bpl
+++ b/AbstractPlatform/ImplCommon.bpl
@@ -55,13 +55,12 @@ implementation InitialHavoc()
     var repl_way          : cache_way_index_t;
     var done              : bool;
     var hit               : bool;
-
+    
     call initialize_tap();
     current_mode := mode_untrusted;
     // and loop will run for a few iterations.
     done := false;
-
-    while (!done)
+    while (!done && exestep < 1)
         // CPU invariants.
         invariant (done ==> (cpu_enclave_id == tap_null_enc_id));
         // current pc invariants
diff --git a/AbstractPlatform/IntegrityProof.bpl b/AbstractPlatform/IntegrityProof.bpl
old mode 100644
new mode 100755
index 44fb498..a516b7b
--- a/AbstractPlatform/IntegrityProof.bpl
+++ b/AbstractPlatform/IntegrityProof.bpl
@@ -1,4 +1,4 @@
-function uf_load_data(vaddr : vaddr_t, iter : int) : word_t;
+function uf_load_data(i_eid : tap_enclave_id_t, vaddr : vaddr_t, iter : int) : word_t;
 
 // The computation performed by the enclave.
 procedure {:inline 1} EnclaveComputation(iter : int)
@@ -8,14 +8,14 @@ procedure {:inline 1} EnclaveComputation(iter : int)
     modifies cpu_regs;
     modifies cpu_pc;
     modifies cache_valid_map, cache_tag_map, cpu_addr_valid;
-
-    requires (tap_enclave_metadata_valid[cpu_enclave_id]);
+    // modifies tap_enclave_metadata_addr_valid;
+    requires tap_enclave_metadata_valid[cpu_enclave_id];
     requires tap_addr_perm_x(cpu_addr_valid[cpu_pc]);
     requires cpu_owner_map[cpu_addr_map[cpu_pc]] == cpu_enclave_id;
 {
     var r0, r1  : word_t;
     var rd      : regindex_t;
-    var eid     : tap_enclave_id_t;
+    var eid     : tap_enclave_id_t; // current (protected) Enclave's eid
     var pc_pa   : wap_addr_t;
     var pc_op   : word_t;
     var l_vaddr : vaddr_t;
@@ -25,31 +25,53 @@ procedure {:inline 1} EnclaveComputation(iter : int)
     var excp    : exception_t;
     var hit     : bool;
     var way     : cache_way_index_t;
+    var i_eid   : tap_enclave_id_t;
+    var is_invalid_id : bool;
 
     eid := cpu_enclave_id;
     pc_pa := cpu_addr_map[cpu_pc];
     assert tap_enclave_metadata_addr_excl[eid][cpu_pc];
     assert tap_addr_perm_x(cpu_addr_valid[cpu_pc]);
+
     havoc way; assume valid_cache_way_index(way);
     call pc_op, excp, hit := fetch_va(cpu_pc, way);
     assert excp == excp_none;
 
-    // two register sources.
     r0 := cpu_regs[uf_cpu_r0_index(pc_op)];
     r1 := cpu_regs[uf_cpu_r1_index(pc_op)];
 
+    
+    // operation sync.
+    i_eid := uf_load_selector(cpu_pc, pc_op, r0, r1);
+    is_invalid_id :=    ((!tap_enclave_metadata_valid[i_eid]) || 
+                         (tap_enclave_metadata_privileged[cpu_enclave_id]  && i_eid != cpu_enclave_id && tap_enclave_metadata_owner_map[i_eid] != cpu_enclave_id) || 
+                         (!tap_enclave_metadata_privileged[cpu_enclave_id] && i_eid != cpu_enclave_id));
+    if (is_invalid_id) {
+        vaddr := k0_vaddr_t;
+        paddr := k0_wap_addr_t;
+        data  := k0_word_t;
+        return;
+    }
+
     // load address and value.
     l_vaddr := uf_mem_load_vaddr(cpu_pc, pc_op, r0, r1);
-    assume tap_addr_perm_r(cpu_addr_valid[l_vaddr]);
-    if (tap_enclave_metadata_addr_excl[eid][l_vaddr]) {
-        assert cpu_owner_map[cpu_addr_map[l_vaddr]] == eid;
-        havoc way; assume valid_cache_way_index(way);
-        call l_data, excp, hit := load_va(l_vaddr, way);
+    // assume tap_addr_perm_r(cpu_addr_valid[l_vaddr]);
+    assume tap_addr_perm_r(tap_enclave_metadata_addr_valid[i_eid][l_vaddr]);
+    // select proper virtual address.
+    assume tap_enclave_metadata_addr_excl_1[i_eid][l_vaddr] <==> tap_enclave_metadata_addr_excl_2[i_eid][l_vaddr];
+
+    // data from NE children can also be cached (PIPT), data from outside cannot be cached
+    if (tap_enclave_metadata_addr_excl[i_eid][l_vaddr]) {
+        // load from exclusive memory
+        havoc way; 
+        assume valid_cache_way_index(way);
+        call l_data, excp, hit := load_va(i_eid, l_vaddr, way);
         assert excp == excp_none;
     } else {
+        // load from outside (shared) memory
         hit := false;
         excp := excp_none;
-        l_data := uf_load_data(l_vaddr, iter);
+        l_data := uf_load_data(i_eid, l_vaddr, iter);
     }
 
     // get data to store to mem.
@@ -61,7 +83,7 @@ procedure {:inline 1} EnclaveComputation(iter : int)
     // update mem.
     assume tap_addr_perm_w(cpu_addr_valid[s_vaddr]);
     if (tap_enclave_metadata_addr_excl[eid][s_vaddr]) {
-        assert (cpu_owner_map[cpu_addr_map[s_vaddr]] == eid);
+        // assert (cpu_owner_map[cpu_addr_map[s_vaddr]] == eid);
         havoc way; assume valid_cache_way_index(way);
         call excp, hit := store_va(s_vaddr, s_data, way);
         assert excp == excp_none;
@@ -71,7 +93,7 @@ procedure {:inline 1} EnclaveComputation(iter : int)
     cpu_pc := uf_cpu_pc(cpu_pc, pc_op, l_data, r0, r1);
     assume tap_addr_perm_x(cpu_addr_valid[cpu_pc]);
     assume tap_enclave_metadata_addr_excl[eid][cpu_pc];
-    assert cpu_owner_map[cpu_addr_map[cpu_pc]] == eid;
+    // assert cpu_owner_map[cpu_addr_map[cpu_pc]] == eid;
     // update regs.
     rd := uf_cpu_r2_index(pc_op);
     cpu_regs[rd] := uf_cpu_result(cpu_pc, pc_op, l_data, r0, r1);
@@ -95,10 +117,6 @@ procedure {:inline 1} IntegrityAdversarialStep(
     modifies cpu_addr_map;
     modifies cpu_owner_map;
     modifies cache_valid_map, cache_tag_map;
-    modifies untrusted_addr_valid;
-    modifies untrusted_addr_map;
-    modifies untrusted_regs;
-    modifies untrusted_pc;
     modifies tap_enclave_metadata_valid;
     modifies tap_enclave_metadata_addr_map;
     modifies tap_enclave_metadata_addr_valid;
@@ -108,6 +126,8 @@ procedure {:inline 1} IntegrityAdversarialStep(
     modifies tap_enclave_metadata_regs;
     modifies tap_enclave_metadata_paused;
     modifies tap_enclave_metadata_cache_conflict;
+    modifies tap_enclave_metadata_privileged;
+    modifies tap_enclave_metadata_owner_map;
 {
     var status            : enclave_op_result_t;
     var r_addr_valid      : addr_valid_t;
@@ -117,12 +137,14 @@ procedure {:inline 1} IntegrityAdversarialStep(
     var r_container_valid : container_valid_t;
     var r_container_data  : container_data_t;
     var r_entrypoint      : vaddr_t;
+    var r_privileged      : bool;
     var r_vaddr           : vaddr_t;
     var r_valid           : addr_perm_t;
     var r_excp            : exception_t;
     var r_paddr           : wap_addr_t;
     var r_word            : word_t;
     var r_bmap            : excl_map_t;
+    var regs              : regs_t;
     var hit               : bool;
     var way               : cache_way_index_t;
 
@@ -131,37 +153,74 @@ procedure {:inline 1} IntegrityAdversarialStep(
     // the "default" value which may be overwritten by destroy.
     enclave_dead := false;
 
+    // Allow OS to launch PE.
+
+    // init case:   OS (r_eid == null): r_privileged = 1/0
+    //              PE (r_eid != null): r_privileged = 0.
+    current_mode := mode_untrusted;
+    regs := cpu_regs;
+
     if (op == tap_proof_op_launch) {            
         // launch
+        assume !tap_enclave_metadata_valid[r_eid];
         call InitOSMem(r_container_valid, r_container_data);
+        call r_addr_valid, r_addr_map, r_excl_vaddr, r_excl_map, r_entrypoint, r_privileged := LaunchHavoc(r_eid);
         call status := launch(r_eid, r_addr_valid, r_addr_map, 
-                              r_excl_vaddr, r_excl_map, r_entrypoint);
-        assert (r_eid == eid) ==> (status != enclave_op_success);
-    } else if (op == tap_proof_op_enter) {      
-        // enter
-        cpu_regs := r_regs;
+                              r_excl_vaddr, r_excl_map, r_entrypoint, r_privileged);
+        
+    } else if (op == tap_proof_op_enter) {
         call status := enter(r_eid);
+        cpu_regs := r_regs;
         // mode == mode_enclave means we are in trace_2.
         assert (mode == mode_enclave ==> status == enclave_op_success);
-        if (status == enclave_op_success && r_eid == eid) { 
-            current_mode := mode_enclave; 
+        if (status == enclave_op_success) { 
+            if (r_eid == eid) {
+                current_mode := mode_enclave; 
+            } else {
+                current_mode := mode_untrusted;
+            }
+        } else {
+            cpu_regs := regs;
         }
-    } else if (op == tap_proof_op_resume) {     
+    } else if (op == tap_proof_op_resume) {
         // resume
         call status := resume(r_eid);
+        cpu_regs := r_regs;
+
         // mode == mode_enclave means we are in trace_2.
         assert (mode == mode_enclave ==> status == enclave_op_success);
-        if (status == enclave_op_success && r_eid == eid) { 
-            current_mode := mode_enclave; 
+        if (status == enclave_op_success) { 
+            if (r_eid == eid) {
+                current_mode := mode_enclave; 
+            } else {
+                current_mode := mode_untrusted;
+            }
+        } else {
+            cpu_regs := regs;
+        }
+    } else if (op == tap_proof_op_pause) {
+        // exit: 1. back to PE. 2. back to NE/OS
+        // mode == mode_enclave means we are in trace_2 && return to eid (PE)
+        call status := pause();
+        assert (mode == mode_enclave ==> status == enclave_op_success);
+        // for both trace_1 && trace_2
+        if (status == enclave_op_success && cpu_enclave_id == eid) {
+            current_mode := mode_enclave;
         }
+        assert (cpu_enclave_id == tap_null_enc_id) || tap_enclave_metadata_privileged[cpu_enclave_id];
+
     } else if (op == tap_proof_op_exit) {       
-        // exit
+        // exit: 1. back to PE. 2. back to NE/OS
+        // mode == mode_enclave means we are in trace_2 && return to eid (PE)
         call status := exit();
-    } else if (op == tap_proof_op_pause) {      
-        // pause.
-        call status := pause();
-    } else if (op == tap_proof_op_destroy) {    
-        // destroy.
+        assert (mode == mode_enclave ==> status == enclave_op_success);
+        // for both trace_1 && trace_2
+        if (status == enclave_op_success && cpu_enclave_id == eid) {
+            current_mode := mode_enclave;
+        }
+        assert (cpu_enclave_id == tap_null_enc_id) || tap_enclave_metadata_privileged[cpu_enclave_id];
+        
+    } else if (op == tap_proof_op_destroy) {
         call status := destroy(r_eid);
         if (r_eid == eid && status == enclave_op_success) {
             enclave_dead := true;
@@ -171,6 +230,7 @@ procedure {:inline 1} IntegrityAdversarialStep(
     } else if (op == tap_proof_op_block) {
         call status := block_memory_region(r_bmap);
     } else if (op == tap_proof_op_compute) {    
+        // need update.
         // some adversarial computation
         if (*) {
             havoc r_vaddr, r_word;
@@ -178,12 +238,14 @@ procedure {:inline 1} IntegrityAdversarialStep(
             call r_excp, hit := store_va(r_vaddr, r_word, way);
         } else if (*) {
             havoc cpu_regs, cpu_pc;
-        } else if (*) {
+        } 
+        else if (*) {
             // update "page" table map.
-            havoc r_vaddr, r_paddr, r_valid;
+            call r_vaddr, r_paddr, r_valid := AcquireMapping(cpu_enclave_id);
             cpu_addr_valid[r_vaddr] := r_valid;
             cpu_addr_map[r_vaddr] := r_paddr;
-        } else if (*) {
+        } 
+        else if (*) {
             havoc r_vaddr, r_paddr, r_valid;
             call status := set_enclave_addr_map(r_eid, r_vaddr, r_valid, r_paddr);
         }
@@ -191,8 +253,10 @@ procedure {:inline 1} IntegrityAdversarialStep(
 }
 
 procedure {:inline 1} IntegrityEnclaveStep(
-    /* what operation?  */  op : tap_proof_op_t, 
-    /* which iteration? */  iter : int
+    /* mode             */  mode  : mode_t,
+    /* primitive target */  r_eid : tap_enclave_id_t,
+    /* what operation?  */  op    : tap_proof_op_t, 
+    /* which iteration? */  iter  : int
 )
     returns (next_mode : mode_t, vaddr : vaddr_t, paddr : wap_addr_t, data : word_t)
 
@@ -204,39 +268,117 @@ procedure {:inline 1} IntegrityEnclaveStep(
     modifies cpu_addr_map;
     modifies cpu_owner_map;
     modifies cache_valid_map, cache_tag_map;
-    modifies untrusted_addr_valid;
-    modifies untrusted_addr_map;
-    modifies untrusted_regs;
-    modifies untrusted_pc;
     modifies tap_enclave_metadata_valid;
     modifies tap_enclave_metadata_addr_map;
     modifies tap_enclave_metadata_addr_valid;
+    modifies tap_enclave_metadata_addr_excl;
     modifies tap_enclave_metadata_entrypoint;
     modifies tap_enclave_metadata_pc;
     modifies tap_enclave_metadata_regs;
     modifies tap_enclave_metadata_paused;
     modifies tap_enclave_metadata_cache_conflict;
+    modifies tap_enclave_metadata_privileged;
+    modifies tap_enclave_metadata_owner_map;
 {
-    var status : enclave_op_result_t;
-    assert tap_proof_op_valid_in_enclave(op);
+    var status            : enclave_op_result_t;
+    var eid               : tap_enclave_id_t;   
+    var regs              : regs_t;
+    var p_regs            : regs_t;
+    var p_container_valid : container_valid_t;
+    var p_container_data  : container_data_t;
+    var p_vaddr           : vaddr_t;
+    var p_valid           : addr_perm_t;
+    var p_excp            : exception_t;
+    var p_paddr           : wap_addr_t;
+    var p_word            : word_t;
+    var hit               : bool;
+    var way               : cache_way_index_t;
+    /* enclave launch structure */
+    var r_addr_valid      : addr_valid_t;
+    var r_addr_map        : addr_map_t;
+    var r_excl_vaddr      : excl_vaddr_t;
+    var r_excl_map        : excl_map_t;
+    var r_entrypoint      : vaddr_t;
+    var r_privileged      : bool;
 
+    eid   := cpu_enclave_id;
     vaddr := k0_vaddr_t;
     paddr := k0_wap_addr_t;
-    data := k0_word_t;
+    data  := k0_word_t;
+    // reserve previous regs
+    regs  := cpu_regs;
 
-    // in enclave-mode:
-    if (op == tap_proof_op_compute) {
-        call vaddr, paddr, data := EnclaveComputation(iter);
-        next_mode := mode_enclave;
-    } else if (op == tap_proof_op_pause) {
-        call status := pause();
-        assert status == enclave_op_success;
-        next_mode := mode_untrusted;
-    } else if (op == tap_proof_op_exit) {
-        call status := exit();
-        assert status == enclave_op_success;
-        next_mode := mode_untrusted;
+    if (tap_enclave_metadata_privileged[eid]) {
+        if (op == tap_proof_op_exit) {
+            call status := exit();
+            assert status == enclave_op_success;
+            next_mode := mode_untrusted;
+
+        } else if (op == tap_proof_op_pause) {
+            call status := pause();
+            assert status == enclave_op_success;
+            next_mode := mode_untrusted;
+
+        } else if (op == tap_proof_op_compute) {
+            call vaddr, paddr, data := EnclaveComputation(iter);
+            next_mode := mode_enclave;      
+
+        } else if (op == tap_proof_op_launch) {
+            assume !tap_enclave_metadata_valid[r_eid];
+            call InitOSMem(p_container_valid, p_container_data);
+            // Apr 6, 2023. add a buildup stage for launch.
+            call r_addr_valid, r_addr_map, r_excl_vaddr, r_excl_map, r_entrypoint, r_privileged := LaunchHavoc(r_eid);
+            assume !r_privileged;
+            call status := launch(r_eid, r_addr_valid, r_addr_map,
+                                r_excl_vaddr, r_excl_map, r_entrypoint, r_privileged);
+            next_mode := mode_enclave;
+
+        } else if (op == tap_proof_op_enter) {
+            call status := enter(r_eid);
+            cpu_regs := p_regs;
+            
+            if (status == enclave_op_success) {
+                next_mode := mode_untrusted;
+            } else {
+                cpu_regs  := regs;
+                next_mode := mode_enclave;
+            }
+            // mode == mode_untrusted means we are in trace_2, sync operation.
+            // sync: all eid's children must be same stage.
+            assert mode == mode_untrusted ==> status == enclave_op_success;
+            
+        } else if (op == tap_proof_op_destroy) {
+            call status := destroy(r_eid);
+            next_mode := mode_enclave;
+
+        }  else if (op == tap_proof_op_resume) {
+            call status := resume(r_eid);
+            if (status == enclave_op_success) {
+                next_mode := mode_untrusted;
+            } else {
+                next_mode := mode_enclave;
+            }
+            assert mode == mode_untrusted ==> status == enclave_op_success;
+        }
+
+    } else {
+        if (op == tap_proof_op_pause) {
+            call status := pause();
+            assert status == enclave_op_success;
+            next_mode := mode_untrusted;
+
+        } else if (op == tap_proof_op_compute) {
+            call vaddr, paddr, data := EnclaveComputation(iter);
+            next_mode := mode_enclave;      
+
+        } else if (op == tap_proof_op_exit) {
+            call status := exit();
+            assert status == enclave_op_success;
+            next_mode := mode_untrusted;
+
+        }
     }
+
 }
 
 procedure ProveIntegrity()
@@ -250,10 +392,6 @@ procedure ProveIntegrity()
     modifies cache_valid_map, cache_tag_map;
     modifies cache_valid_map_1, cache_tag_map_1;
     modifies cache_valid_map_2, cache_tag_map_2;
-    modifies untrusted_addr_valid;
-    modifies untrusted_addr_map;
-    modifies untrusted_regs;
-    modifies untrusted_pc;
     modifies tap_enclave_metadata_valid;
     modifies tap_enclave_metadata_addr_map;
     modifies tap_enclave_metadata_addr_valid;
@@ -263,6 +401,8 @@ procedure ProveIntegrity()
     modifies tap_enclave_metadata_regs;
     modifies tap_enclave_metadata_paused;
     modifies tap_enclave_metadata_cache_conflict;
+    modifies tap_enclave_metadata_privileged;
+    modifies tap_enclave_metadata_owner_map;
     modifies cpu_mem_1;
     modifies cpu_regs_1;
     modifies cpu_pc_1;
@@ -270,10 +410,6 @@ procedure ProveIntegrity()
     modifies cpu_addr_valid_1;
     modifies cpu_addr_map_1;
     modifies cpu_owner_map_1;
-    modifies untrusted_addr_valid_1;
-    modifies untrusted_addr_map_1;
-    modifies untrusted_regs_1;
-    modifies untrusted_pc_1;
     modifies tap_enclave_metadata_valid_1;
     modifies tap_enclave_metadata_addr_map_1;
     modifies tap_enclave_metadata_addr_valid_1;
@@ -283,6 +419,8 @@ procedure ProveIntegrity()
     modifies tap_enclave_metadata_regs_1;
     modifies tap_enclave_metadata_paused_1;
     modifies tap_enclave_metadata_cache_conflict_1;
+    modifies tap_enclave_metadata_privileged_1;
+    modifies tap_enclave_metadata_owner_map_1;
     modifies cpu_mem_2;
     modifies cpu_regs_2;
     modifies cpu_pc_2;
@@ -290,10 +428,6 @@ procedure ProveIntegrity()
     modifies cpu_addr_valid_2;
     modifies cpu_addr_map_2;
     modifies cpu_owner_map_2;
-    modifies untrusted_addr_valid_2;
-    modifies untrusted_addr_map_2;
-    modifies untrusted_regs_2;
-    modifies untrusted_pc_2;
     modifies tap_enclave_metadata_valid_2;
     modifies tap_enclave_metadata_addr_map_2;
     modifies tap_enclave_metadata_addr_valid_2;
@@ -303,8 +437,10 @@ procedure ProveIntegrity()
     modifies tap_enclave_metadata_regs_2;
     modifies tap_enclave_metadata_paused_2;
     modifies tap_enclave_metadata_cache_conflict_2;
+    modifies tap_enclave_metadata_privileged_2;
+    modifies tap_enclave_metadata_owner_map_2;
 {
-    var eid, r_eid                                    : tap_enclave_id_t;
+    var eid, i_eid, r_eid                             : tap_enclave_id_t;
     var status                                        : enclave_op_result_t;
     var e_addr_valid                                  : addr_valid_t;
     var e_addr_map                                    : addr_map_t;
@@ -312,6 +448,7 @@ procedure ProveIntegrity()
     var e_excl_map                                    : excl_map_t;
     var e_container_data                              : container_data_t;
     var e_entrypoint                                  : vaddr_t;
+    var e_privileged                                  : bool;  
     var e_proof_op, r_proof_op                        : tap_proof_op_t;
     var r_regs                                        : regs_t;
     var current_mode_1, current_mode_2, current_mode  : mode_t;
@@ -322,20 +459,23 @@ procedure ProveIntegrity()
     var paddr_1, paddr_2                              : wap_addr_t;
     var data_1, data_2                                : word_t;
     var iter                                          : int;
+    
+    // debug variables
+    var pc_op_1, pc_op_2    : word_t;
 
     // launch the same enclave in both traces.
     call RestoreContext_1();
-    call current_mode_1 := InitialHavoc();
+    call current_mode_1 := InitialHavoc(eid);
     call InitOSMem(e_excl_map, e_container_data);
-    call status := launch(eid, e_addr_valid, e_addr_map, e_excl_vaddr, e_excl_map, e_entrypoint);
+    call status := launch(eid, e_addr_valid, e_addr_map, e_excl_vaddr, e_excl_map, e_entrypoint, e_privileged);
     assume status == enclave_op_success;
     call SaveContext_1();
 
     // trace_2.
     call RestoreContext_2();
-    call current_mode_2 := InitialHavoc();
+    call current_mode_2 := InitialHavoc(eid);
     call InitOSMem(e_excl_map, e_container_data);
-    call status := launch(eid, e_addr_valid, e_addr_map, e_excl_vaddr, e_excl_map, e_entrypoint);
+    call status := launch(eid, e_addr_valid, e_addr_map, e_excl_vaddr, e_excl_map, e_entrypoint, e_privileged);
     assume status == enclave_op_success;
     call SaveContext_2();
 
@@ -346,10 +486,75 @@ procedure ProveIntegrity()
 
     // main loop.
     enclave_dead := false;
+
     while (!enclave_dead)
         //----------------------------------------------------------------------//
         // global TAP invariants.                                               //
         //----------------------------------------------------------------------//
+        
+        // privilege relationship: OS & eid
+        invariant !tap_enclave_metadata_privileged_1[tap_null_enc_id];
+        invariant !tap_enclave_metadata_privileged_2[tap_null_enc_id];
+        invariant tap_enclave_metadata_privileged_1[eid] == tap_enclave_metadata_privileged_2[eid];
+        invariant tap_enclave_metadata_privileged_1[eid] == e_privileged;
+        invariant tap_enclave_metadata_privileged_2[eid] == e_privileged;
+
+        //  Apr 8, 2023
+        //  privileged relationship: unique PE
+        //  Apr 19, 2023
+        //  privileged relationship: multiple PE
+        invariant (forall e : tap_enclave_id_t :: 
+                (tap_enclave_metadata_valid_1[e] && tap_enclave_metadata_privileged_1[e]) ==> 
+                        (tap_enclave_metadata_owner_map_1[e] == tap_null_enc_id));
+        invariant (forall e : tap_enclave_id_t :: 
+                (tap_enclave_metadata_valid_2[e] && tap_enclave_metadata_privileged_2[e]) ==> 
+                        (tap_enclave_metadata_owner_map_2[e] == tap_null_enc_id));
+
+        // valid guarantee
+        invariant tap_enclave_metadata_valid_1[tap_null_enc_id];
+        invariant tap_enclave_metadata_valid_2[tap_null_enc_id];
+        invariant (forall e : tap_enclave_id_t :: 
+                        special_enclave_id(e) ==> !tap_enclave_metadata_valid_1[e]);
+        invariant (forall e: tap_enclave_id_t :: 
+                        special_enclave_id(e) ==> !tap_enclave_metadata_valid_2[e]);
+
+        // enclave ownermap relationship: valid enclave's parent must be valid
+        invariant (forall e : tap_enclave_id_t :: tap_enclave_metadata_valid_1[e] ==>
+                    (tap_enclave_metadata_valid_1[tap_enclave_metadata_owner_map_1[e]]));
+        invariant (forall e : tap_enclave_id_t :: tap_enclave_metadata_valid_2[e] ==> 
+                    (tap_enclave_metadata_valid_2[tap_enclave_metadata_owner_map_2[e]]));
+
+        // enclave ownermap relationship: special children
+        invariant tap_enclave_metadata_owner_map_1[eid] == tap_null_enc_id;
+        invariant tap_enclave_metadata_owner_map_2[eid] == tap_null_enc_id;
+        invariant tap_enclave_metadata_owner_map_1[tap_null_enc_id] == tap_null_enc_id;
+        invariant tap_enclave_metadata_owner_map_2[tap_null_enc_id] == tap_null_enc_id;
+
+        // enclave ownermap relationship: the maximal parent-tree depth is 2 
+        invariant (forall e : tap_enclave_id_t :: (tap_enclave_metadata_valid_1[e]) ==> 
+                    (tap_enclave_metadata_owner_map_1[tap_enclave_metadata_owner_map_1[e]] == tap_null_enc_id));
+        invariant (forall e : tap_enclave_id_t :: (tap_enclave_metadata_valid_2[e]) ==> 
+                    (tap_enclave_metadata_owner_map_2[tap_enclave_metadata_owner_map_2[e]] == tap_null_enc_id));
+
+        // enclave ownermap relationship: Apr 4, 2023.
+        //   if the mode_untrusted is from PE's children enclave, then the 2 traces is in **one** children enclave of this PE.
+
+        // invariant ((tap_enclave_metadata_owner_map_1[cpu_enclave_id_1] == eid) ==>
+        //             (cpu_enclave_id_1 == cpu_enclave_id_2));
+        invariant ((tap_enclave_metadata_owner_map_1[cpu_enclave_id_1] == eid) ==>
+                    (tap_enclave_metadata_valid_2[cpu_enclave_id_2]));
+        invariant ((tap_enclave_metadata_owner_map_1[cpu_enclave_id_1] == eid) ==>
+                    (tap_enclave_metadata_owner_map_2[cpu_enclave_id_2] == eid));
+
+        // enclave ownermap relationship: enclave with chidren must be privileged 
+        invariant (forall e : tap_enclave_id_t :: 
+                    (tap_enclave_metadata_valid_1[e] && tap_enclave_metadata_owner_map_1[e] != tap_null_enc_id) ==> 
+                        (tap_enclave_metadata_privileged_1[tap_enclave_metadata_owner_map_1[e]]));
+        invariant (forall e : tap_enclave_id_t :: 
+                    (tap_enclave_metadata_valid_2[e] && tap_enclave_metadata_owner_map_2[e] != tap_null_enc_id) ==> 
+                        (tap_enclave_metadata_privileged_2[tap_enclave_metadata_owner_map_2[e]]));
+
+        // pa ownermap wouldn't point to invalid enclave.
         invariant  (forall pa : wap_addr_t, e : tap_enclave_id_t ::
                     (valid_enclave_id(e) && !tap_enclave_metadata_valid_1[e]) ==> 
                         (cpu_owner_map_1[pa] != e));
@@ -390,6 +595,23 @@ procedure ProveIntegrity()
                      (tap_enclave_metadata_addr_excl_1[eid] == e_excl_vaddr);
         invariant (!enclave_dead) ==>
                      (tap_enclave_metadata_addr_excl_2[eid] == e_excl_vaddr);
+        
+        // This consistency should be supposed by platform.
+        // extend the exclusive-memory consistency to PE and NE children.
+        // 1.   constrain this consistency to PE-controlled enclave.
+        invariant (forall e : tap_enclave_id_t, v : vaddr_t :: 
+                    (tap_enclave_metadata_valid_1[e] && (tap_enclave_metadata_privileged_1[e] || tap_enclave_metadata_privileged_1[tap_enclave_metadata_owner_map_1[e]]) ==> 
+                        (tap_enclave_metadata_addr_excl_1[e][v] <==> cpu_owner_map_1[tap_enclave_metadata_addr_map_1[e][v]] == e)));
+        invariant (forall e : tap_enclave_id_t, v : vaddr_t :: 
+                    (tap_enclave_metadata_valid_2[e] && (tap_enclave_metadata_privileged_2[e] || tap_enclave_metadata_privileged_2[tap_enclave_metadata_owner_map_2[e]]) ==> 
+                        (tap_enclave_metadata_addr_excl_2[e][v] <==> cpu_owner_map_2[tap_enclave_metadata_addr_map_2[e][v]] == e)));
+        // 2.   constraint this consistency to PE.
+        invariant (forall v : vaddr_t :: 
+                    (!enclave_dead && (tap_enclave_metadata_privileged_1[cpu_enclave_id_1] || tap_enclave_metadata_privileged_1[tap_enclave_metadata_owner_map_1[cpu_enclave_id_1]])) ==> 
+                        (tap_enclave_metadata_addr_excl_1[cpu_enclave_id_1][v] <==> cpu_owner_map_1[cpu_addr_map_1[v]] == cpu_enclave_id_1));
+        invariant (forall v : vaddr_t :: 
+                    (!enclave_dead && (tap_enclave_metadata_privileged_2[cpu_enclave_id_2] || tap_enclave_metadata_privileged_2[tap_enclave_metadata_owner_map_2[cpu_enclave_id_2]])) ==> 
+                        (tap_enclave_metadata_addr_excl_2[cpu_enclave_id_2][v] <==> cpu_owner_map_2[cpu_addr_map_2[v]] == cpu_enclave_id_2));
         // permission bits are the same.
         invariant (forall v : vaddr_t :: (!enclave_dead && e_excl_vaddr[v]) ==>
                      (tap_enclave_metadata_addr_valid_1[eid][v] == tap_enclave_metadata_addr_valid_2[eid][v]));
@@ -417,11 +639,42 @@ procedure ProveIntegrity()
                     (tap_enclave_metadata_paused_1[eid] == tap_enclave_metadata_paused_2[eid]);
         // the two registers are the same.
         invariant (forall ri : regindex_t :: !enclave_dead ==>
-                      (tap_enclave_metadata_regs_1[eid][ri] == tap_enclave_metadata_regs_2[eid][ri]));
+                    (tap_enclave_metadata_regs_1[eid][ri] == tap_enclave_metadata_regs_2[eid][ri]));
+        
         // invariants about the states of the CPUs.
-        // are we in attacker mode?
+        // are we in attacker mode? or we enter PE's children enclave.
         invariant (current_mode == mode_untrusted) ==> (cpu_enclave_id_1 != eid);
-        invariant (current_mode == mode_untrusted) ==> (cpu_enclave_id_2 == tap_null_enc_id);
+        invariant (current_mode == mode_untrusted) ==> (cpu_enclave_id_2 == tap_null_enc_id || tap_enclave_metadata_owner_map_2[cpu_enclave_id_2] == eid);
+
+        // invariants about state sync between 2 traces.
+        // t_1: OS / OS-CE / other PE / other PE's CE ==> t_2: OS.
+        // t_1: eid's CE ==> t_2: eid's same CE.
+        invariant (current_mode == mode_untrusted) ==> 
+            ((tap_enclave_metadata_owner_map_1[cpu_enclave_id_1] != eid) ==> 
+                        cpu_enclave_id_2 == tap_null_enc_id);
+        invariant (current_mode == mode_untrusted) ==> 
+            ((tap_enclave_metadata_owner_map_1[cpu_enclave_id_1] == eid) ==> 
+                        tap_enclave_metadata_owner_map_2[cpu_enclave_id_2] == eid);
+        invariant (current_mode == mode_untrusted) ==> 
+            ((tap_enclave_metadata_owner_map_1[cpu_enclave_id_1] == eid) ==> 
+                        cpu_enclave_id_1 == cpu_enclave_id_2);
+
+        // PE sync. the PE's structure must be same.
+        invariant (forall e : tap_enclave_id_t :: 
+            (tap_enclave_metadata_valid_1[e] && tap_enclave_metadata_owner_map_1[e] == eid) <==> 
+                (tap_enclave_metadata_valid_2[e] && tap_enclave_metadata_owner_map_2[e] == eid));
+
+        // PE sync. the two (PE) enclave's children pause state must be same. 
+        // Apr 4, 2023.
+        invariant !enclave_dead ==>
+                    (forall e : tap_enclave_id_t :: 
+                        (tap_enclave_metadata_valid_1[e] && tap_enclave_metadata_owner_map_1[e] == eid) ==> 
+                            tap_enclave_metadata_paused_1[e] == tap_enclave_metadata_paused_2[e]);
+        
+
+        invariant (current_mode == mode_untrusted) ==> (tap_enclave_metadata_valid_1[cpu_enclave_id_1]);
+        invariant (current_mode == mode_untrusted) ==> (tap_enclave_metadata_valid_2[cpu_enclave_id_2]);
+
         // if we are in trusted mode, we mean our enclave. 
         invariant (current_mode == mode_enclave ==> 
                     (cpu_enclave_id_1 == eid  && cpu_enclave_id_2 == eid));
@@ -456,10 +709,9 @@ procedure ProveIntegrity()
                     (current_mode == mode_enclave && e_excl_vaddr[va]) ==>
                         (e_addr_map[va] == cpu_addr_map_2[va]));
     {
-        havoc r_eid, r_proof_op, e_proof_op, r_regs;
-        if (current_mode == mode_untrusted) {
+        havoc i_eid, r_eid, r_proof_op, e_proof_op, r_regs;
+        if (current_mode == mode_untrusted) {   
             assume tap_proof_op_valid(r_proof_op);
-
             // execute the operation in trace_1
             call RestoreContext_1();
             call current_mode, enclave_dead := IntegrityAdversarialStep(
@@ -467,8 +719,11 @@ procedure ProveIntegrity()
             call SaveContext_1();
 
             // if the mode changed, we need to do this in trace_2
+            // trace1: eid, other enclave
+            // trace2: eid / standing
             call RestoreContext_2();
             if (current_mode == mode_enclave) {
+                // case 1. sync enter/exit/pause into PE
                 call current_mode, enclave_dead := IntegrityAdversarialStep(
                         current_mode, eid, r_eid, r_regs, r_proof_op);
                 // sanity check.
@@ -476,20 +731,27 @@ procedure ProveIntegrity()
                 assert !enclave_dead;
             }
             call SaveContext_2();
+
         } else if (current_mode == mode_enclave) {
             havoc iter;
-            assume tap_proof_op_valid_in_enclave(e_proof_op);
-
+            if (e_privileged) {
+                assume tap_proof_op_valid_in_privileged(e_proof_op);
+                
+            } else {
+                assume tap_proof_op_valid_in_enclave(e_proof_op);
+                
+            }
+            
             // enclave step in trace_1
             call RestoreContext_1();
             call current_mode, vaddr_1, paddr_1, data_1 := IntegrityEnclaveStep(
-                                                            e_proof_op, iter);
+                                                            current_mode, r_eid, e_proof_op, iter);
             call SaveContext_1();
 
             // enclave step in trace_2
             call RestoreContext_2();
             call current_mode, vaddr_2, paddr_2, data_2 := IntegrityEnclaveStep(
-                                                            e_proof_op, iter);
+                                                            current_mode, r_eid, e_proof_op, iter);
             call SaveContext_2();
 
             assert vaddr_1 == vaddr_2;
diff --git a/AbstractPlatform/Makefile b/AbstractPlatform/Makefile
old mode 100644
new mode 100755
index a46310c..d787f13
--- a/AbstractPlatform/Makefile
+++ b/AbstractPlatform/Makefile
@@ -4,9 +4,23 @@ ifeq ($(SMOKE),1)
 else
 	BOOGIESMOKE:=
 endif
-
-BOOGIEOPT:=/z3opt:smt.RELEVANCY=0 /z3opt:smt.CASE_SPLIT=0 /errorLimit:1 $(BOOGIESMOKE)
-
+BOOGIE := boogie
+BOOGIEOPT:= 		/proverOpt:O:smt.relevancy=2 /proverOpt:O:smt.case_split=2 /errorLimit:1 $(BOOGIESMOKE) \
+					/proverOpt:O:parallel.enable=true \
+					/traceverify \
+					/trace	\
+					/printModel:1 \
+					/printModelToFile:log/model.log \
+					/errorTrace:2 \
+					/enhancedErrorMessages:0 \
+					/proverLog:log/prover.log \
+					/printCFG:dotfiles/ctrlflow \
+					/proc:measurement_proof_part2 \
+					/proverWarnings:1 \
+					#  /timeLimit:900 \
+					#  /break \
+# /traceverify
+# /errorTrace
 COMMON=../Common
 BUILD=build
 CPU_TARGET:=$(BUILD)/CPU.xml
@@ -35,6 +49,17 @@ MEASUREMENT_PROOF_FILES:=MeasurementProof.bpl
 TEMP_PROOF_FILES:=temp.bpl
 
 all: $(CPU_TARGET) $(MEASUREMENT_TARGET) $(COMMON_PROOF_TARGET) $(INTEGRITY_PROOF_TARGET) $(MEM_CONFIDENTIALITY_PROOF_TARGET) $(CACHE_CONFIDENTIALITY_PROOF_TARGET) $(PT_CONFIDENTIALITY_PROOF_TARGET) $(MEASUREMENT_PROOF_TARGET)
+cpu: $(CPU_TARGET)
+intipf: $(INTEGRITY_PROOF_TARGET)
+# M
+memconf: $(MEM_CONFIDENTIALITY_PROOF_TARGET)
+# C
+cacheconf : $(CACHE_CONFIDENTIALITY_PROOF_TARGET)
+# P
+ptconf : $(PT_CONFIDENTIALITY_PROOF_TARGET)
+measurepf: $(MEASUREMENT_PROOF_TARGET)
+cmnpf : $(COMMON_PROOF_TARGET)
+
 $(CPU_TARGET): $(ATP_COMMON_FILES) $(CPU_FILES) $(CPU_IMPL_FILES)
 	$(BOOGIE) $(BOOGIEOPT) /xml:$@ $^
 
@@ -50,19 +75,32 @@ $(CACHE_CONFIDENTIALITY_PROOF_TARGET): $(ATP_COMMON_FILES) $(CPU_FILES) $(CONFID
 $(PT_CONFIDENTIALITY_PROOF_TARGET): $(ATP_COMMON_FILES) $(CPU_FILES) $(CONFIDENTIALITY_COMMON_FILES) $(PT_CONFIDENTIALITY_PROOF_FILES)
 	$(BOOGIE) $(BOOGIEOPT) /xml:$@ $^
 
-$(COMMON_PROOF_TARGET): $(COMMON_PROOF_FILES) $(CPU_FILES) $(ATP_COMMON_FILES) $(COMMON_IMPL_FILES)
+$(COMMON_PROOF_TARGET): $(ATP_COMMON_FILES) $(CPU_FILES) $(COMMON_PROOF_FILES)  $(COMMON_IMPL_FILES)
 	$(BOOGIE) $(BOOGIEOPT) /xml:$@ $^
 
-$(MEASUREMENT_TARGET): $(MEASUREMENT_FILES) $(COMMON_PROOF_FILES) $(CPU_FILES) $(ATP_COMMON_FILES)
+$(MEASUREMENT_TARGET): $(ATP_COMMON_FILES) $(CPU_FILES) $(MEASUREMENT_FILES) $(COMMON_PROOF_FILES) 
 	$(BOOGIE) $(BOOGIEOPT) /xml:$@ $^
 
-$(MEASUREMENT_PROOF_TARGET): $(MEASUREMENT_PROOF_FILES) $(MEASUREMENT_FILES) $(COMMON_PROOF_FILES) $(CPU_FILES) $(ATP_COMMON_FILES)
+$(MEASUREMENT_PROOF_TARGET): $(ATP_COMMON_FILES) $(CPU_FILES) $(MEASUREMENT_PROOF_FILES) $(MEASUREMENT_FILES) $(COMMON_PROOF_FILES) 
 	$(BOOGIE) $(BOOGIEOPT) /xml:$@ $^
 
-$(TEMP_PROOF_TARGET): $(TEMP_PROOF_FILES) $(COMMON_PROOF_FILES) $(CPU_FILES) $(ATP_COMMON_FILES)
+$(TEMP_PROOF_TARGET):  $(TEMP_PROOF_FILES) $(COMMON_PROOF_FILES) $(CPU_FILES) $(ATP_COMMON_FILES)
 	$(BOOGIE) $(BOOGIEOPT) /xml:$@ $^
 
+
+
+
 clean:
 	rm -f build/*.xml
 
-.PHONY: clean
+cut:
+	sed -n '/peep-hole/,$$p' log/run.log > log/peephole.log
+	sed -n -e'/catch/,$$p' log/run.log > log/catch.log	
+	sed '/passive/,$$d' log/catch.log > log/onlyCatch.log
+	sed -n -e'/z3/,$$p' log/peephole.log > log/result.log	
+	sed -i 's/#AT#/@/g' log/run.log 
+	sed -i 's/#AT#/@/g' log/peephole.log
+	rm log/catch.log
+
+
+.PHONY: clean, cut
diff --git a/AbstractPlatform/Measure.bpl b/AbstractPlatform/Measure.bpl
old mode 100644
new mode 100755
index eefb5f9..ebcaab1
--- a/AbstractPlatform/Measure.bpl
+++ b/AbstractPlatform/Measure.bpl
@@ -2,12 +2,29 @@ function addrperm2int(p : addr_perm_t) : int;
 axiom (forall v1, v2 : addr_perm_t :: (v1 != v2) ==> (addrperm2int(v1) != addrperm2int(v2)));
 axiom (forall w : addr_perm_t :: addrperm2int(w) >= 0 && addrperm2int(w) <= kmax_addr_perm_t_as_int);
 
+// add privileged into measurement
+function privileged2int (p : bool) : int;
+axiom (forall v1, v2 : bool :: (v1 != v2) ==> (privileged2int(v1) != privileged2int(v2)));
+axiom (forall w : bool :: privileged2int(w) >= 0 && privileged2int(w) <= kmax_privileged_t_as_int);
+
 function valid_regindex_le(ri : regindex_t, rmax : regindex_t) : bool 
 { LE_ri(k0_regindex_t, ri) && LE_ri(ri, rmax) }
 
 //--------------------------------------------------------------------------//
 // Helper fns in order to state measurement invariants.                     //
 //--------------------------------------------------------------------------//
+// valid PE structure: be same
+// notice case that eid == root1/2
+function {:inline} encl_owner_map_match(valid1 : tap_enclave_metadata_valid_t,
+                                        valid2 : tap_enclave_metadata_valid_t,
+                                        map1 : tap_enclave_metadata_owner_map_t, 
+                                        map2 : tap_enclave_metadata_owner_map_t, 
+                                        eid : tap_enclave_id_t,
+                                        root1 : tap_enclave_id_t, 
+                                        root2 : tap_enclave_id_t) : bool
+{ (valid1[eid] && map1[eid] == root1) <==> (valid2[eid] && map2[eid] == root2) }
+
+
 function {:inline} excl_match(ev1 : excl_vaddr_t, ev2 : excl_vaddr_t, v : vaddr_t) : bool
 { ev1[v] == ev2[v] }
 
@@ -69,14 +86,35 @@ function {:inline} update_digest_virt_addr(
   //       else update_digest(1, s))
   //  else update_digest(k0_measurement_t, s)
 
+// int(2)
+const kbias_cpu_measurement_index : int;
+axiom kbias_cpu_measurement_index == 2;
+
+const kbias_privil_measurement_index : int;
+axiom kbias_privil_measurement_index == 1;
+
+// int(2 + 512)
+const kmax_cpu_regs_bound_index : int;
+axiom kmax_cpu_regs_bound_index == kbias_cpu_measurement_index + kN_regindex_t_as_int;
+
+// int(2 + 512 + 1)
+const kmax_cpu_privil_bound_index : int;
+axiom kmax_cpu_privil_bound_index == kbias_privil_measurement_index + kmax_cpu_regs_bound_index;
+
+// int(2 + 512 + 1 + 512)
 const kmax_cpu_measurement_index : int;
-axiom kmax_cpu_measurement_index == 2 + kN_regindex_t_as_int;
+axiom kmax_cpu_measurement_index == kmax_cpu_privil_bound_index + kN_enclave_id_t;
 
+/* append metadata: privileged */ 
 procedure {:inline 1} measure_cpu_state_at_index(
+   /* eid        */ eid        : tap_enclave_id_t ,
    /* regs       */ regs       : regs_t           , 
    /* pc         */ pc         : vaddr_t          , 
    /* entrypoint */ entrypoint : vaddr_t          ,
    /* index      */ index      : int              ,
+   /* privileged */ privileged : bool             ,
+   /* owner_map  */ ownermap   : tap_enclave_metadata_owner_map_t,
+   /* encl valid */ valid      : tap_enclave_metadata_valid_t,
    /* meas in    */ s          : measurement_t
 )
   returns (t : measurement_t)
@@ -85,15 +123,31 @@ procedure {:inline 1} measure_cpu_state_at_index(
 {
   var ri : regindex_t;
   var vi : int;
+  var iter_eid : tap_enclave_id_t;
 
   if (index == 0) {
     t := update_digest(vaddr2int(pc), s);
-  } else if (index == 1) {
+  }
+  else if (index == 1) {
     t := update_digest(vaddr2int(entrypoint), s);
-  } else if (index >= 2 && index < (2 + kN_regindex_t_as_int)) {
-    ri := index - 2;
+  } 
+  else if (index >= kbias_cpu_measurement_index && index < kmax_cpu_regs_bound_index) {
+    ri := index - kbias_cpu_measurement_index;
     assert valid_regindex(ri);
     t := update_digest(word2int(regs[ri]), s);
+  } 
+  else if (index >= kmax_cpu_regs_bound_index && index < kmax_cpu_privil_bound_index) {
+    t := update_digest(bool2int(privileged), s); 
+  }
+  else if (index >= kmax_cpu_privil_bound_index && index < kmax_cpu_measurement_index) {
+    iter_eid := index - kmax_cpu_privil_bound_index;
+    assert valid_enclave_id_index(eid);
+    if (valid[iter_eid] && ownermap[iter_eid] == eid) {
+      // iter_eid cannot be tap_null_enc_id, avoid default value
+      t := update_digest(iter_eid, s);
+    } else {
+      t := update_digest(k0_int_t, s);
+    }
   }
 }
 
@@ -110,75 +164,132 @@ procedure measure_state_self_composed(
      /* mem        */ m1          , m2          : mem_t            , 
      /* regs       */ regs1       , regs2       : regs_t           , 
      /* pc         */ pc1         , pc2         : vaddr_t          , 
-     /* entrypoint */ entrypoint1 , entrypoint2 : vaddr_t
+     /* entrypoint */ entrypoint1 , entrypoint2 : vaddr_t          ,
+     /* privileged */ privileged1 , privileged2 : bool             ,
+     /* ownermap   */ ownermap1   , ownermap2   : tap_enclave_metadata_owner_map_t,
+     /* encl valid */ valid1      , valid2      : tap_enclave_metadata_valid_t
 )
   returns (t1 : measurement_t, t2 : measurement_t)
+  // some additional requirement on ownermap structure.
+  // These 2 judge conditions could be merged.
+  requires (valid_enclave_id_index(e1) && valid_enclave_id_index(e2));
+  requires (valid_enclave_id(e1) && valid_enclave_id(e2));
+  requires (ownermap1[tap_null_enc_id] == tap_null_enc_id);
+  requires (ownermap2[tap_null_enc_id] == tap_null_enc_id);
+
   ensures ((forall v : vaddr_t :: 
               (excl_match(ev1, ev2, v)                                                 &&
                addr_valid_match(ev1, ev2, av1, av2, v)                                 &&
                private_data_match(ev1, ev2, am1, am2, m1, m2, v)))                     &&
            (forall ri : regindex_t :: valid_regindex(ri) ==> (regs1[ri] == regs2[ri])) &&
-           (pc1 == pc2 && entrypoint1 == entrypoint2))
+           (pc1 == pc2 && entrypoint1 == entrypoint2 && privileged1 == privileged2)    &&
+           (forall e : tap_enclave_id_t :: valid_enclave_id_index(e) ==>
+              encl_owner_map_match(valid1, valid2, ownermap1, ownermap2, e, e1, e2)))
           <==> (t1 == t2);
   ensures ((exists v : vaddr_t :: 
               (!excl_match(ev1, ev2, v)                                               ||
                !addr_valid_match(ev1, ev2, av1, av2, v)                               ||
                !private_data_match(ev1, ev2, am1, am2, m1, m2, v)))                   ||
            (exists ri : regindex_t :: valid_regindex(ri) && (regs1[ri] != regs2[ri])) ||
-           (pc1 != pc2 || entrypoint1 != entrypoint2))
-          <==> (t1 != t2);
+           (pc1 != pc2 || entrypoint1 != entrypoint2 || privileged1 != privileged2)   || 
+           (exists e : tap_enclave_id_t :: valid_enclave_id_index(e) &&
+              !encl_owner_map_match(valid1, valid2, ownermap1, ownermap2, e, e1, e2)))
+          ==> (t1 != t2);
 {
   var index : int;
   var va    : vaddr_t;
-
+  // Loop 1. update digest/measurement by cpu state and metadata.
+  // A stronger assume: e1 == e2 ==> digest1 == digest2
   t1 := 0; t2 := 0; index := 0;
   while (index < kmax_cpu_measurement_index)
     invariant (index >= 0 && index <= kmax_cpu_measurement_index);
-    invariant ((pc1 == pc2 && entrypoint1 == entrypoint2 && e1 == e2)                    &&
+    invariant ((pc1 == pc2 && entrypoint1 == entrypoint2 && e1 == e2 && privileged1 == privileged2) &&
                (forall ri : regindex_t :: valid_regindex(ri) ==> regs1[ri] == regs2[ri]) &&
-               (forall v : vaddr_t :: av1[v] == av2[v] && am1[v] == am2[v]))
+               (forall v : vaddr_t :: av1[v] == av2[v] && am1[v] == am2[v]) &&
+               (forall e : tap_enclave_id_t :: valid_enclave_id_index(e) ==> 
+                  encl_owner_map_match(valid1, valid2, ownermap1, ownermap2, e, e1, e2)))
               ==> (t1 == t2);
+    // Step by step.
+    // 1 step over: pc
     invariant (index >= 1) ==> ((pc1 != pc2) ==> (t1 != t2));
     invariant (index <= 1) ==> ((pc1 == pc2) ==> (t1 == t2));
-    invariant (index >= 2) ==> ((entrypoint1 != entrypoint2) ==> (t1 != t2));
-    invariant (index <= 2) ==> (((pc1 == pc2) && (entrypoint1 == entrypoint2)) ==> (t1 == t2));
-    invariant (index >= 2) ==> 
-                ((exists ri : regindex_t :: 
-                    (valid_regindex(ri) && ri < (index-2) && (regs1[ri] != regs2[ri]))) 
-                        ==> (t1 != t2));
-    invariant (index >= 3) ==> 
-          (((pc1 == pc2) && (entrypoint1 == entrypoint2) &&
-            (forall ri : regindex_t :: 
-                (valid_regindex(ri) && ri < (index-2)) ==> (regs1[ri] == regs2[ri])))
-          ==> (t1 == t2));
+    // 2 steps over: entry
+    invariant (index >= kbias_cpu_measurement_index) ==> ((entrypoint1 != entrypoint2) ==> (t1 != t2));
+    invariant (index <= kbias_cpu_measurement_index) ==> (((pc1 == pc2) && (entrypoint1 == entrypoint2)) ==> (t1 == t2));
+    // 2+n (n<=512) steps over: regs
+    invariant (index > kbias_cpu_measurement_index && index <= kmax_cpu_regs_bound_index) ==> 
+                ((pc1 == pc2) && (entrypoint1 == entrypoint2) && 
+                 (forall ri : regindex_t :: 
+                      (valid_regindex(ri) && ri < index - kbias_cpu_measurement_index) ==> regs1[ri] == regs2[ri]) 
+                          ==> (t1 == t2));
+    invariant (index > kbias_cpu_measurement_index) ==> 
+              ((exists ri : regindex_t :: 
+                  (valid_regindex(ri) && ri < (index - kbias_cpu_measurement_index) && (regs1[ri] != regs2[ri]))) 
+                      ==> (t1 != t2));
+    invariant (index >= kmax_cpu_regs_bound_index) ==> 
+                ((exists ri : regindex_t :: valid_regindex(ri) && 
+                  regs1[ri] != regs2[ri]) ==> (t1 != t2));
+    // 2+512+1 steps over: privilege tag
+    invariant (index > kmax_cpu_regs_bound_index && index <= kmax_cpu_privil_bound_index) ==> 
+                ((pc1 == pc2) && (entrypoint1 == entrypoint2) && (privileged1 == privileged2) && 
+                 (forall ri : regindex_t :: 
+                       valid_regindex(ri) ==> regs1[ri] == regs2[ri]) 
+                          ==> (t1 == t2));    
+    invariant (index > kmax_cpu_regs_bound_index) ==> 
+              ((privileged1 != privileged2) ==> (t1 != t2));
+    // 2+512+1+n (n<=512) steps over: ownermap
+    invariant (index > kmax_cpu_privil_bound_index && index <= kmax_cpu_measurement_index) ==> 
+                ((pc1 == pc2) && (entrypoint1 == entrypoint2) && (privileged1 == privileged2) && 
+                 (forall ri : regindex_t :: 
+                       valid_regindex(ri) ==> regs1[ri] == regs2[ri]) &&
+                 (forall e : tap_enclave_id_t :: 
+                      (valid_enclave_id_index(e) && e < index - kmax_cpu_privil_bound_index) ==> 
+                          encl_owner_map_match(valid1, valid2, ownermap1, ownermap2, e, e1, e2)) 
+                              ==> (t1 == t2));
+    invariant (index > kmax_cpu_privil_bound_index) ==> 
+              ((exists e : tap_enclave_id_t :: 
+                      ( valid_enclave_id_index(e) && 
+                        e < index - kmax_cpu_privil_bound_index && 
+                       !encl_owner_map_match(valid1, valid2, ownermap1, ownermap2, e, e1, e2))) 
+                          ==> (t1 != t2));
   {
-    call t1 := measure_cpu_state_at_index(regs1, pc1, entrypoint1, index, t1);
-    call t2 := measure_cpu_state_at_index(regs2, pc2, entrypoint2, index, t2);
+    call t1 := measure_cpu_state_at_index(e1, regs1, pc1, entrypoint1, index, privileged1, ownermap1, valid1, t1);
+    call t2 := measure_cpu_state_at_index(e2, regs2, pc2, entrypoint2, index, privileged2, ownermap2, valid2, t2);
     index := index + 1;
   }
   assert ((forall ri : regindex_t :: valid_regindex(ri) ==> (regs1[ri] == regs2[ri])) &&
-          pc1 == pc2 && entrypoint1 == entrypoint2)
+          pc1 == pc2 && entrypoint1 == entrypoint2 && privileged1 == privileged2 && 
+          (forall e : tap_enclave_id_t :: valid_enclave_id_index(e) ==> 
+              encl_owner_map_match(valid1, valid2, ownermap1, ownermap2, e, e1, e2)))
          <==> (t1 == t2);
   assert ((exists ri : regindex_t :: valid_regindex(ri) && (regs1[ri] != regs2[ri])) ||
-          pc1 != pc2 || entrypoint1 != entrypoint2)
+          pc1 != pc2 || entrypoint1 != entrypoint2 || privileged1 != privileged2 || 
+          (exists e : tap_enclave_id_t :: valid_enclave_id_index(e) && 
+              !encl_owner_map_match(valid1, valid2, ownermap1, ownermap2, e, e1, e2)))
          <==> (t1 != t2);
-
+  // assume false;
+  // Loop 2. update digest/measurement by v
   va := k0_vaddr_t;
   while (LT_va(va, kmax_vaddr_t)) 
     invariant ((forall ri : regindex_t :: valid_regindex(ri) ==> (regs1[ri] == regs2[ri])) &&
-               pc1 == pc2 && entrypoint1 == entrypoint2 &&
-               (forall v : vaddr_t :: LT_va(v, va) ==> 
-                  (excl_match(ev1, ev2, v)                                                 &&
-                   addr_valid_match(ev1, ev2, av1, av2, v)                                 &&
-                   private_data_match(ev1, ev2, am1, am2, m1, m2, v))))
+               pc1 == pc2 && entrypoint1 == entrypoint2 && privileged1 == privileged2      &&
+               (forall e : tap_enclave_id_t :: valid_enclave_id_index(e) ==>
+                  encl_owner_map_match(valid1, valid2, ownermap1, ownermap2, e, e1, e2)))  &&
+               (forall v : vaddr_t :: 
+                  LT_va(v, va) ==> 
+                      (excl_match(ev1, ev2, v) &&
+                      addr_valid_match(ev1, ev2, av1, av2, v) &&
+                      private_data_match(ev1, ev2, am1, am2, m1, m2, v)))                  
                ==> (t1 == t2);
     invariant ((exists ri : regindex_t :: valid_regindex(ri) && (regs1[ri] != regs2[ri])) ||
-               pc1 != pc2 || entrypoint1 != entrypoint2 || 
+               pc1 != pc2 || entrypoint1 != entrypoint2 || privileged1 != privileged2 ||
                (exists v : vaddr_t :: 
                    LT_va(v, va) && 
-                      (!excl_match(ev1, ev2, v)                                               ||
-                       !addr_valid_match(ev1, ev2, av1, av2, v)                               ||
-                       !private_data_match(ev1, ev2, am1, am2, m1, m2, v))))
+                      (!excl_match(ev1, ev2, v) ||
+                       !addr_valid_match(ev1, ev2, av1, av2, v) ||
+                       !private_data_match(ev1, ev2, am1, am2, m1, m2, v)))                 ||
+               (exists e : tap_enclave_id_t :: valid_enclave_id_index(e) &&
+                  !encl_owner_map_match(valid1, valid2, ownermap1, ownermap2, e, e1, e2)))
                ==> (t1 != t2);
   {
     t1 := update_digest_virt_addr(av1, am1, ev1, m1, va, t1);
@@ -187,11 +298,37 @@ procedure measure_state_self_composed(
   }
   t1 := update_digest_virt_addr(av1, am1, ev1, m1, va, t1);
   t2 := update_digest_virt_addr(av2, am2, ev2, m2, va, t2);
+
+  // // Loop 2 with assumption.
+  // assume t1 == t2;
+  // va := k0_vaddr_t;
+  // while (LT_va(va, kmax_vaddr_t))
+  //   invariant (forall v : vaddr_t :: 
+  //                 (LT_va(v, va) && LT_va(v, kmax_vaddr_t)) ==> 
+  //                     (excl_match(ev1, ev2, v) &&
+  //                     addr_valid_match(ev1, ev2, av1, av2, v) &&
+  //                     private_data_match(ev1, ev2, am1, am2, m1, m2, v)))                  
+  //              ==> (t1 == t2);
+  //   invariant (exists v : vaddr_t :: 
+  //                  (LT_va(v, va) && LT_va(v, kmax_vaddr_t)) && 
+  //                     (!excl_match(ev1, ev2, v) ||
+  //                      !addr_valid_match(ev1, ev2, av1, av2, v) ||
+  //                      !private_data_match(ev1, ev2, am1, am2, m1, m2, v))) 
+  //              ==> (t1 != t2);
+  // {
+  //   t1 := update_digest_virt_addr(av1, am1, ev1, m1, va, t1);
+  //   t2 := update_digest_virt_addr(av2, am2, ev2, m2, va, t2);
+  //   va := PLUS_va(va, k1_vaddr_t);
+  // }
+  // t1 := update_digest_virt_addr(av1, am1, ev1, m1, va, t1);
+  // t2 := update_digest_virt_addr(av2, am2, ev2, m2, va, t2);
+
 }
 
 //--------------------------------------------------------------------------//
 // Measurement API                                                          //
 //--------------------------------------------------------------------------//
+// Deprecated in measurement proof. Use measurement-self-composed instead.
 procedure {:inline 1} measure()
     returns (status : enclave_op_result_t, measurement : measurement_t)
 {
@@ -212,7 +349,13 @@ procedure {:inline 1} measure()
                                     tap_enclave_metadata_pc[cpu_enclave_id], 
                                     tap_enclave_metadata_pc[cpu_enclave_id], 
                                     tap_enclave_metadata_entrypoint[cpu_enclave_id],
-                                    tap_enclave_metadata_entrypoint[cpu_enclave_id]);
+                                    tap_enclave_metadata_entrypoint[cpu_enclave_id],
+                                    tap_enclave_metadata_privileged_1[cpu_enclave_id],
+                                    tap_enclave_metadata_privileged_2[cpu_enclave_id],
+                                    tap_enclave_metadata_owner_map_1,
+                                    tap_enclave_metadata_owner_map_2,
+                                    tap_enclave_metadata_valid_1,
+                                    tap_enclave_metadata_valid_2);
     assert measurement == temp;
     status := enclave_op_success;
 }
diff --git a/AbstractPlatform/MeasurementProof.bpl b/AbstractPlatform/MeasurementProof.bpl
old mode 100644
new mode 100755
index bdf5569..6e49966
--- a/AbstractPlatform/MeasurementProof.bpl
+++ b/AbstractPlatform/MeasurementProof.bpl
@@ -27,6 +27,16 @@ procedure {:inline 1} MeasurementEnclaveComputation(iter : int)
     var excp    : exception_t;
     var hit     : bool;
     var way     : cache_way_index_t;
+    var i_eid   : tap_enclave_id_t;
+    var is_invalid_id : bool;
+    var another_eid : tap_enclave_id_t;
+
+    // Determine another trace's eid, just for validation sync.
+    // Not elegant, but it's Z3-provable. Quite weird.
+    another_eid := cpu_enclave_id_1;    
+    assume (cpu_enclave_id_1 != cpu_enclave_id_2 && cpu_enclave_id == cpu_enclave_id_1) ==> (another_eid == cpu_enclave_id_2);
+    assume (cpu_enclave_id_1 != cpu_enclave_id_2 && cpu_enclave_id == cpu_enclave_id_2) ==> (another_eid == cpu_enclave_id_1);
+    assume (cpu_enclave_id_1 == cpu_enclave_id_2) ==> (another_eid == cpu_enclave_id_1);
 
     eid := cpu_enclave_id;
     pc_pa := cpu_addr_map[cpu_pc];
@@ -39,14 +49,40 @@ procedure {:inline 1} MeasurementEnclaveComputation(iter : int)
     // two register sources.
     r0 := cpu_regs[uf_cpu_r0_index(pc_op)];
     r1 := cpu_regs[uf_cpu_r1_index(pc_op)];
+    
+    // operation sync.
+    i_eid := uf_load_selector(cpu_pc, pc_op, r0, r1);
+    // strongest version.
+    if (!tap_enclave_metadata_privileged[cpu_enclave_id] || i_eid == another_eid) {
+        i_eid := cpu_enclave_id;
+    } 
+    is_invalid_id :=    ((!tap_enclave_metadata_valid[i_eid]) || 
+                         (tap_enclave_metadata_privileged[cpu_enclave_id]  && i_eid != cpu_enclave_id && tap_enclave_metadata_owner_map[i_eid] != cpu_enclave_id) || 
+                         (!tap_enclave_metadata_privileged[cpu_enclave_id] && i_eid != cpu_enclave_id));
+    if (is_invalid_id) {
+        vaddr := k0_vaddr_t;
+        data  := k0_word_t;
+        return;
+    }
 
     // load address and value.
     l_vaddr := uf_mem_load_vaddr(cpu_pc, pc_op, r0, r1);
-    assume tap_addr_perm_r(cpu_addr_valid[l_vaddr]);
-    if(tap_enclave_metadata_addr_excl[eid][l_vaddr]) {
-        assert cpu_owner_map[cpu_addr_map[l_vaddr]] == eid;
-        havoc way; assume valid_cache_way_index(way);
-        call l_data, excp, hit := load_va(l_vaddr, way);
+    // assume tap_addr_perm_r(cpu_addr_valid[l_vaddr]);
+    assume tap_addr_perm_r(tap_enclave_metadata_addr_valid[i_eid][l_vaddr]);
+
+    // select proper virtual address.
+    assume tap_enclave_metadata_addr_excl_1[i_eid][l_vaddr] <==> tap_enclave_metadata_addr_excl_2[i_eid][l_vaddr];
+
+    if(tap_enclave_metadata_addr_excl[i_eid][l_vaddr]) {
+        // assert cpu_owner_map[cpu_addr_map[l_vaddr]] == eid;
+        // havoc way; assume valid_cache_way_index(way);
+        // call l_data, excp, hit := load_va(l_vaddr, way);
+        
+        // load from exclusive memory
+        havoc way; 
+        assume valid_cache_way_index(way);
+        call l_data, excp, hit := load_va(i_eid, l_vaddr, way);
+        assert excp == excp_none;
     } else {
         l_data := uf_load_data(l_vaddr, iter);
         excp := excp_none;
@@ -80,13 +116,28 @@ procedure {:inline 1} MeasurementEnclaveComputation(iter : int)
     rd := uf_cpu_r2_index(pc_op);
     cpu_regs[rd] := uf_cpu_result(cpu_pc, pc_op, l_data, r0, r1);
 }
-                      
-function {:inline 1} is_measurement_untrusted_op(op : tap_proof_op_t) : bool
+// Boogie 2.16.4.0
+//    Parameter to :inline attribute on a function must be Boolean
+function is_measurement_untrusted_op(op : tap_proof_op_t) : bool
 { 
-  op == tap_proof_op_resume || op == tap_proof_op_enter 
+  op == tap_proof_op_resume || 
+  op == tap_proof_op_enter  ||
+  op == tap_proof_op_exit   || 
+  op == tap_proof_op_pause
+}
+// enter pass, resume failed
+function is_measurement_privilege_op(op : tap_proof_op_t) : bool
+{
+  op == tap_proof_op_enter      || 
+  op == tap_proof_op_compute    ||
+  op == tap_proof_op_destroy    ||
+  op == tap_proof_op_exit       ||
+  op == tap_proof_op_launch     ||
+  op == tap_proof_op_resume     ||
+  op == tap_proof_op_pause
 }
 
-function {:inline 1} is_measurement_enclave_op(op : tap_proof_op_t) : bool
+function is_measurement_enclave_op(op : tap_proof_op_t) : bool
 { 
   op == tap_proof_op_compute    ||
   op == tap_proof_op_pause      ||
@@ -94,9 +145,10 @@ function {:inline 1} is_measurement_enclave_op(op : tap_proof_op_t) : bool
 }
 
 procedure {:inline 1} MeasurementUntrustedOp(
-    /* operation */ op   : tap_proof_op_t, 
-    /* enclave   */ eid  : tap_enclave_id_t,
-    /* args      */ regs : regs_t
+    /* mode      */ mode    : mode_t,
+    /* operation */ op      : tap_proof_op_t, 
+    /* enclave   */ eid     : tap_enclave_id_t,
+    /* args      */ r_regs  : regs_t
 ) 
   returns (status : enclave_op_result_t, current_mode : mode_t)
   modifies cpu_mem;
@@ -106,10 +158,6 @@ procedure {:inline 1} MeasurementUntrustedOp(
   modifies cpu_addr_valid;
   modifies cpu_addr_map;
   modifies cpu_owner_map;
-  modifies untrusted_addr_valid;
-  modifies untrusted_addr_map;
-  modifies untrusted_regs;
-  modifies untrusted_pc;
   modifies tap_enclave_metadata_valid;
   modifies tap_enclave_metadata_addr_map;
   modifies tap_enclave_metadata_addr_valid;
@@ -119,26 +167,65 @@ procedure {:inline 1} MeasurementUntrustedOp(
   modifies tap_enclave_metadata_paused;
   modifies tap_enclave_metadata_cache_conflict;
 {
+    var regs    : regs_t;
+
     assert (is_measurement_untrusted_op(op));
+    regs := cpu_regs;
     status := enclave_op_success;
+
+    assert (cpu_enclave_id != tap_null_enc_id) ==> 
+        (tap_enclave_metadata_owner_map[cpu_enclave_id] == eid);
+    assert (cpu_enclave_id != tap_null_enc_id) ==> 
+        (tap_enclave_metadata_privileged[tap_enclave_metadata_owner_map[cpu_enclave_id]]);
+
     if (op == tap_proof_op_enter) {
-        cpu_regs := regs;
         call status := enter(eid);
-        assert status == enclave_op_success;
-        current_mode := mode_enclave;
+        cpu_regs := r_regs;
+        
+        assert mode == mode_enclave ==> status == enclave_op_success;
+        if (status == enclave_op_success) {
+            current_mode := mode_enclave;
+        } else {
+            cpu_regs := regs;
+            current_mode := mode_untrusted;
+        }
+
     } else if (op == tap_proof_op_resume) {
         call status := resume(eid);
+        assert mode == mode_enclave ==> status == enclave_op_success;
         if (status == enclave_op_success) {
             current_mode := mode_enclave;
         } else {
             current_mode := mode_untrusted;
         }
+
+    } else if (op == tap_proof_op_exit) {
+        call status := exit();
+        if (status == enclave_op_success) {
+           current_mode := mode_enclave;
+        } else {
+            current_mode := mode_untrusted;
+        }
+        assert mode == mode_enclave ==> status == enclave_op_success;
+
+    } else if (op == tap_proof_op_pause) {
+        call status := pause();
+        if (status == enclave_op_success) {
+            current_mode := mode_enclave;
+        } else {
+            current_mode := mode_untrusted;
+        }
+        assert mode == mode_enclave ==> status == enclave_op_success;
+
     }
+
 }
 
 procedure {:inline 1} MeasurementEnclaveOp(
-    /* operation */ op   : tap_proof_op_t,
-    /* iteration */ iter : int
+    /* mode      */ mode  : mode_t,
+    /* target    */ r_eid : tap_enclave_id_t,
+    /* operation */ op    : tap_proof_op_t,
+    /* iteration */ iter  : int
 ) 
   returns (status : enclave_op_result_t, current_mode : mode_t, vaddr : vaddr_t, word : word_t)
   modifies cpu_mem;
@@ -149,34 +236,112 @@ procedure {:inline 1} MeasurementEnclaveOp(
   modifies cpu_addr_map;
   modifies cpu_owner_map;
   modifies cache_valid_map, cache_tag_map;
-  modifies untrusted_addr_valid;
-  modifies untrusted_addr_map;
-  modifies untrusted_regs;
-  modifies untrusted_pc;
   modifies tap_enclave_metadata_valid;
   modifies tap_enclave_metadata_addr_map;
   modifies tap_enclave_metadata_addr_valid;
+  modifies tap_enclave_metadata_addr_excl;
   modifies tap_enclave_metadata_entrypoint;
   modifies tap_enclave_metadata_pc;
   modifies tap_enclave_metadata_regs;
   modifies tap_enclave_metadata_paused;
   modifies tap_enclave_metadata_cache_conflict;
+  modifies tap_enclave_metadata_privileged;
+  modifies tap_enclave_metadata_owner_map;
 {
-    assert (is_measurement_enclave_op(op));
+    var regs              : regs_t;
+    var p_regs            : regs_t;
+    var p_container_valid : container_valid_t;
+    var p_container_data  : container_data_t;
+    /* enclave launch structure */
+    var r_addr_valid      : addr_valid_t;
+    var r_addr_map        : addr_map_t;
+    var r_excl_vaddr      : excl_vaddr_t;
+    var r_excl_map        : excl_map_t;
+    var r_entrypoint      : vaddr_t;
+    var r_privileged      : bool;
+
     vaddr := k0_vaddr_t;
     word  := k0_word_t;
-    if (op == tap_proof_op_compute) {
-        call vaddr, word := MeasurementEnclaveComputation(iter);
-        status := enclave_op_success;
-        current_mode := mode_enclave;
-    } else if (op == tap_proof_op_exit) {
-        call status := exit();
-        current_mode := mode_untrusted;
-    } else if (op == tap_proof_op_pause) {
-        call status := pause();
-        current_mode := mode_untrusted;
+    regs  := cpu_regs;
+
+    if (tap_enclave_metadata_privileged[cpu_enclave_id]) {
+        assert is_measurement_privilege_op(op);
+        
+        if (op == tap_proof_op_enter) {
+            call status := enter(r_eid);
+            cpu_regs := p_regs;
+            
+            if (status == enclave_op_success) {
+                current_mode := mode_untrusted;
+            } else {
+                cpu_regs  := regs;
+                current_mode := mode_enclave;
+            }
+            // mode == mode_untrusted means we are in trace_2, sync operation.
+            // sync: all eid's children must be same stage.
+            assert mode == mode_untrusted ==> status == enclave_op_success;
+
+        } else if (op == tap_proof_op_compute) {
+            call vaddr, word := MeasurementEnclaveComputation(iter);
+            status := enclave_op_success;
+            current_mode := mode_enclave;
+
+        } else if (op == tap_proof_op_destroy) {
+            call status := destroy(r_eid);
+            current_mode := mode_enclave;
+
+        } else if (op == tap_proof_op_exit) {
+            call status := exit();
+            assert status == enclave_op_success;
+            current_mode := mode_untrusted;
+
+        } else if (op == tap_proof_op_launch) {
+            assume !tap_enclave_metadata_valid[r_eid];
+            call InitOSMem(p_container_valid, p_container_data);
+            // Apr 6, 2023. add a buildup stage for launch.
+            call r_addr_valid, r_addr_map, r_excl_vaddr, r_excl_map, r_entrypoint, r_privileged := LaunchHavoc(r_eid);
+            assume !r_privileged;
+            call status := launch(r_eid, r_addr_valid, r_addr_map,
+                                r_excl_vaddr, r_excl_map, r_entrypoint, r_privileged);
+            current_mode := mode_enclave;
+
+        } else if (op == tap_proof_op_resume) {
+            call status := resume(r_eid);
+            if (status == enclave_op_success) {
+                current_mode := mode_untrusted;
+            } else {
+                current_mode := mode_enclave;
+            }
+            assert mode == mode_untrusted ==> status == enclave_op_success;
+
+        } else if (op == tap_proof_op_pause) {
+            call status := pause();
+            assert status == enclave_op_success;
+            current_mode := mode_untrusted;
+
+        }
+        
+    } else {
+        assert is_measurement_enclave_op(op);
+
+        if (op == tap_proof_op_compute) {
+            call vaddr, word := MeasurementEnclaveComputation(iter);
+            status := enclave_op_success;
+            current_mode := mode_enclave;
+
+        } else if (op == tap_proof_op_exit) {
+            call status := exit();
+            assert status == enclave_op_success;
+            current_mode := mode_untrusted;
+
+        } else if (op == tap_proof_op_pause) {
+            call status := pause();
+            assert status == enclave_op_success;
+            current_mode := mode_untrusted;
+
+        }
     }
-    assert status == enclave_op_success;
+
 }
 
 //--------------------------------------------------------------------------//
@@ -190,7 +355,8 @@ procedure measurement_proof_part1()
       /* excl vaddr */  e_excl_vaddr_1, e_excl_vaddr_2 : excl_vaddr_t,
       /* excl paddr */  e_excl_map_1, e_excl_map_2     : excl_map_t,
       /* entrypoint */  e_entrypoint_1, e_entrypoint_2 : vaddr_t,
-      /* mode       */  current_mode                  : mode_t
+      /* privileged */  e_privileged_1, e_privileged_2 : bool,
+      /* mode       */  current_mode                   : mode_t
   )
 
   modifies cpu_mem;
@@ -203,10 +369,6 @@ procedure measurement_proof_part1()
   modifies cache_valid_map, cache_tag_map;
   modifies cache_valid_map_1, cache_tag_map_1;
   modifies cache_valid_map_2, cache_tag_map_2;
-  modifies untrusted_addr_valid;
-  modifies untrusted_addr_map;
-  modifies untrusted_regs;
-  modifies untrusted_pc;
   modifies tap_enclave_metadata_valid;
   modifies tap_enclave_metadata_addr_map;
   modifies tap_enclave_metadata_addr_valid;
@@ -216,6 +378,8 @@ procedure measurement_proof_part1()
   modifies tap_enclave_metadata_regs;
   modifies tap_enclave_metadata_paused;
   modifies tap_enclave_metadata_cache_conflict;
+  modifies tap_enclave_metadata_privileged;
+  modifies tap_enclave_metadata_owner_map;
   modifies cpu_mem_1;
   modifies cpu_regs_1;
   modifies cpu_pc_1;
@@ -223,10 +387,6 @@ procedure measurement_proof_part1()
   modifies cpu_addr_valid_1;
   modifies cpu_addr_map_1;
   modifies cpu_owner_map_1;
-  modifies untrusted_addr_valid_1;
-  modifies untrusted_addr_map_1;
-  modifies untrusted_regs_1;
-  modifies untrusted_pc_1;
   modifies tap_enclave_metadata_valid_1;
   modifies tap_enclave_metadata_addr_map_1;
   modifies tap_enclave_metadata_addr_valid_1;
@@ -236,6 +396,8 @@ procedure measurement_proof_part1()
   modifies tap_enclave_metadata_regs_1;
   modifies tap_enclave_metadata_paused_1;
   modifies tap_enclave_metadata_cache_conflict_1;
+  modifies tap_enclave_metadata_privileged_1;
+  modifies tap_enclave_metadata_owner_map_1;
   modifies cpu_mem_2;
   modifies cpu_regs_2;
   modifies cpu_pc_2;
@@ -243,10 +405,6 @@ procedure measurement_proof_part1()
   modifies cpu_addr_valid_2;
   modifies cpu_addr_map_2;
   modifies cpu_owner_map_2;
-  modifies untrusted_addr_valid_2;
-  modifies untrusted_addr_map_2;
-  modifies untrusted_regs_2;
-  modifies untrusted_pc_2;
   modifies tap_enclave_metadata_valid_2;
   modifies tap_enclave_metadata_addr_map_2;
   modifies tap_enclave_metadata_addr_valid_2;
@@ -256,12 +414,20 @@ procedure measurement_proof_part1()
   modifies tap_enclave_metadata_regs_2;
   modifies tap_enclave_metadata_paused_2;
   modifies tap_enclave_metadata_cache_conflict_2;
+  modifies tap_enclave_metadata_privileged_2;
+  modifies tap_enclave_metadata_owner_map_2;
 
   ensures (forall v : vaddr_t :: excl_match(e_excl_vaddr_1, e_excl_vaddr_2, v));
   ensures (forall v : vaddr_t :: addr_valid_match(e_excl_vaddr_1, e_excl_vaddr_2, e_addr_valid_1, e_addr_valid_2, v));
   ensures (forall v : vaddr_t :: private_data_match(e_excl_vaddr_1, e_excl_vaddr_2, e_addr_map_1, e_addr_map_2, cpu_mem_1, cpu_mem_2, v));
   ensures (forall ri : regindex_t :: valid_regindex(ri) ==> (cpu_regs_1[ri] == cpu_regs_2[ri]));
   ensures (e_entrypoint_1 == e_entrypoint_2);
+  ensures (e_privileged_1 == e_privileged_2);
+  // PE structure consistency
+  ensures (forall e : tap_enclave_id_t :: encl_owner_map_match( tap_enclave_metadata_valid_1, tap_enclave_metadata_valid_2, 
+                                                                tap_enclave_metadata_owner_map_1, tap_enclave_metadata_owner_map_2,
+                                                                e, eid_1, eid_2));
+
   ensures (current_mode == mode_untrusted);
   ensures  (forall pa : wap_addr_t, e : tap_enclave_id_t ::
                 (valid_enclave_id(e) && !tap_enclave_metadata_valid_1[e]) ==> 
@@ -333,6 +499,80 @@ procedure measurement_proof_part1()
   ensures (forall v : vaddr_t ::
                 tap_enclave_metadata_addr_excl_2[eid_2][v] ==> 
                 (cpu_owner_map_2[tap_enclave_metadata_addr_map_2[eid_2][v]] == eid_2));
+
+  ensures !tap_enclave_metadata_privileged_1[tap_null_enc_id];
+  ensures !tap_enclave_metadata_privileged_2[tap_null_enc_id];
+  ensures tap_enclave_metadata_privileged_1[eid_1] == tap_enclave_metadata_privileged_2[eid_2];
+  ensures tap_enclave_metadata_privileged_1[eid_1] == e_privileged_1;
+  ensures tap_enclave_metadata_privileged_2[eid_2] == e_privileged_2;
+
+  //  Apr 8, 2023
+  //  privileged relationship: unique PE
+  //  Apr 19, 2023
+  //  privileged relationship: multiple PE
+  ensures (forall e : tap_enclave_id_t :: 
+        (tap_enclave_metadata_valid_1[e] && tap_enclave_metadata_privileged_1[e]) ==> 
+            (tap_enclave_metadata_owner_map_1[e] == tap_null_enc_id));
+  ensures (forall e : tap_enclave_id_t :: 
+        (tap_enclave_metadata_valid_2[e] && tap_enclave_metadata_privileged_2[e]) ==> 
+            (tap_enclave_metadata_owner_map_2[e] == tap_null_enc_id));
+
+  // valid guarantee
+  ensures tap_enclave_metadata_valid_1[tap_null_enc_id];
+  ensures tap_enclave_metadata_valid_2[tap_null_enc_id];
+  ensures (forall e : tap_enclave_id_t :: special_enclave_id(e) ==> 
+    !tap_enclave_metadata_valid_1[e]);
+  ensures (forall e : tap_enclave_id_t :: special_enclave_id(e) ==> 
+    !tap_enclave_metadata_valid_2[e]);
+
+  // enclave ownermap relationship: valid enclave's parent must be valid
+  ensures (forall e : tap_enclave_id_t :: tap_enclave_metadata_valid_1[e] ==>
+    (tap_enclave_metadata_valid_1[tap_enclave_metadata_owner_map_1[e]]));
+  ensures (forall e : tap_enclave_id_t :: tap_enclave_metadata_valid_2[e] ==>
+    (tap_enclave_metadata_valid_2[tap_enclave_metadata_owner_map_2[e]]));
+
+  // enclave ownermap relationship: special children
+  ensures tap_enclave_metadata_owner_map_1[eid_1] == tap_null_enc_id;
+  ensures tap_enclave_metadata_owner_map_2[eid_2] == tap_null_enc_id;
+  ensures tap_enclave_metadata_owner_map_1[tap_null_enc_id] == tap_null_enc_id;
+  ensures tap_enclave_metadata_owner_map_2[tap_null_enc_id] == tap_null_enc_id;
+  
+  // enclave ownermap relationship: the maximal parent-tree depth is 2 
+  ensures (forall e : tap_enclave_id_t :: (tap_enclave_metadata_valid_1[e]) ==> 
+    (tap_enclave_metadata_owner_map_1[tap_enclave_metadata_owner_map_1[e]] == tap_null_enc_id));
+  ensures (forall e : tap_enclave_id_t :: (tap_enclave_metadata_valid_2[e]) ==> 
+    (tap_enclave_metadata_owner_map_2[tap_enclave_metadata_owner_map_2[e]] == tap_null_enc_id));
+  
+  // if the mode_untrusted is from PE's children enclave, then the 2 traces is in **one** children enclave of this PE.
+  ensures ((tap_enclave_metadata_owner_map_1[cpu_enclave_id_1] == eid_1) ==> 
+    (tap_enclave_metadata_valid_2[cpu_enclave_id_2]));
+  ensures ((tap_enclave_metadata_owner_map_1[cpu_enclave_id_1] == eid_1) ==>
+    (tap_enclave_metadata_owner_map_2[cpu_enclave_id_2] == eid_2));
+  
+  // enclave ownermap relationship: enclave with chidren must be privileged 
+  ensures (forall e : tap_enclave_id_t :: 
+    (tap_enclave_metadata_valid_1[e] && tap_enclave_metadata_owner_map_1[e] != tap_null_enc_id) ==> 
+      (tap_enclave_metadata_privileged_1[tap_enclave_metadata_owner_map_1[e]]));
+  ensures (forall e : tap_enclave_id_t :: 
+    (tap_enclave_metadata_valid_2[e] && tap_enclave_metadata_owner_map_2[e] != tap_null_enc_id) ==> 
+      (tap_enclave_metadata_privileged_2[tap_enclave_metadata_owner_map_2[e]]));
+
+  // extend exclusive memory consistency and structure rules. Apr 14, 2023.
+  ensures (forall e : tap_enclave_id_t, v : vaddr_t :: 
+    (tap_enclave_metadata_valid_1[e] && (tap_enclave_metadata_privileged_1[e] || tap_enclave_metadata_privileged_1[tap_enclave_metadata_owner_map_1[e]]) ==> 
+        (tap_enclave_metadata_addr_excl_1[e][v] <==> cpu_owner_map_1[tap_enclave_metadata_addr_map_1[e][v]] == e)));
+  ensures (forall e : tap_enclave_id_t, v : vaddr_t :: 
+    (tap_enclave_metadata_valid_2[e] && (tap_enclave_metadata_privileged_2[e] || tap_enclave_metadata_privileged_2[tap_enclave_metadata_owner_map_2[e]]) ==> 
+        (tap_enclave_metadata_addr_excl_2[e][v] <==> cpu_owner_map_2[tap_enclave_metadata_addr_map_2[e][v]] == e)));
+  // PE sync. the PE's structure must be same.
+  ensures (forall e : tap_enclave_id_t :: 
+        (tap_enclave_metadata_valid_1[e] && tap_enclave_metadata_owner_map_1[e] == eid_1) <==> 
+            (tap_enclave_metadata_valid_2[e] && tap_enclave_metadata_owner_map_2[e] == eid_2));
+  // PE sync. the two (PE) enclave's children pause state must be same. 
+  ensures (forall e : tap_enclave_id_t :: 
+        (tap_enclave_metadata_valid_1[e] && tap_enclave_metadata_owner_map_1[e] == eid_1) ==> 
+            (tap_enclave_metadata_paused_1[e] == tap_enclave_metadata_paused_2[e]));
+
   //----------------------------------------------------------------------//
   // invariants about the states of the CPUs.                             //
   //----------------------------------------------------------------------//
@@ -342,7 +582,6 @@ procedure measurement_proof_part1()
 {
   var status, status_1, status_2                   : enclave_op_result_t;
   var e_container_data_1, e_container_data_2       : container_data_t;
-  var enclave_dead_1, enclave_dead_2               : bool;
   var e_proof_op, r_proof_op                       : tap_proof_op_t;
   var measurement_1, measurement_2                 : measurement_t;
   var measurement_1p, measurement_2p               : measurement_t;
@@ -359,19 +598,20 @@ procedure measurement_proof_part1()
   call SaveContext_1();
   call SaveContext_2();
 
+  assume valid_enclave_id_index(eid_1) && valid_enclave_id_index(eid_2);
   // Enclave 1
   call RestoreContext_1();
-  call current_mode_1 := InitialHavoc();
+  call current_mode_1 := InitialHavoc(eid_1);
   call InitOSMem(e_excl_map_1, e_container_data_1);
-  call status := launch(eid_1, e_addr_valid_1, e_addr_map_1, e_excl_vaddr_1, e_excl_map_1, e_entrypoint_1);
+  call status := launch(eid_1, e_addr_valid_1, e_addr_map_1, e_excl_vaddr_1, e_excl_map_1, e_entrypoint_1, e_privileged_1);
   assume status == enclave_op_success;
   call SaveContext_1();
 
   // Repeat for second enclave.
   call RestoreContext_2();
-  call current_mode_2 := InitialHavoc();
+  call current_mode_2 := InitialHavoc(eid_2);
   call InitOSMem(e_excl_map_2, e_container_data_2);
-  call status := launch(eid_2, e_addr_valid_2, e_addr_map_2, e_excl_vaddr_2, e_excl_map_2, e_entrypoint_2);
+  call status := launch(eid_2, e_addr_valid_2, e_addr_map_2, e_excl_vaddr_2, e_excl_map_2, e_entrypoint_2, e_privileged_2);
   assume status == enclave_op_success;
   call SaveContext_2();
 
@@ -383,7 +623,12 @@ procedure measurement_proof_part1()
                                         cpu_mem_1,          cpu_mem_2, 
                                         cpu_regs_1,         cpu_regs_2,
                                         e_entrypoint_1,     e_entrypoint_2,
-                                        e_entrypoint_1,     e_entrypoint_2);
+                                        e_entrypoint_1,     e_entrypoint_2,
+                                        e_privileged_1,     e_privileged_2,
+                                        tap_enclave_metadata_owner_map_1, 
+                                        tap_enclave_metadata_owner_map_2,
+                                        tap_enclave_metadata_valid_1,
+                                        tap_enclave_metadata_valid_2 );
   assert ((forall v : vaddr_t :: 
                 (excl_match(e_excl_vaddr_1, e_excl_vaddr_2, v)                 &&
                  addr_valid_match(e_excl_vaddr_1, e_excl_vaddr_2, 
@@ -393,8 +638,15 @@ procedure measurement_proof_part1()
                                     cpu_mem_1, cpu_mem_2, v)))                 &&
            (forall ri : regindex_t :: valid_regindex(ri) ==> 
                                         (cpu_regs_1[ri] == cpu_regs_2[ri]))    &&
-           (e_entrypoint_1 == e_entrypoint_2))
+           (e_entrypoint_1 == e_entrypoint_2)                                  && 
+           (e_privileged_1 == e_privileged_2)                                  && 
+           (forall e : tap_enclave_id_t :: 
+                encl_owner_map_match( tap_enclave_metadata_valid_1, tap_enclave_metadata_valid_2, 
+                                      tap_enclave_metadata_owner_map_1, tap_enclave_metadata_owner_map_2,
+                                      e, eid_1, eid_2))
+           )
           <==> (measurement_1p == measurement_2p);
+  // Proof p1 over. Prove p2 based on p1.
   assume measurement_1p == measurement_2p;
   assert current_mode_1 == current_mode_2;
   current_mode := current_mode_1;
@@ -407,7 +659,8 @@ procedure measurement_proof_part2
   /* addr_map   */  e_addr_map_1, e_addr_map_2     : addr_map_t,
   /* excl vaddr */  e_addr_excl_1, e_addr_excl_2   : excl_vaddr_t,
   /* excl       */  e_excl_map_1, e_excl_map_2     : excl_map_t,
-  /* entrypoint */  e_entrypoint_1, e_entrypoint_2 : vaddr_t
+  /* entrypoint */  e_entrypoint_1, e_entrypoint_2 : vaddr_t,
+  /* privileged */  e_privileged_1, e_privileged_2 : bool
 )
   
   modifies cpu_mem;
@@ -420,10 +673,6 @@ procedure measurement_proof_part2
   modifies cache_valid_map, cache_tag_map;
   modifies cache_valid_map_1, cache_tag_map_1;
   modifies cache_valid_map_2, cache_tag_map_2;
-  modifies untrusted_addr_valid;
-  modifies untrusted_addr_map;
-  modifies untrusted_regs;
-  modifies untrusted_pc;
   modifies tap_enclave_metadata_valid;
   modifies tap_enclave_metadata_addr_map;
   modifies tap_enclave_metadata_addr_valid;
@@ -433,6 +682,8 @@ procedure measurement_proof_part2
   modifies tap_enclave_metadata_regs;
   modifies tap_enclave_metadata_paused;
   modifies tap_enclave_metadata_cache_conflict;
+  modifies tap_enclave_metadata_privileged;
+  modifies tap_enclave_metadata_owner_map;
   modifies cpu_mem_1;
   modifies cpu_regs_1;
   modifies cpu_pc_1;
@@ -440,10 +691,6 @@ procedure measurement_proof_part2
   modifies cpu_addr_valid_1;
   modifies cpu_addr_map_1;
   modifies cpu_owner_map_1;
-  modifies untrusted_addr_valid_1;
-  modifies untrusted_addr_map_1;
-  modifies untrusted_regs_1;
-  modifies untrusted_pc_1;
   modifies tap_enclave_metadata_valid_1;
   modifies tap_enclave_metadata_addr_map_1;
   modifies tap_enclave_metadata_addr_valid_1;
@@ -453,6 +700,8 @@ procedure measurement_proof_part2
   modifies tap_enclave_metadata_regs_1;
   modifies tap_enclave_metadata_paused_1;
   modifies tap_enclave_metadata_cache_conflict_1;
+  modifies tap_enclave_metadata_privileged_1;
+  modifies tap_enclave_metadata_owner_map_1;
   modifies cpu_mem_2;
   modifies cpu_regs_2;
   modifies cpu_pc_2;
@@ -460,10 +709,6 @@ procedure measurement_proof_part2
   modifies cpu_addr_valid_2;
   modifies cpu_addr_map_2;
   modifies cpu_owner_map_2;
-  modifies untrusted_addr_valid_2;
-  modifies untrusted_addr_map_2;
-  modifies untrusted_regs_2;
-  modifies untrusted_pc_2;
   modifies tap_enclave_metadata_valid_2;
   modifies tap_enclave_metadata_addr_map_2;
   modifies tap_enclave_metadata_addr_valid_2;
@@ -473,6 +718,8 @@ procedure measurement_proof_part2
   modifies tap_enclave_metadata_regs_2;
   modifies tap_enclave_metadata_paused_2;
   modifies tap_enclave_metadata_cache_conflict_2;
+  modifies tap_enclave_metadata_privileged_2;
+  modifies tap_enclave_metadata_owner_map_2;
 
   requires (forall v : vaddr_t :: excl_match(e_addr_excl_1, e_addr_excl_2, v));
   requires (forall v : vaddr_t :: addr_valid_match(e_addr_excl_1, e_addr_excl_2, 
@@ -483,6 +730,7 @@ procedure measurement_proof_part2
                                     cpu_mem_1, cpu_mem_2, v));
   requires (forall ri : regindex_t :: valid_regindex(ri) ==> (cpu_regs_1[ri] == cpu_regs_2[ri]));
   requires (e_entrypoint_1 == e_entrypoint_2);
+  requires (e_privileged_1 == e_privileged_2);
   requires  (forall pa : wap_addr_t, e : tap_enclave_id_t ::
               (valid_enclave_id(e) && !tap_enclave_metadata_valid_1[e]) ==> 
                   (cpu_owner_map_1[pa] != e));
@@ -555,10 +803,76 @@ procedure measurement_proof_part2
             cpu_enclave_id_2 == tap_null_enc_id);
   requires (tap_addr_perm_x(cpu_addr_valid_1[cpu_pc_1]) && 
             tap_addr_perm_x(cpu_addr_valid_2[cpu_pc_2]));
+  //----------------------------------------------------------------------//
+  // invariants about PE-related structure rules                          //
+  //----------------------------------------------------------------------//
+  requires !tap_enclave_metadata_privileged_1[tap_null_enc_id];
+  requires !tap_enclave_metadata_privileged_2[tap_null_enc_id];
+  requires  tap_enclave_metadata_privileged_1[eid_1] == tap_enclave_metadata_privileged_2[eid_2];
+  requires  tap_enclave_metadata_privileged_1[eid_1] == e_privileged_1;
+  requires  tap_enclave_metadata_privileged_2[eid_2] == e_privileged_2;
+  //  Apr 19, 2023
+  //  privileged relationship: multiple PE
+  requires (forall e : tap_enclave_id_t :: 
+        (tap_enclave_metadata_valid_1[e] && tap_enclave_metadata_privileged_1[e]) ==> 
+            (tap_enclave_metadata_owner_map_1[e] == tap_null_enc_id));
+  requires (forall e : tap_enclave_id_t :: 
+        (tap_enclave_metadata_valid_2[e] && tap_enclave_metadata_privileged_2[e]) ==> 
+            (tap_enclave_metadata_owner_map_2[e] == tap_null_enc_id));
+
+  // valid guarantee
+  requires tap_enclave_metadata_valid_1[tap_null_enc_id];
+  requires tap_enclave_metadata_valid_2[tap_null_enc_id];
+  requires (forall e : tap_enclave_id_t :: special_enclave_id(e) ==> 
+            !tap_enclave_metadata_valid_1[e]);
+  requires (forall e : tap_enclave_id_t :: special_enclave_id(e) ==> 
+            !tap_enclave_metadata_valid_2[e]);
+  // enclave ownermap relationship: valid enclave's parent must be valid
+  requires (forall e : tap_enclave_id_t :: tap_enclave_metadata_valid_1[e] ==>
+          (tap_enclave_metadata_valid_1[tap_enclave_metadata_owner_map_1[e]]));
+  requires (forall e : tap_enclave_id_t :: tap_enclave_metadata_valid_2[e] ==>
+          (tap_enclave_metadata_valid_2[tap_enclave_metadata_owner_map_2[e]]));
+  // enclave ownermap relationship: special children
+  requires tap_enclave_metadata_owner_map_1[eid_1] == tap_null_enc_id;
+  requires tap_enclave_metadata_owner_map_2[eid_2] == tap_null_enc_id;
+  requires tap_enclave_metadata_owner_map_1[tap_null_enc_id] == tap_null_enc_id;
+  requires tap_enclave_metadata_owner_map_2[tap_null_enc_id] == tap_null_enc_id;
+  // enclave ownermap relationship: the maximal parent-tree depth is 2 
+  requires (forall e : tap_enclave_id_t :: (tap_enclave_metadata_valid_1[e]) ==> 
+          (tap_enclave_metadata_owner_map_1[tap_enclave_metadata_owner_map_1[e]] == tap_null_enc_id));
+  requires (forall e : tap_enclave_id_t :: (tap_enclave_metadata_valid_2[e]) ==> 
+          (tap_enclave_metadata_owner_map_2[tap_enclave_metadata_owner_map_2[e]] == tap_null_enc_id));
+  // if the mode_untrusted is from PE's children enclave, then the 2 traces is in **one** children enclave of this PE.
+  requires ((tap_enclave_metadata_owner_map_1[cpu_enclave_id_1] == eid_1) ==> 
+          (tap_enclave_metadata_valid_2[cpu_enclave_id_2]));
+  requires ((tap_enclave_metadata_owner_map_1[cpu_enclave_id_1] == eid_1) ==>
+          (tap_enclave_metadata_owner_map_2[cpu_enclave_id_2] == eid_2));
+  // enclave ownermap relationship: enclave with chidren must be privileged 
+  requires (forall e : tap_enclave_id_t :: 
+          (tap_enclave_metadata_valid_1[e] && tap_enclave_metadata_owner_map_1[e] != tap_null_enc_id) ==> 
+                (tap_enclave_metadata_privileged_1[tap_enclave_metadata_owner_map_1[e]]));
+  requires (forall e : tap_enclave_id_t :: 
+          (tap_enclave_metadata_valid_2[e] && tap_enclave_metadata_owner_map_2[e] != tap_null_enc_id) ==> 
+                (tap_enclave_metadata_privileged_2[tap_enclave_metadata_owner_map_2[e]]));
+  // extend exclusive memory consistency and structure rules. Apr 14, 2023.
+  requires (forall e : tap_enclave_id_t, v : vaddr_t :: 
+          (tap_enclave_metadata_valid_1[e] && (tap_enclave_metadata_privileged_1[e] || tap_enclave_metadata_privileged_1[tap_enclave_metadata_owner_map_1[e]]) ==> 
+                (tap_enclave_metadata_addr_excl_1[e][v] <==> cpu_owner_map_1[tap_enclave_metadata_addr_map_1[e][v]] == e)));
+  requires (forall e : tap_enclave_id_t, v : vaddr_t :: 
+          (tap_enclave_metadata_valid_2[e] && (tap_enclave_metadata_privileged_2[e] || tap_enclave_metadata_privileged_2[tap_enclave_metadata_owner_map_2[e]]) ==> 
+                (tap_enclave_metadata_addr_excl_2[e][v] <==> cpu_owner_map_2[tap_enclave_metadata_addr_map_2[e][v]] == e)));
+  // PE sync. the PE's structure must be same.
+  requires (forall e : tap_enclave_id_t :: 
+          (tap_enclave_metadata_valid_1[e] && tap_enclave_metadata_owner_map_1[e] == eid_1) <==> 
+                (tap_enclave_metadata_valid_2[e] && tap_enclave_metadata_owner_map_2[e] == eid_2));
+  // PE sync. the two (PE) enclave's children pause state must be same. 
+  requires (forall e : tap_enclave_id_t :: 
+          (tap_enclave_metadata_valid_1[e] && tap_enclave_metadata_owner_map_1[e] == eid_1) ==> 
+                (tap_enclave_metadata_paused_1[e] == tap_enclave_metadata_paused_2[e]));
 {
+  var r_eid                                        : tap_enclave_id_t;
   var status, status_1, status_2                   : enclave_op_result_t;
   var e_container_data_1, e_container_data_2       : container_data_t;
-  var enclave_dead_1, enclave_dead_2               : bool;
   var e_proof_op, r_proof_op                       : tap_proof_op_t;
   var measurement_1, measurement_2                 : measurement_t;
   var measurement_1p, measurement_2p               : measurement_t;
@@ -567,23 +881,94 @@ procedure measurement_proof_part2
   var memp_1, memp_2                               : mem_t;
   var word_1, word_2                               : word_t;
   var proof_op                                     : tap_proof_op_t;
-  var regs                                         : regs_t;
+  var regs, r_regs                                 : regs_t;
   var shared_vaddr_map                             : shared_vaddr_map_t;
   var current_mode                                 : mode_t;
   var current_mode_1, current_mode_2               : mode_t;
   var iter                                         : int;
-
+  
   current_mode := mode_untrusted;
   while (*)
     //----------------------------------------------------------------------//
     // global TAP invariants.                                               //
     //----------------------------------------------------------------------//
+    
+    // privilege relationship: OS & eid
+    invariant !tap_enclave_metadata_privileged_1[tap_null_enc_id];
+    invariant !tap_enclave_metadata_privileged_2[tap_null_enc_id];
+    invariant tap_enclave_metadata_privileged_1[eid_1] == tap_enclave_metadata_privileged_2[eid_2];
+    invariant  tap_enclave_metadata_privileged_1[eid_1] == e_privileged_1;
+    invariant  tap_enclave_metadata_privileged_2[eid_2] == e_privileged_2;
+    //  Apr 19, 2023
+    //  privileged relationship: multiple PE
+    invariant (forall e : tap_enclave_id_t :: 
+            (tap_enclave_metadata_valid_1[e] && tap_enclave_metadata_privileged_1[e]) ==> 
+                (tap_enclave_metadata_owner_map_1[e] == tap_null_enc_id));
+    invariant (forall e : tap_enclave_id_t :: 
+            (tap_enclave_metadata_valid_2[e] && tap_enclave_metadata_privileged_2[e]) ==> 
+                (tap_enclave_metadata_owner_map_2[e] == tap_null_enc_id));
+    // valid guarantee
+    invariant tap_enclave_metadata_valid_1[tap_null_enc_id];
+    invariant tap_enclave_metadata_valid_2[tap_null_enc_id];
+    invariant (forall e : tap_enclave_id_t :: special_enclave_id(e) ==> 
+        !tap_enclave_metadata_valid_1[e]);
+    invariant (forall e : tap_enclave_id_t :: special_enclave_id(e) ==> 
+        !tap_enclave_metadata_valid_2[e]);
+
+    // enclave ownermap relationship: valid enclave's parent must be valid
+    invariant (forall e : tap_enclave_id_t :: tap_enclave_metadata_valid_1[e] ==>
+        (tap_enclave_metadata_valid_1[tap_enclave_metadata_owner_map_1[e]]));
+    invariant (forall e : tap_enclave_id_t :: tap_enclave_metadata_valid_2[e] ==>
+        (tap_enclave_metadata_valid_2[tap_enclave_metadata_owner_map_2[e]]));
+
+    // enclave ownermap relationship: special children
+    invariant tap_enclave_metadata_owner_map_1[eid_1] == tap_null_enc_id;
+    invariant tap_enclave_metadata_owner_map_2[eid_2] == tap_null_enc_id;
+    invariant tap_enclave_metadata_owner_map_1[tap_null_enc_id] == tap_null_enc_id;
+    invariant tap_enclave_metadata_owner_map_2[tap_null_enc_id] == tap_null_enc_id;
+    
+    // enclave ownermap relationship: the maximal parent-tree depth is 2 
+    invariant (forall e : tap_enclave_id_t :: (tap_enclave_metadata_valid_1[e]) ==> 
+        (tap_enclave_metadata_owner_map_1[tap_enclave_metadata_owner_map_1[e]] == tap_null_enc_id));
+    invariant (forall e : tap_enclave_id_t :: (tap_enclave_metadata_valid_2[e]) ==> 
+        (tap_enclave_metadata_owner_map_2[tap_enclave_metadata_owner_map_2[e]] == tap_null_enc_id));
+    
+    // if the mode_untrusted is from PE's children enclave, then the 2 traces is in **one** children enclave of this PE.
+    invariant ((tap_enclave_metadata_owner_map_1[cpu_enclave_id_1] == eid_1) ==> 
+        (tap_enclave_metadata_valid_2[cpu_enclave_id_2]));
+    invariant ((tap_enclave_metadata_owner_map_1[cpu_enclave_id_1] == eid_1) ==>
+        (tap_enclave_metadata_owner_map_2[cpu_enclave_id_2] == eid_2));
+    
+    // enclave ownermap relationship: enclave with chidren must be privileged 
+    invariant (forall e : tap_enclave_id_t :: 
+        (tap_enclave_metadata_valid_1[e] && tap_enclave_metadata_owner_map_1[e] != tap_null_enc_id) ==> 
+          (tap_enclave_metadata_privileged_1[tap_enclave_metadata_owner_map_1[e]]));
+    invariant (forall e : tap_enclave_id_t :: 
+        (tap_enclave_metadata_valid_2[e] && tap_enclave_metadata_owner_map_2[e] != tap_null_enc_id) ==> 
+          (tap_enclave_metadata_privileged_2[tap_enclave_metadata_owner_map_2[e]]));
+
+    // pa ownermap wouldn't point to invalid enclave.
     invariant  (forall pa : wap_addr_t, e : tap_enclave_id_t ::
                 (valid_enclave_id(e) && !tap_enclave_metadata_valid_1[e]) ==> 
                     (cpu_owner_map_1[pa] != e));
     invariant  (forall pa : wap_addr_t, e : tap_enclave_id_t ::
                 (valid_enclave_id(e) && !tap_enclave_metadata_valid_2[e]) ==> 
                     (cpu_owner_map_2[pa] != e));
+
+    // extend exclusive memory consistency and structure rules. Apr 14, 2023.
+    invariant (forall e : tap_enclave_id_t, v : vaddr_t :: 
+        (tap_enclave_metadata_valid_1[e] && (tap_enclave_metadata_privileged_1[e] || tap_enclave_metadata_privileged_1[tap_enclave_metadata_owner_map_1[e]]) ==> 
+            (tap_enclave_metadata_addr_excl_1[e][v] <==> cpu_owner_map_1[tap_enclave_metadata_addr_map_1[e][v]] == e)));
+    invariant (forall e : tap_enclave_id_t, v : vaddr_t :: 
+        (tap_enclave_metadata_valid_2[e] && (tap_enclave_metadata_privileged_2[e] || tap_enclave_metadata_privileged_2[tap_enclave_metadata_owner_map_2[e]]) ==> 
+            (tap_enclave_metadata_addr_excl_2[e][v] <==> cpu_owner_map_2[tap_enclave_metadata_addr_map_2[e][v]] == e)));
+    invariant (forall v : vaddr_t :: 
+        ((tap_enclave_metadata_privileged_1[cpu_enclave_id_1] || tap_enclave_metadata_privileged_1[tap_enclave_metadata_owner_map_1[cpu_enclave_id_1]])) ==> 
+            (tap_enclave_metadata_addr_excl_1[cpu_enclave_id_1][v] <==> cpu_owner_map_1[cpu_addr_map_1[v]] == cpu_enclave_id_1));
+    invariant (forall v : vaddr_t :: 
+        ((tap_enclave_metadata_privileged_2[cpu_enclave_id_2] || tap_enclave_metadata_privileged_2[tap_enclave_metadata_owner_map_2[cpu_enclave_id_2]])) ==> 
+            (tap_enclave_metadata_addr_excl_2[cpu_enclave_id_2][v] <==> cpu_owner_map_2[cpu_addr_map_2[v]] == cpu_enclave_id_2));
+
     // eid is valid.
     invariant (valid_enclave_id(eid_1) && valid_enclave_id(eid_2));
     invariant (tap_enclave_metadata_valid_1[eid_1] && tap_enclave_metadata_valid_2[eid_2]);
@@ -625,8 +1010,33 @@ procedure measurement_proof_part2
     //----------------------------------------------------------------------//
     // invariants about the states of the CPUs.                             //
     //----------------------------------------------------------------------//
-    invariant (current_mode == mode_untrusted) ==>
-                (cpu_enclave_id_1 == tap_null_enc_id && cpu_enclave_id_2 == tap_null_enc_id);
+
+    // invariants about state sync between 2 traces.
+    // These properties may need extension/modification for multiple PE environment.
+    // OS/NE sync. (stronger than Integrity's)
+    invariant (current_mode == mode_untrusted) ==> 
+                  (cpu_enclave_id_1 == cpu_enclave_id_2);
+    invariant (current_mode == mode_untrusted) ==> 
+                  (cpu_enclave_id_1 == tap_null_enc_id) || 
+                  (tap_enclave_metadata_owner_map_1[cpu_enclave_id_1] == eid_1);
+    // PE sync. the PE's structure must be same.
+    invariant (forall e : tap_enclave_id_t :: 
+        (tap_enclave_metadata_valid_1[e] && tap_enclave_metadata_owner_map_1[e] == eid_1) <==> 
+            (tap_enclave_metadata_valid_2[e] && tap_enclave_metadata_owner_map_2[e] == eid_2));
+
+    // PE sync. the two (PE) enclave's children pause state must be same. 
+    // Apr 4, 2023.
+    // invariant (!enclave_dead_1 && !enclave_dead_2) ==>
+    //             (forall e : tap_enclave_id_t :: 
+    //                 (tap_enclave_metadata_valid_1[e] && tap_enclave_metadata_owner_map_1[e] == eid_1) ==> 
+    //                     tap_enclave_metadata_paused_1[e] == tap_enclave_metadata_paused_2[e]);
+    invariant (forall e : tap_enclave_id_t :: 
+                    (tap_enclave_metadata_valid_1[e] && tap_enclave_metadata_owner_map_1[e] == eid_1) ==> 
+                        tap_enclave_metadata_paused_1[e] == tap_enclave_metadata_paused_2[e]);
+
+    invariant (current_mode == mode_untrusted) ==> tap_enclave_metadata_valid_1[cpu_enclave_id_1];
+    invariant (current_mode == mode_untrusted) ==> tap_enclave_metadata_valid_2[cpu_enclave_id_2];
+
     invariant (current_mode == mode_enclave) ==> 
                 (cpu_enclave_id_1 == eid_1 && cpu_enclave_id_2 == eid_2);
     invariant (current_mode == mode_enclave) ==>
@@ -682,29 +1092,37 @@ procedure measurement_proof_part2
                     (tap_enclave_metadata_addr_map_2[eid_2] == cpu_addr_map_2);
     invariant (current_mode == mode_enclave || current_mode == mode_untrusted);
   {
-    havoc proof_op;
-    havoc regs;
+    havoc r_eid, proof_op, r_regs;
     if (current_mode == mode_untrusted) {
-      assume (is_measurement_untrusted_op(proof_op));
-      assume (proof_op != tap_proof_op_resume);
+
+      assume is_measurement_untrusted_op(proof_op);
       call RestoreContext_1();
-      call status_1, current_mode_1 := MeasurementUntrustedOp(proof_op, eid_1, regs);
+      call status_1, current_mode_1 := MeasurementUntrustedOp(current_mode, proof_op, eid_1, r_regs);
       call SaveContext_1();
 
       call RestoreContext_2();
-      call status_2, current_mode_2 := MeasurementUntrustedOp(proof_op, eid_2, regs);
+      call status_2, current_mode_2 := MeasurementUntrustedOp(current_mode, proof_op, eid_2, r_regs);
       call SaveContext_2();
+
+      assert status_1 == status_2;
+      assert current_mode_1 == current_mode_2;
+
     } else if (current_mode == mode_enclave) {
-      havoc iter;
 
-      assume (is_measurement_enclave_op(proof_op));
-      assume (proof_op != tap_proof_op_pause);
+      havoc iter;
+      if (e_privileged_1) {
+        assume is_measurement_privilege_op(proof_op);
+      } else {
+        assume is_measurement_enclave_op(proof_op);
+      }
+      assume r_eid != eid_1 && r_eid != eid_2;
+      
       call RestoreContext_1();
-      call status_1, current_mode_1, vaddr_1, word_1 := MeasurementEnclaveOp(proof_op, iter);
+      call status_1, current_mode_1, vaddr_1, word_1 := MeasurementEnclaveOp(current_mode, r_eid, proof_op, iter);
       call SaveContext_1();
 
       call RestoreContext_2();
-      call status_2, current_mode_2, vaddr_2, word_2 := MeasurementEnclaveOp(proof_op, iter);
+      call status_2, current_mode_2, vaddr_2, word_2 := MeasurementEnclaveOp(current_mode, r_eid, proof_op, iter);
       call SaveContext_2();
 
       assert vaddr_1 == vaddr_2;
@@ -725,10 +1143,6 @@ procedure measurement_proof()
   modifies cache_valid_map, cache_tag_map;
   modifies cache_valid_map_1, cache_tag_map_1;
   modifies cache_valid_map_2, cache_tag_map_2;
-  modifies untrusted_addr_valid;
-  modifies untrusted_addr_map;
-  modifies untrusted_regs;
-  modifies untrusted_pc;
   modifies tap_enclave_metadata_valid;
   modifies tap_enclave_metadata_addr_map;
   modifies tap_enclave_metadata_addr_valid;
@@ -738,6 +1152,8 @@ procedure measurement_proof()
   modifies tap_enclave_metadata_regs;
   modifies tap_enclave_metadata_paused;
   modifies tap_enclave_metadata_cache_conflict;
+  modifies tap_enclave_metadata_privileged;
+  modifies tap_enclave_metadata_owner_map;
   modifies cpu_mem_1;
   modifies cpu_regs_1;
   modifies cpu_pc_1;
@@ -745,10 +1161,6 @@ procedure measurement_proof()
   modifies cpu_addr_valid_1;
   modifies cpu_addr_map_1;
   modifies cpu_owner_map_1;
-  modifies untrusted_addr_valid_1;
-  modifies untrusted_addr_map_1;
-  modifies untrusted_regs_1;
-  modifies untrusted_pc_1;
   modifies tap_enclave_metadata_valid_1;
   modifies tap_enclave_metadata_addr_map_1;
   modifies tap_enclave_metadata_addr_valid_1;
@@ -758,6 +1170,8 @@ procedure measurement_proof()
   modifies tap_enclave_metadata_regs_1;
   modifies tap_enclave_metadata_paused_1;
   modifies tap_enclave_metadata_cache_conflict_1;
+  modifies tap_enclave_metadata_privileged_1;
+  modifies tap_enclave_metadata_owner_map_1;
   modifies cpu_mem_2;
   modifies cpu_regs_2;
   modifies cpu_pc_2;
@@ -765,10 +1179,6 @@ procedure measurement_proof()
   modifies cpu_addr_valid_2;
   modifies cpu_addr_map_2;
   modifies cpu_owner_map_2;
-  modifies untrusted_addr_valid_2;
-  modifies untrusted_addr_map_2;
-  modifies untrusted_regs_2;
-  modifies untrusted_pc_2;
   modifies tap_enclave_metadata_valid_2;
   modifies tap_enclave_metadata_addr_map_2;
   modifies tap_enclave_metadata_addr_valid_2;
@@ -778,6 +1188,8 @@ procedure measurement_proof()
   modifies tap_enclave_metadata_regs_2;
   modifies tap_enclave_metadata_paused_2;
   modifies tap_enclave_metadata_cache_conflict_2;
+  modifies tap_enclave_metadata_privileged_2;
+  modifies tap_enclave_metadata_owner_map_2;
 {
   var eid_1, eid_2                   : tap_enclave_id_t;
   var e_addr_valid_1, e_addr_valid_2 : addr_valid_t;
@@ -785,20 +1197,25 @@ procedure measurement_proof()
   var e_excl_map_1, e_excl_map_2     : excl_map_t;
   var e_excl_vaddr_1, e_excl_vaddr_2 : excl_vaddr_t;
   var e_entrypoint_1, e_entrypoint_2 : vaddr_t;
+  var e_privileged_1, e_privileged_2 : bool;
   var current_mode                   : mode_t;
 
+  // proof stage 1.
   call eid_1, eid_2,
        e_addr_valid_1, e_addr_valid_2,
        e_addr_map_1, e_addr_map_2, 
        e_excl_vaddr_1, e_excl_vaddr_2,
        e_excl_map_1, e_excl_map_2,
        e_entrypoint_1, e_entrypoint_2,
+       e_privileged_1, e_privileged_2,
        current_mode                     := measurement_proof_part1();
+  // proof stage 2.
   call measurement_proof_part2(
          eid_1, eid_2,
          e_addr_valid_1, e_addr_valid_2,
          e_addr_map_1, e_addr_map_2,
          e_excl_vaddr_1, e_excl_vaddr_2,
          e_excl_map_1, e_excl_map_2,
-         e_entrypoint_1, e_entrypoint_2);
+         e_entrypoint_1, e_entrypoint_2,
+         e_privileged_1, e_privileged_2);
 }
diff --git a/AbstractPlatform/MemConfidentialityProof.bpl b/AbstractPlatform/MemConfidentialityProof.bpl
old mode 100644
new mode 100755
index c84d579..40813f8
--- a/AbstractPlatform/MemConfidentialityProof.bpl
+++ b/AbstractPlatform/MemConfidentialityProof.bpl
@@ -12,10 +12,6 @@ procedure ProveConfidentialityMem(
     modifies cache_valid_map, cache_tag_map;
     modifies cache_valid_map_1, cache_tag_map_1;
     modifies cache_valid_map_2, cache_tag_map_2;
-    modifies untrusted_addr_valid;
-    modifies untrusted_addr_map;
-    modifies untrusted_regs;
-    modifies untrusted_pc;
     modifies tap_enclave_metadata_valid;
     modifies tap_enclave_metadata_addr_map;
     modifies tap_enclave_metadata_addr_valid;
@@ -25,6 +21,8 @@ procedure ProveConfidentialityMem(
     modifies tap_enclave_metadata_regs;
     modifies tap_enclave_metadata_paused;
     modifies tap_enclave_metadata_cache_conflict;
+    modifies tap_enclave_metadata_privileged;
+    modifies tap_enclave_metadata_owner_map;
     modifies cpu_mem_1;
     modifies cpu_regs_1;
     modifies cpu_pc_1;
@@ -32,10 +30,6 @@ procedure ProveConfidentialityMem(
     modifies cpu_addr_valid_1;
     modifies cpu_addr_map_1;
     modifies cpu_owner_map_1;
-    modifies untrusted_addr_valid_1;
-    modifies untrusted_addr_map_1;
-    modifies untrusted_regs_1;
-    modifies untrusted_pc_1;
     modifies tap_enclave_metadata_valid_1;
     modifies tap_enclave_metadata_addr_map_1;
     modifies tap_enclave_metadata_addr_valid_1;
@@ -45,6 +39,8 @@ procedure ProveConfidentialityMem(
     modifies tap_enclave_metadata_regs_1;
     modifies tap_enclave_metadata_paused_1;
     modifies tap_enclave_metadata_cache_conflict_1;
+    modifies tap_enclave_metadata_privileged_1;
+    modifies tap_enclave_metadata_owner_map_1;
     modifies cpu_mem_2;
     modifies cpu_regs_2;
     modifies cpu_pc_2;
@@ -52,10 +48,6 @@ procedure ProveConfidentialityMem(
     modifies cpu_addr_valid_2;
     modifies cpu_addr_map_2;
     modifies cpu_owner_map_2;
-    modifies untrusted_addr_valid_2;
-    modifies untrusted_addr_map_2;
-    modifies untrusted_regs_2;
-    modifies untrusted_pc_2;
     modifies tap_enclave_metadata_valid_2;
     modifies tap_enclave_metadata_addr_map_2;
     modifies tap_enclave_metadata_addr_valid_2;
@@ -65,6 +57,8 @@ procedure ProveConfidentialityMem(
     modifies tap_enclave_metadata_regs_2;
     modifies tap_enclave_metadata_paused_2;
     modifies tap_enclave_metadata_cache_conflict_2;
+    modifies tap_enclave_metadata_privileged_2;
+    modifies tap_enclave_metadata_owner_map_2;
 {
     var eid, r_eid                                   : tap_enclave_id_t;
     var status, status_1, status_2                   : enclave_op_result_t;
@@ -74,6 +68,7 @@ procedure ProveConfidentialityMem(
     var e_excl_map                                   : excl_map_t;
     var e_container_data_1, e_container_data_2       : container_data_t;
     var e_entrypoint_1, e_entrypoint_2               : vaddr_t;
+    var e_privileged                                 : bool;
     var current_mode, current_mode_1, current_mode_2 : mode_t;
     var enclave_dead, enclave_dead_1, enclave_dead_2 : bool;
     var observation_1, observation_2                 : word_t;
@@ -91,8 +86,10 @@ procedure ProveConfidentialityMem(
     var r_container_valid                            : container_valid_t;
     var r_container_data                             : container_data_t;
     var r_entrypoint                                 : vaddr_t;
+    var r_privileged                                 : bool;
     var r_l_way, r_s_way                             : cache_way_index_t;
     var r_pc                                         : vaddr_t;
+    var r_regs                                       : regs_t;
     var r_read                                       : regindex_t;
     var r_write                                      : regindex_t;
     var r_data                                       : word_t;
@@ -108,14 +105,14 @@ procedure ProveConfidentialityMem(
     var l_way, s_way                                 : cache_way_index_t;
 
     // initial state.
-    call current_mode := InitialHavoc();
+    call current_mode := InitialHavoc(eid);
     assert tap_addr_perm_x(cpu_addr_valid[cpu_pc]);
     assert cpu_owner_map[cpu_addr_map[cpu_pc]] == cpu_enclave_id;
     assert cpu_enclave_id == tap_null_enc_id;
     // initialize the untrusted (OS) state with sane values.
-    untrusted_addr_valid := cpu_addr_valid;
-    untrusted_addr_map := cpu_addr_map;
-    untrusted_pc := cpu_pc;
+    tap_enclave_metadata_addr_valid[tap_null_enc_id] := cpu_addr_valid;
+    tap_enclave_metadata_addr_map[tap_null_enc_id] := cpu_addr_map;
+    tap_enclave_metadata_pc[tap_null_enc_id] := cpu_pc;
 
     // create two copies of state.
     call SaveContext_1();
@@ -127,7 +124,7 @@ procedure ProveConfidentialityMem(
     call RestoreContext_1();
     call InitOSMem(e_excl_map, e_container_data_1);
     call status := launch(eid, e_addr_valid_1, e_addr_map_1, 
-                          e_excl_vaddr_1, e_excl_map, e_entrypoint_1);
+                          e_excl_vaddr_1, e_excl_map, e_entrypoint_1, e_privileged);
     assume tap_enclave_metadata_cache_conflict[eid] == cache_conflict;
     assume status == enclave_op_success;
     call SaveContext_1();
@@ -135,7 +132,7 @@ procedure ProveConfidentialityMem(
     call RestoreContext_2();
     call InitOSMem(e_excl_map, e_container_data_2);
     call status := launch(eid, e_addr_valid_2, e_addr_map_2, 
-                          e_excl_vaddr_2, e_excl_map, e_entrypoint_2);
+                          e_excl_vaddr_2, e_excl_map, e_entrypoint_2, e_privileged);
     assume status == enclave_op_success;
     assume tap_enclave_metadata_cache_conflict[eid] == cache_conflict;
     call SaveContext_2();
@@ -148,10 +145,77 @@ procedure ProveConfidentialityMem(
     observation_2 := k0_word_t;
 
     current_mode := mode_untrusted;
-    while (!enclave_dead)
-        //// The property ////
+    current_mode_1 := current_mode;
+    current_mode_2 := current_mode;
+
+    while (*)
+        // M adversary: unconditionally
         invariant (observation_1 == observation_2);
         //// General invariants /////
+        invariant !tap_enclave_metadata_privileged_1[tap_null_enc_id];
+        invariant !tap_enclave_metadata_privileged_2[tap_null_enc_id];
+        invariant tap_enclave_metadata_privileged_1[eid] == e_privileged;
+        invariant tap_enclave_metadata_privileged_2[eid] == e_privileged;
+
+        //  Apr 19, 2023
+        //  privileged relationship: multiple PE
+        invariant (forall e : tap_enclave_id_t :: 
+                (tap_enclave_metadata_valid_1[e] && tap_enclave_metadata_privileged_1[e]) ==> 
+                        (tap_enclave_metadata_owner_map_1[e] == tap_null_enc_id));
+        invariant (forall e : tap_enclave_id_t :: 
+                (tap_enclave_metadata_valid_2[e] && tap_enclave_metadata_privileged_2[e]) ==> 
+                        (tap_enclave_metadata_owner_map_2[e] == tap_null_enc_id));
+
+        // valid guarantee
+        invariant tap_enclave_metadata_valid_1[tap_null_enc_id];
+        invariant tap_enclave_metadata_valid_2[tap_null_enc_id];
+        invariant (forall e : tap_enclave_id_t :: 
+                    special_enclave_id(e) ==> !tap_enclave_metadata_valid_1[e]);
+        invariant (forall e: tap_enclave_id_t :: 
+                    special_enclave_id(e) ==> !tap_enclave_metadata_valid_2[e]);
+
+        // enclave ownermap relationship: valid enclave's parent must be valid
+        invariant (forall e : tap_enclave_id_t :: tap_enclave_metadata_valid_1[e] ==>
+                    (tap_enclave_metadata_valid_1[tap_enclave_metadata_owner_map_1[e]]));
+        invariant (forall e : tap_enclave_id_t :: tap_enclave_metadata_valid_2[e] ==> 
+                    (tap_enclave_metadata_valid_2[tap_enclave_metadata_owner_map_2[e]]));
+
+        // enclave ownermap relationship: special children
+        invariant tap_enclave_metadata_owner_map_1[eid] == tap_null_enc_id;
+        invariant tap_enclave_metadata_owner_map_2[eid] == tap_null_enc_id;
+        invariant tap_enclave_metadata_owner_map_1[tap_null_enc_id] == tap_null_enc_id;
+        invariant tap_enclave_metadata_owner_map_2[tap_null_enc_id] == tap_null_enc_id;
+
+        // enclave ownermap relationship: the maximal parent-tree depth is 2 
+        invariant (forall e : tap_enclave_id_t :: (tap_enclave_metadata_valid_1[e]) ==> 
+                    (tap_enclave_metadata_owner_map_1[tap_enclave_metadata_owner_map_1[e]] == tap_null_enc_id));
+        invariant (forall e : tap_enclave_id_t :: (tap_enclave_metadata_valid_2[e]) ==> 
+                    (tap_enclave_metadata_owner_map_2[tap_enclave_metadata_owner_map_2[e]] == tap_null_enc_id));
+
+        // enclave ownermap relationship: enclave with chidren must be privileged 
+        invariant (forall e : tap_enclave_id_t :: 
+                    (tap_enclave_metadata_valid_1[e] && tap_enclave_metadata_owner_map_1[e] != tap_null_enc_id) ==> 
+                        (tap_enclave_metadata_privileged_1[tap_enclave_metadata_owner_map_1[e]]));
+        invariant (forall e : tap_enclave_id_t :: 
+                    (tap_enclave_metadata_valid_2[e] && tap_enclave_metadata_owner_map_2[e] != tap_null_enc_id) ==> 
+                        (tap_enclave_metadata_privileged_2[tap_enclave_metadata_owner_map_2[e]]));
+        
+        // extend the exclusive-memory consistency to PE and NE children.
+        // 1.   constrain this consistency to PE-controlled enclave.
+        invariant (forall e : tap_enclave_id_t, v : vaddr_t :: 
+                    (tap_enclave_metadata_valid_1[e] && (tap_enclave_metadata_privileged_1[e] || tap_enclave_metadata_privileged_1[tap_enclave_metadata_owner_map_1[e]]) ==> 
+                        (tap_enclave_metadata_addr_excl_1[e][v] <==> cpu_owner_map_1[tap_enclave_metadata_addr_map_1[e][v]] == e)));
+        invariant (forall e : tap_enclave_id_t, v : vaddr_t :: 
+                    (tap_enclave_metadata_valid_2[e] && (tap_enclave_metadata_privileged_2[e] || tap_enclave_metadata_privileged_2[tap_enclave_metadata_owner_map_2[e]]) ==> 
+                        (tap_enclave_metadata_addr_excl_2[e][v] <==> cpu_owner_map_2[tap_enclave_metadata_addr_map_2[e][v]] == e)));
+        // 2.   constraint this consistency to PE.
+        invariant (forall v : vaddr_t :: 
+                    (tap_enclave_metadata_privileged_1[cpu_enclave_id_1] || tap_enclave_metadata_privileged_1[tap_enclave_metadata_owner_map_1[cpu_enclave_id_1]]) ==> 
+                        (tap_enclave_metadata_addr_excl_1[cpu_enclave_id_1][v] <==> cpu_owner_map_1[cpu_addr_map_1[v]] == cpu_enclave_id_1));
+        invariant (forall v : vaddr_t :: 
+                    (tap_enclave_metadata_privileged_2[cpu_enclave_id_2] || tap_enclave_metadata_privileged_2[tap_enclave_metadata_owner_map_2[cpu_enclave_id_2]]) ==> 
+                        (tap_enclave_metadata_addr_excl_2[cpu_enclave_id_2][v] <==> cpu_owner_map_2[cpu_addr_map_2[v]] == cpu_enclave_id_2));
+        
         invariant current_mode == mode_untrusted || current_mode == mode_enclave;
         // memory is not assigned to an enclave that doesn't exist.
         invariant (forall pa : wap_addr_t, e : tap_enclave_id_t ::
@@ -163,12 +227,8 @@ procedure ProveConfidentialityMem(
         //-------------------------------------------------------------------//
         // CPU mode and CPU enclave ID must be consistent.
         //-------------------------------------------------------------------//
-        invariant (forall e : tap_enclave_id_t :: 
-                    !valid_enclave_id(e) ==> !tap_enclave_metadata_valid_1[tap_null_enc_id]);
-        invariant (forall e : tap_enclave_id_t ::
-                    !valid_enclave_id(e) ==> !tap_enclave_metadata_valid_2[tap_null_enc_id]);
-        invariant (current_mode == mode_untrusted) ==> cpu_enclave_id_1 != eid;
-        invariant (current_mode == mode_untrusted) ==> cpu_enclave_id_2 != eid;
+        invariant (current_mode == mode_untrusted) ==> (cpu_enclave_id_1 != eid);
+        invariant (current_mode == mode_untrusted) ==> (cpu_enclave_id_2 != eid);
         invariant (current_mode == mode_enclave) ==> (cpu_enclave_id_1 == eid);
         invariant (current_mode == mode_enclave) ==> (cpu_enclave_id_2 == eid);
         //-------------------------------------------------------------------//
@@ -177,30 +237,28 @@ procedure ProveConfidentialityMem(
         invariant (valid_enclave_id(eid));
         invariant (cpu_enclave_id_1 != tap_blocked_enc_id);
         invariant (cpu_enclave_id_2 != tap_blocked_enc_id);
-        invariant (!enclave_dead ==> tap_enclave_metadata_valid_1[eid]);
-        invariant (!enclave_dead ==> tap_enclave_metadata_valid_2[eid]);
+        invariant (tap_enclave_metadata_valid_1[eid]);
+        invariant (tap_enclave_metadata_valid_2[eid]);
         // maintain invariants about excl_vaddr.
-        invariant (!enclave_dead) ==>
-                        (tap_enclave_metadata_addr_excl_1[eid] == e_excl_vaddr_1);
-        invariant (!enclave_dead) ==>
-                        (tap_enclave_metadata_addr_excl_2[eid] == e_excl_vaddr_2);
+        invariant tap_enclave_metadata_addr_excl_1[eid] == e_excl_vaddr_1;
+        invariant tap_enclave_metadata_addr_excl_2[eid] == e_excl_vaddr_2;
         // invariants about addr_map
         invariant (forall v : vaddr_t ::
-                      (!enclave_dead && e_excl_vaddr_1[v]) ==>
-                          (tap_enclave_metadata_addr_map_1[eid][v] == e_addr_map_1[v]));
+                      e_excl_vaddr_1[v] ==>
+                          tap_enclave_metadata_addr_map_1[eid][v] == e_addr_map_1[v]);
         invariant (forall v : vaddr_t ::
-                      (!enclave_dead && e_excl_vaddr_2[v]) ==>
-                          (tap_enclave_metadata_addr_map_2[eid][v] == e_addr_map_2[v]));
+                      e_excl_vaddr_2[v] ==>
+                          tap_enclave_metadata_addr_map_2[eid][v] == e_addr_map_2[v]);
         // invariants about e_excl_addr
         invariant (forall p : wap_addr_t :: 
-                    (!enclave_dead) ==> ((cpu_owner_map_1[p] == eid) <==> e_excl_map[p]));
+                    (cpu_owner_map_1[p] == eid) <==> e_excl_map[p]);
         invariant (forall p : wap_addr_t :: 
-                    (!enclave_dead) ==> ((cpu_owner_map_2[p] == eid) <==> e_excl_map[p]));
+                    (cpu_owner_map_2[p] == eid) <==> e_excl_map[p]);
         invariant (forall v : vaddr_t, p : wap_addr_t :: 
-                        (!enclave_dead && e_excl_vaddr_1[v] && p == e_addr_map_1[v])
+                        (e_excl_vaddr_1[v] && p == e_addr_map_1[v])
                             ==> e_excl_map[p]);
         invariant (forall v : vaddr_t, p : wap_addr_t :: 
-                        (!enclave_dead && e_excl_vaddr_2[v] && p == e_addr_map_2[v])
+                        (e_excl_vaddr_2[v] && p == e_addr_map_2[v])
                             ==> e_excl_map[p]);
         //-------------------------------------------------------------------//
         // Now deal with the enclaves.
@@ -214,6 +272,7 @@ procedure ProveConfidentialityMem(
         //-------------------------------------------------------------------//
         // CPU state is the same                                             //
         //-------------------------------------------------------------------//
+        invariant (current_mode_1 == current_mode_2);
         // same PC.
         invariant (current_mode == mode_untrusted) ==> (cpu_pc_1 == cpu_pc_2);
         // same mode of operation.
@@ -221,30 +280,48 @@ procedure ProveConfidentialityMem(
         // same regs.
         invariant (current_mode == mode_untrusted) ==> (cpu_regs_1 == cpu_regs_2);
         // same va->pa.
-        invariant (current_mode == mode_untrusted) ==> 
-                    (cpu_addr_valid_1 == cpu_addr_valid_2);
-        invariant (current_mode == mode_untrusted) ==> 
-                    (cpu_addr_map_1 == cpu_addr_map_2);
+        invariant (current_mode == mode_untrusted) ==> (cpu_addr_valid_1 == cpu_addr_valid_2);
+        invariant (current_mode == mode_untrusted) ==> (cpu_addr_map_1 == cpu_addr_map_2);
         // owner map is the same.
         invariant (forall pa : wap_addr_t :: (cpu_owner_map_1[pa] == cpu_owner_map_2[pa]));
         // memory is the same except for the enclave memory.
         invariant (forall pa : wap_addr_t :: !e_excl_map[pa] ==> (cpu_mem_1[pa] == cpu_mem_2[pa]));
+
+        invariant (current_mode == mode_untrusted) ==> (tap_enclave_metadata_valid_1[cpu_enclave_id_1]);
+        invariant (current_mode == mode_untrusted) ==> (tap_enclave_metadata_valid_2[cpu_enclave_id_2]);
+
+        invariant (tap_enclave_metadata_valid_1[eid] && tap_enclave_metadata_valid_2[eid]);
         //-------------------------------------------------------------------//
         // OS state is the same                                              //
         //-------------------------------------------------------------------//
         // OS va->pa 
-        invariant (untrusted_addr_valid_1 == untrusted_addr_valid_2);
-        invariant (untrusted_addr_map_1 == untrusted_addr_map_2);
+        invariant (tap_enclave_metadata_addr_valid_1[tap_null_enc_id] == tap_enclave_metadata_addr_valid_2[tap_null_enc_id]);
+        invariant (tap_enclave_metadata_addr_map_1[tap_null_enc_id] == tap_enclave_metadata_addr_map_2[tap_null_enc_id]);
         // OS regs.
-        invariant (untrusted_regs_1 == untrusted_regs_2);
-        invariant (untrusted_pc_1 == untrusted_pc_2);
+        invariant (tap_enclave_metadata_regs_1[tap_null_enc_id] == tap_enclave_metadata_regs_2[tap_null_enc_id]);
+        invariant (tap_enclave_metadata_pc_1[tap_null_enc_id] == tap_enclave_metadata_pc_2[tap_null_enc_id]);
+        
+        // Stronger: applied for OS and all other NE
+        invariant (forall e : tap_enclave_id_t :: (tap_enclave_metadata_valid[e] && e != eid) ==> 
+            (tap_enclave_metadata_addr_valid_1[e] == tap_enclave_metadata_addr_valid_2[e]));
+        invariant (forall e : tap_enclave_id_t :: (tap_enclave_metadata_valid[e] && e != eid) ==>
+            (tap_enclave_metadata_addr_map_1[e] == tap_enclave_metadata_addr_map_2[e]));
+        invariant (forall e : tap_enclave_id_t :: (tap_enclave_metadata_valid[e] && e != eid) ==> 
+            (tap_enclave_metadata_regs_1[e] == tap_enclave_metadata_regs_2[e]));
+        invariant (forall e : tap_enclave_id_t :: (tap_enclave_metadata_valid[e] && e != eid) ==> 
+            (tap_enclave_metadata_pc_1[e] == tap_enclave_metadata_pc_2[e]));
+
+
         //-------------------------------------------------------------------//
         // Enclave state is the same except for eid (mostly). Some it is the //
         // the same for eid as well (addr_map and addr_excl).                //
         //-------------------------------------------------------------------//
+        
         // valid is the same except for eid.
-        invariant (forall e : tap_enclave_id_t :: (e != eid) ==>
-                    (tap_enclave_metadata_valid_1[e] == tap_enclave_metadata_valid_2[e]));
+        invariant (forall e : tap_enclave_id_t :: (e != eid) ==> 
+            (tap_enclave_metadata_valid_1[e] == tap_enclave_metadata_valid_2[e]));
+
+        
         // addr valid is the same except for eid.
         invariant (forall e : tap_enclave_id_t :: 
                     (tap_enclave_metadata_valid_1[e] && tap_enclave_metadata_valid_2[e] && e != eid) ==>
@@ -273,68 +350,115 @@ procedure ProveConfidentialityMem(
         invariant (forall e : tap_enclave_id_t :: 
                     (tap_enclave_metadata_valid_1[e] && tap_enclave_metadata_valid_2[e]) ==>
                         (tap_enclave_metadata_paused_1[e] == tap_enclave_metadata_paused_2[e]));
+                
+        // invariants about state sync between 2 traces.
+        // OS/NE sync.
+        invariant (current_mode == mode_untrusted) ==> 
+                    (cpu_enclave_id_1 == tap_null_enc_id ==> 
+                        cpu_enclave_id_2 == tap_null_enc_id);
+        invariant (current_mode == mode_untrusted) ==> 
+            ((cpu_enclave_id_1 != tap_null_enc_id && tap_enclave_metadata_owner_map_1[cpu_enclave_id_1] == tap_null_enc_id) ==> 
+                tap_enclave_metadata_owner_map_2[cpu_enclave_id_2] == tap_null_enc_id);
+        // due to Z3 prover's features, we add some trivial claims in the precondition of this claim.
+        invariant (current_mode == mode_untrusted && cpu_enclave_id_1 != tap_null_enc_id && cpu_enclave_id_1 != eid && tap_enclave_metadata_owner_map_1[cpu_enclave_id_1] == eid) ==> 
+            (cpu_enclave_id_1 == cpu_enclave_id_2);
+        
+        // OS/NE & PE sync: stronger.
+        invariant (forall e : tap_enclave_id_t :: 
+            (tap_enclave_metadata_valid_1[e] && tap_enclave_metadata_valid_2[e]) ==> 
+                tap_enclave_metadata_owner_map_1[e] == tap_enclave_metadata_owner_map_2[e]);
+        // In confidentiality, we keep the adversary be same.
+        invariant (forall e: tap_enclave_id_t ::
+            tap_enclave_metadata_privileged_1[e] <==> tap_enclave_metadata_privileged_2[e]);
+        // PE sync. the PE's structure must be same.
+        // invariant (forall e : tap_enclave_id_t :: 
+        //     (tap_enclave_metadata_valid_1[e] && tap_enclave_metadata_owner_map_1[e] == eid) <==> 
+        //         (tap_enclave_metadata_valid_2[e] && tap_enclave_metadata_owner_map_2[e] == eid));
+
+        invariant (forall e : tap_enclave_id_t :: 
+                    (tap_enclave_metadata_valid_1[e] && tap_enclave_metadata_owner_map_1[e] == eid) ==> 
+                        tap_enclave_metadata_paused_1[e] == tap_enclave_metadata_paused_2[e]);
+
     {
-        if (current_mode == mode_untrusted) {
-            havoc r_proof_op, r_eid, r_pc, r_read, r_write, r_data, 
-                  l_vaddr, s_vaddr, s_data, r_pt_eid, r_pt_va, 
-                  pt_eid, pt_vaddr, pt_valid, pt_paddr, r_addr_valid, 
-                  r_addr_map, r_excl_vaddr, r_excl_map, r_bmap,
-                  r_container_valid, r_container_data, r_entrypoint, r_l_way, r_s_way;
+        havoc r_proof_op, r_eid, r_pc, r_regs, r_read, r_write, r_data, 
+                l_vaddr, s_vaddr, s_data, r_pt_eid, r_pt_va, 
+                pt_eid, pt_vaddr, pt_valid, pt_paddr, r_addr_valid, 
+                r_addr_map, r_excl_vaddr, r_excl_map, r_bmap,
+                r_container_valid, r_container_data, r_entrypoint, r_privileged, r_l_way, r_s_way;
 
+        if (current_mode == mode_untrusted) {
+            assume tap_proof_op_valid(r_proof_op);
             assume valid_regindex(r_read);
             assume valid_regindex(r_write);
             assume valid_cache_way_index(r_l_way);
             assume valid_cache_way_index(r_s_way);
+
+            call r_addr_valid, r_addr_map, r_excl_vaddr, r_excl_map, r_entrypoint, r_privileged := LaunchInputHavoc(r_eid);
+
             // trace_1
             call RestoreContext_1();
             call observation_1, current_mode_1, enclave_dead_1, status_1 :=
-                                    ObserverStep(k_mem_observer_t, current_mode, eid, r_eid, r_proof_op, 
+                                    ObserverStep(k_mem_observer_t, current_mode, eid, r_eid, 
+                                                r_addr_valid, r_addr_map, r_excl_vaddr, r_excl_map, r_entrypoint, r_privileged, 
+                                                r_proof_op, 
                                                 r_pc, r_read, r_write, r_data, 
                                                 l_vaddr, s_vaddr, s_data,
                                                 r_pt_eid, r_pt_va,
                                                 pt_eid, pt_vaddr, pt_valid, pt_paddr,
-                                                r_addr_valid, r_addr_map, r_excl_vaddr,
-                                                r_excl_map, r_container_valid, r_container_data,
-                                                r_entrypoint, r_bmap,
+                                                r_container_valid, r_container_data, r_bmap,
                                                 r_l_way, r_s_way);
             call SaveContext_1();
 
             // trace_2
             call RestoreContext_2();
             call observation_2, current_mode_2, enclave_dead_2, status_2 :=
-                                    ObserverStep(k_mem_observer_t, current_mode, eid, r_eid, r_proof_op, 
+                                    ObserverStep(k_mem_observer_t, current_mode, eid, r_eid, 
+                                                r_addr_valid, r_addr_map, r_excl_vaddr, r_excl_map, r_entrypoint, r_privileged, 
+                                                r_proof_op, 
                                                 r_pc, r_read, r_write, r_data, 
                                                 l_vaddr, s_vaddr, s_data,
                                                 r_pt_eid, r_pt_va,
                                                 pt_eid, pt_vaddr, pt_valid, pt_paddr,
-                                                r_addr_valid, r_addr_map, r_excl_vaddr,
-                                                r_excl_map, r_container_valid, r_container_data,
-                                                r_entrypoint, r_bmap,
+                                                r_container_valid, r_container_data, r_bmap,
                                                 r_l_way, r_s_way);
             call SaveContext_2();
 
             // some sanity checks.
             assert status_1 == status_2;
             assert current_mode_1 == current_mode_2;
-            assert enclave_dead_1 == enclave_dead_2;
+            // Considering deprecate enclave dead.
             current_mode := current_mode_1;
-            enclave_dead := enclave_dead_2;
         } else {
             havoc e_proof_op;
-            assume tap_proof_op_valid_in_enclave(e_proof_op);
+            if (e_privileged) {
+                assume tap_proof_op_valid_in_privileged(e_proof_op);
+
+            } else {
+                assume tap_proof_op_valid_in_enclave(e_proof_op);
 
+            }
+
+            call r_addr_valid, r_addr_map, r_excl_vaddr, r_excl_map, r_entrypoint, r_privileged := LaunchInputHavoc(r_eid);
+            // Be opening with the SYNC!
             // trace_1
             call RestoreContext_1();
-            call current_mode_1, load_addr_1, l_way, store_addr_1, store_data_1, s_way := 
-                            EnclaveStep(current_mode, eid, e_proof_op);
+            call current_mode_1, load_addr_1, l_way, store_addr_1, store_data_1, s_way, status_1 := 
+                            EnclaveStep(current_mode, eid, r_eid, 
+                                        r_addr_valid, r_addr_map, r_excl_vaddr, r_excl_map, r_entrypoint, r_privileged, 
+                                        r_container_valid, r_container_data,
+                                        r_regs, e_proof_op);
             call SaveContext_1();
 
             // trace_1
             call RestoreContext_2();
-            call current_mode_2, load_addr_2, l_way, store_addr_2, store_data_2, s_way := 
-                            EnclaveStep(current_mode, eid, e_proof_op);
+            call current_mode_2, load_addr_2, l_way, store_addr_2, store_data_2, s_way, status_2 := 
+                            EnclaveStep(current_mode, eid, r_eid, 
+                                        r_addr_valid, r_addr_map, r_excl_vaddr, r_excl_map, r_entrypoint, r_privileged,
+                                        r_container_valid, r_container_data,
+                                        r_regs, e_proof_op);
             call SaveContext_2();
 
+
             assume (!e_excl_vaddr_1[load_addr_1] || !e_excl_vaddr_2[load_addr_2]) ==>
                    ((load_addr_1 == load_addr_2) && 
                     (cpu_addr_map_1[load_addr_1] == cpu_addr_map_2[load_addr_2]));
diff --git a/AbstractPlatform/PTConfidentialityProof.bpl b/AbstractPlatform/PTConfidentialityProof.bpl
old mode 100644
new mode 100755
index dd358d1..d2c7f63
--- a/AbstractPlatform/PTConfidentialityProof.bpl
+++ b/AbstractPlatform/PTConfidentialityProof.bpl
@@ -12,10 +12,6 @@ procedure ProveConfidentialityPT(
     modifies cache_valid_map, cache_tag_map;
     modifies cache_valid_map_1, cache_tag_map_1;
     modifies cache_valid_map_2, cache_tag_map_2;
-    modifies untrusted_addr_valid;
-    modifies untrusted_addr_map;
-    modifies untrusted_regs;
-    modifies untrusted_pc;
     modifies tap_enclave_metadata_valid;
     modifies tap_enclave_metadata_addr_map;
     modifies tap_enclave_metadata_addr_valid;
@@ -25,6 +21,8 @@ procedure ProveConfidentialityPT(
     modifies tap_enclave_metadata_regs;
     modifies tap_enclave_metadata_paused;
     modifies tap_enclave_metadata_cache_conflict;
+    modifies tap_enclave_metadata_privileged;
+    modifies tap_enclave_metadata_owner_map;
     modifies cpu_mem_1;
     modifies cpu_regs_1;
     modifies cpu_pc_1;
@@ -32,10 +30,6 @@ procedure ProveConfidentialityPT(
     modifies cpu_addr_valid_1;
     modifies cpu_addr_map_1;
     modifies cpu_owner_map_1;
-    modifies untrusted_addr_valid_1;
-    modifies untrusted_addr_map_1;
-    modifies untrusted_regs_1;
-    modifies untrusted_pc_1;
     modifies tap_enclave_metadata_valid_1;
     modifies tap_enclave_metadata_addr_map_1;
     modifies tap_enclave_metadata_addr_valid_1;
@@ -45,6 +39,8 @@ procedure ProveConfidentialityPT(
     modifies tap_enclave_metadata_regs_1;
     modifies tap_enclave_metadata_paused_1;
     modifies tap_enclave_metadata_cache_conflict_1;
+    modifies tap_enclave_metadata_privileged_1;
+    modifies tap_enclave_metadata_owner_map_1;
     modifies cpu_mem_2;
     modifies cpu_regs_2;
     modifies cpu_pc_2;
@@ -52,10 +48,6 @@ procedure ProveConfidentialityPT(
     modifies cpu_addr_valid_2;
     modifies cpu_addr_map_2;
     modifies cpu_owner_map_2;
-    modifies untrusted_addr_valid_2;
-    modifies untrusted_addr_map_2;
-    modifies untrusted_regs_2;
-    modifies untrusted_pc_2;
     modifies tap_enclave_metadata_valid_2;
     modifies tap_enclave_metadata_addr_map_2;
     modifies tap_enclave_metadata_addr_valid_2;
@@ -65,6 +57,8 @@ procedure ProveConfidentialityPT(
     modifies tap_enclave_metadata_regs_2;
     modifies tap_enclave_metadata_paused_2;
     modifies tap_enclave_metadata_cache_conflict_2;
+    modifies tap_enclave_metadata_privileged_2;
+    modifies tap_enclave_metadata_owner_map_2;
 {
     var eid, r_eid                                   : tap_enclave_id_t;
     var status, status_1, status_2                   : enclave_op_result_t;
@@ -74,6 +68,7 @@ procedure ProveConfidentialityPT(
     var e_excl_map                                   : excl_map_t;
     var e_container_data_1, e_container_data_2       : container_data_t;
     var e_entrypoint_1, e_entrypoint_2               : vaddr_t;
+    var e_privileged                                 : bool;
     var current_mode, current_mode_1, current_mode_2 : mode_t;
     var enclave_dead, enclave_dead_1, enclave_dead_2 : bool;
     var observation_1, observation_2                 : word_t;
@@ -91,7 +86,10 @@ procedure ProveConfidentialityPT(
     var r_container_valid                            : container_valid_t;
     var r_container_data                             : container_data_t;
     var r_entrypoint                                 : vaddr_t;
+    var r_privileged                                 : bool;
+
     var r_pc                                         : vaddr_t;
+    var r_regs                                       : regs_t;
     var r_read                                       : regindex_t;
     var r_write                                      : regindex_t;
     var r_data                                       : word_t;
@@ -110,14 +108,14 @@ procedure ProveConfidentialityPT(
     assume (!obs_pt_ev_read ==> block_os_ev_read);
 
     // initial state.
-    call current_mode := InitialHavoc();
+    call current_mode := InitialHavoc(eid);
     assert tap_addr_perm_x(cpu_addr_valid[cpu_pc]);
     assert cpu_owner_map[cpu_addr_map[cpu_pc]] == cpu_enclave_id;
     assert cpu_enclave_id == tap_null_enc_id;
     // initialize the untrusted (OS) state with sane values.
-    untrusted_addr_valid := cpu_addr_valid;
-    untrusted_addr_map := cpu_addr_map;
-    untrusted_pc := cpu_pc;
+    tap_enclave_metadata_addr_valid[tap_null_enc_id] := cpu_addr_valid;
+    tap_enclave_metadata_addr_map[tap_null_enc_id] := cpu_addr_map;
+    tap_enclave_metadata_pc[tap_null_enc_id] := cpu_pc;
 
     // create two copies of state.
     call SaveContext_1();
@@ -129,7 +127,7 @@ procedure ProveConfidentialityPT(
     call RestoreContext_1();
     call InitOSMem(e_excl_map, e_container_data_1);
     call status := launch(eid, e_addr_valid_1, e_addr_map_1, 
-                          e_excl_vaddr, e_excl_map, e_entrypoint_1);
+                          e_excl_vaddr, e_excl_map, e_entrypoint_1, e_privileged);
     assume tap_enclave_metadata_cache_conflict[eid] == cache_conflict;
     assume status == enclave_op_success;
     call SaveContext_1();
@@ -137,7 +135,7 @@ procedure ProveConfidentialityPT(
     call RestoreContext_2();
     call InitOSMem(e_excl_map, e_container_data_2);
     call status := launch(eid, e_addr_valid_2, e_addr_map_2, 
-                          e_excl_vaddr, e_excl_map, e_entrypoint_2);
+                          e_excl_vaddr, e_excl_map, e_entrypoint_2, e_privileged);
     assume status == enclave_op_success;
     assume tap_enclave_metadata_cache_conflict[eid] == cache_conflict;
     call SaveContext_2();
@@ -157,10 +155,77 @@ procedure ProveConfidentialityPT(
     observation_2 := k0_word_t;
 
     current_mode := mode_untrusted;
-    while (!enclave_dead)
-        //// The property ////
+    current_mode_1 := current_mode;
+    current_mode_2 := current_mode;
+
+    while (*)
+        //// MC adversary ////
         invariant (!obs_pt_ev_read) ==> (observation_1 == observation_2);
         //// General invariants /////
+        invariant !tap_enclave_metadata_privileged_1[tap_null_enc_id];
+        invariant !tap_enclave_metadata_privileged_2[tap_null_enc_id];
+        invariant tap_enclave_metadata_privileged_1[eid] == e_privileged;
+        invariant tap_enclave_metadata_privileged_2[eid] == e_privileged;
+
+        //  Apr 19, 2023
+        //  privileged relationship: multiple PE
+        invariant (forall e : tap_enclave_id_t :: 
+                (tap_enclave_metadata_valid_1[e] && tap_enclave_metadata_privileged_1[e]) ==> 
+                        (tap_enclave_metadata_owner_map_1[e] == tap_null_enc_id));
+        invariant (forall e : tap_enclave_id_t :: 
+                (tap_enclave_metadata_valid_2[e] && tap_enclave_metadata_privileged_2[e]) ==> 
+                        (tap_enclave_metadata_owner_map_2[e] == tap_null_enc_id));
+
+        // valid guarantee
+        invariant tap_enclave_metadata_valid_1[tap_null_enc_id];
+        invariant tap_enclave_metadata_valid_2[tap_null_enc_id];
+        invariant (forall e : tap_enclave_id_t :: 
+                    special_enclave_id(e) ==> !tap_enclave_metadata_valid_1[e]);
+        invariant (forall e: tap_enclave_id_t :: 
+                    special_enclave_id(e) ==> !tap_enclave_metadata_valid_2[e]);
+
+        // enclave ownermap relationship: valid enclave's parent must be valid
+        invariant (forall e : tap_enclave_id_t :: tap_enclave_metadata_valid_1[e] ==>
+                    (tap_enclave_metadata_valid_1[tap_enclave_metadata_owner_map_1[e]]));
+        invariant (forall e : tap_enclave_id_t :: tap_enclave_metadata_valid_2[e] ==> 
+                    (tap_enclave_metadata_valid_2[tap_enclave_metadata_owner_map_2[e]]));
+
+        // enclave ownermap relationship: special children
+        invariant tap_enclave_metadata_owner_map_1[eid] == tap_null_enc_id;
+        invariant tap_enclave_metadata_owner_map_2[eid] == tap_null_enc_id;
+        invariant tap_enclave_metadata_owner_map_1[tap_null_enc_id] == tap_null_enc_id;
+        invariant tap_enclave_metadata_owner_map_2[tap_null_enc_id] == tap_null_enc_id;
+
+        // enclave ownermap relationship: the maximal parent-tree depth is 2 
+        invariant (forall e : tap_enclave_id_t :: (tap_enclave_metadata_valid_1[e]) ==> 
+                    (tap_enclave_metadata_owner_map_1[tap_enclave_metadata_owner_map_1[e]] == tap_null_enc_id));
+        invariant (forall e : tap_enclave_id_t :: (tap_enclave_metadata_valid_2[e]) ==> 
+                    (tap_enclave_metadata_owner_map_2[tap_enclave_metadata_owner_map_2[e]] == tap_null_enc_id));
+
+        // enclave ownermap relationship: enclave with chidren must be privileged 
+        invariant (forall e : tap_enclave_id_t :: 
+                    (tap_enclave_metadata_valid_1[e] && tap_enclave_metadata_owner_map_1[e] != tap_null_enc_id) ==> 
+                        (tap_enclave_metadata_privileged_1[tap_enclave_metadata_owner_map_1[e]]));
+        invariant (forall e : tap_enclave_id_t :: 
+                    (tap_enclave_metadata_valid_2[e] && tap_enclave_metadata_owner_map_2[e] != tap_null_enc_id) ==> 
+                        (tap_enclave_metadata_privileged_2[tap_enclave_metadata_owner_map_2[e]]));
+
+        // extend the exclusive-memory consistency to PE and NE children.
+        // 1.   constrain this consistency to PE-controlled enclave.
+        invariant (forall e : tap_enclave_id_t, v : vaddr_t :: 
+                    (tap_enclave_metadata_valid_1[e] && (tap_enclave_metadata_privileged_1[e] || tap_enclave_metadata_privileged_1[tap_enclave_metadata_owner_map_1[e]]) ==> 
+                        (tap_enclave_metadata_addr_excl_1[e][v] <==> cpu_owner_map_1[tap_enclave_metadata_addr_map_1[e][v]] == e)));
+        invariant (forall e : tap_enclave_id_t, v : vaddr_t :: 
+                    (tap_enclave_metadata_valid_2[e] && (tap_enclave_metadata_privileged_2[e] || tap_enclave_metadata_privileged_2[tap_enclave_metadata_owner_map_2[e]]) ==> 
+                        (tap_enclave_metadata_addr_excl_2[e][v] <==> cpu_owner_map_2[tap_enclave_metadata_addr_map_2[e][v]] == e)));
+        // 2.   constraint this consistency to PE.
+        invariant (forall v : vaddr_t :: 
+                    (tap_enclave_metadata_privileged_1[cpu_enclave_id_1] || tap_enclave_metadata_privileged_1[tap_enclave_metadata_owner_map_1[cpu_enclave_id_1]]) ==> 
+                        (tap_enclave_metadata_addr_excl_1[cpu_enclave_id_1][v] <==> cpu_owner_map_1[cpu_addr_map_1[v]] == cpu_enclave_id_1));
+        invariant (forall v : vaddr_t :: 
+                    (tap_enclave_metadata_privileged_2[cpu_enclave_id_2] || tap_enclave_metadata_privileged_2[tap_enclave_metadata_owner_map_2[cpu_enclave_id_2]]) ==> 
+                        (tap_enclave_metadata_addr_excl_2[cpu_enclave_id_2][v] <==> cpu_owner_map_2[cpu_addr_map_2[v]] == cpu_enclave_id_2));
+
         invariant current_mode == mode_untrusted || current_mode == mode_enclave;
         // memory is not assigned to an enclave that doesn't exist.
         invariant (forall pa : wap_addr_t, e : tap_enclave_id_t ::
@@ -172,47 +237,42 @@ procedure ProveConfidentialityPT(
         //-------------------------------------------------------------------//
         // CPU mode and CPU enclave ID must be consistent.
         //-------------------------------------------------------------------//
-        invariant (forall e : tap_enclave_id_t :: 
-                    !valid_enclave_id(e) ==> !tap_enclave_metadata_valid_1[tap_null_enc_id]);
-        invariant (forall e : tap_enclave_id_t ::
-                    !valid_enclave_id(e) ==> !tap_enclave_metadata_valid_2[tap_null_enc_id]);
-        invariant (current_mode == mode_untrusted) ==> cpu_enclave_id_1 != eid;
-        invariant (current_mode == mode_untrusted) ==> cpu_enclave_id_2 != eid;
+        invariant (current_mode == mode_untrusted) ==> (cpu_enclave_id_1 != eid);
+        invariant (current_mode == mode_untrusted) ==> (cpu_enclave_id_2 != eid);
         invariant (current_mode == mode_enclave) ==> (cpu_enclave_id_1 == eid);
         invariant (current_mode == mode_enclave) ==> (cpu_enclave_id_2 == eid);
         //-------------------------------------------------------------------//
         // Enclave 'eid' is mostly alive                                     //
         //-------------------------------------------------------------------//
+        invariant (valid_enclave_id(eid));
         invariant (cpu_enclave_id_1 != tap_blocked_enc_id);
         invariant (cpu_enclave_id_2 != tap_blocked_enc_id);
-        invariant (valid_enclave_id(eid));
-        invariant (!enclave_dead ==> tap_enclave_metadata_valid_1[eid]);
-        invariant (!enclave_dead ==> tap_enclave_metadata_valid_2[eid]);
+        invariant (tap_enclave_metadata_valid_1[eid]);
+        invariant (tap_enclave_metadata_valid_2[eid]);
         // maintain invariants about excl_vaddr.
-        invariant (!enclave_dead) ==>
-                        (tap_enclave_metadata_addr_excl_1[eid] == e_excl_vaddr);
-        invariant (!enclave_dead) ==>
-                        (tap_enclave_metadata_addr_excl_2[eid] == e_excl_vaddr);
-        invariant (forall v : vaddr_t :: (!enclave_dead && !e_excl_vaddr[v]) ==>
-                                (tap_enclave_metadata_addr_valid_1[eid][v] == 
-                                 tap_enclave_metadata_addr_valid_2[eid][v]));
-        invariant (forall v : vaddr_t :: (!enclave_dead && !e_excl_vaddr[v]) ==>
-                                (tap_enclave_metadata_addr_map_1[eid][v] == 
-                                 tap_enclave_metadata_addr_map_2[eid][v]));
+        invariant (tap_enclave_metadata_addr_excl_1[eid] == e_excl_vaddr);
+        invariant (tap_enclave_metadata_addr_excl_2[eid] == e_excl_vaddr);
+
+        // invariant (forall v : vaddr_t :: (!e_excl_vaddr[v]) ==>
+        //                         (tap_enclave_metadata_addr_valid_1[eid][v] == 
+        //                          tap_enclave_metadata_addr_valid_2[eid][v]));
+        // invariant (forall v : vaddr_t :: (!e_excl_vaddr[v]) ==>
+        //                         (tap_enclave_metadata_addr_map_1[eid][v] == 
+        //                          tap_enclave_metadata_addr_map_2[eid][v]));
         // invariants about addr_map
         invariant (forall v : vaddr_t ::
-                      (!enclave_dead && e_excl_vaddr[v]) ==>
-                          (tap_enclave_metadata_addr_map_1[eid][v] == e_addr_map_1[v]));
+                      e_excl_vaddr[v] ==>
+                          tap_enclave_metadata_addr_map_1[eid][v] == e_addr_map_1[v]);
         invariant (forall v : vaddr_t ::
-                      (!enclave_dead && e_excl_vaddr[v]) ==>
-                          (tap_enclave_metadata_addr_map_2[eid][v] == e_addr_map_2[v]));
+                      e_excl_vaddr[v] ==>
+                          tap_enclave_metadata_addr_map_2[eid][v] == e_addr_map_2[v]);
         // invariants about e_excl_addr
         invariant (forall p : wap_addr_t :: 
-                    (!enclave_dead) ==> ((cpu_owner_map_1[p] == eid) <==> e_excl_map[p]));
+                    (cpu_owner_map_1[p] == eid) <==> e_excl_map[p]);
         invariant (forall p : wap_addr_t :: 
-                    (!enclave_dead) ==> ((cpu_owner_map_2[p] == eid) <==> e_excl_map[p]));
+                    (cpu_owner_map_2[p] == eid) <==> e_excl_map[p]);
         invariant (forall v : vaddr_t, p : wap_addr_t :: 
-                        (!enclave_dead && e_excl_vaddr[v] && (p == e_addr_map_1[v] || p == e_addr_map_2[v]))
+                        (e_excl_vaddr[v] && (p == e_addr_map_1[v] || p == e_addr_map_2[v]))
                             ==> e_excl_map[p]);
         //-------------------------------------------------------------------//
         // Now deal with the enclaves.
@@ -223,15 +283,16 @@ procedure ProveConfidentialityPT(
         invariant (forall v : vaddr_t ::
                     (current_mode == mode_enclave && e_excl_vaddr[v]) ==> 
                         (cpu_addr_map_2[v] == e_addr_map_2[v]));
-        invariant (forall v : vaddr_t :: 
-                        (current_mode == mode_enclave && !e_excl_vaddr[v]) ==> 
-                            (cpu_addr_valid_1[v] == cpu_addr_valid_2[v]));
-        invariant (forall v : vaddr_t :: 
-                        (current_mode == mode_enclave && !e_excl_vaddr[v]) ==> 
-                            (cpu_addr_map_1[v] == cpu_addr_map_2[v]));
+        // invariant (forall v : vaddr_t :: 
+        //                 (current_mode == mode_enclave && !e_excl_vaddr[v]) ==> 
+        //                     (cpu_addr_valid_1[v] == cpu_addr_valid_2[v]));
+        // invariant (forall v : vaddr_t :: 
+        //                 (current_mode == mode_enclave && !e_excl_vaddr[v]) ==> 
+        //                     (cpu_addr_map_1[v] == cpu_addr_map_2[v]));
         //-------------------------------------------------------------------//
         // CPU state is the same                                             //
         //-------------------------------------------------------------------//
+        invariant (current_mode_1 == current_mode_2);
         // same PC.
         invariant (current_mode == mode_untrusted) ==> (cpu_pc_1 == cpu_pc_2);
         // same mode of operation.
@@ -239,34 +300,48 @@ procedure ProveConfidentialityPT(
         // same regs.
         invariant (current_mode == mode_untrusted) ==> (cpu_regs_1 == cpu_regs_2);
         // same va->pa.
-        invariant (current_mode == mode_untrusted) ==> 
-                    (cpu_addr_valid_1 == cpu_addr_valid_2);
-        invariant (current_mode == mode_untrusted) ==> 
-                        (cpu_addr_map_1 == cpu_addr_map_2);
+        invariant (current_mode == mode_untrusted) ==> (cpu_addr_valid_1 == cpu_addr_valid_2);
+        invariant (current_mode == mode_untrusted) ==> (cpu_addr_map_1 == cpu_addr_map_2);
         // owner map is the same.
         invariant (forall pa : wap_addr_t :: (cpu_owner_map_1[pa] == cpu_owner_map_2[pa]));
-        // addr_excl is the same for all eid.
-        invariant (forall e : tap_enclave_id_t :: 
-                    (tap_enclave_metadata_valid_1[e] && tap_enclave_metadata_valid_2[e]) ==>
-                        (tap_enclave_metadata_addr_excl_1[e] == tap_enclave_metadata_addr_excl_2[e]));
         // memory is the same except for the enclave memory.
         invariant (forall pa : wap_addr_t :: !e_excl_map[pa] ==> (cpu_mem_1[pa] == cpu_mem_2[pa]));
+
+        invariant (current_mode == mode_untrusted) ==> (tap_enclave_metadata_valid_1[cpu_enclave_id_1]);
+        invariant (current_mode == mode_untrusted) ==> (tap_enclave_metadata_valid_2[cpu_enclave_id_2]);
+
+        invariant (tap_enclave_metadata_valid_1[eid] && tap_enclave_metadata_valid_2[eid]);
         //-------------------------------------------------------------------//
-        //// OS state is the same ////
+        // OS state is the same                                              //
         //-------------------------------------------------------------------//
         // OS va->pa 
-        invariant (untrusted_addr_valid_1 == untrusted_addr_valid_2);
-        invariant (untrusted_addr_map_1 == untrusted_addr_map_2);
+        invariant (tap_enclave_metadata_addr_valid_1[tap_null_enc_id] == tap_enclave_metadata_addr_valid_2[tap_null_enc_id]);
+        invariant (tap_enclave_metadata_addr_map_1[tap_null_enc_id] == tap_enclave_metadata_addr_map_2[tap_null_enc_id]);
         // OS regs.
-        invariant (untrusted_regs_1 == untrusted_regs_2);
-        invariant (untrusted_pc_1 == untrusted_pc_2);
+        invariant (tap_enclave_metadata_regs_1[tap_null_enc_id] == tap_enclave_metadata_regs_2[tap_null_enc_id]);
+        invariant (tap_enclave_metadata_pc_1[tap_null_enc_id] == tap_enclave_metadata_pc_2[tap_null_enc_id]);
+
+        // Stronger: applied for OS and all other NE
+        invariant (forall e : tap_enclave_id_t :: (tap_enclave_metadata_valid[e] && e != eid) ==> 
+            (tap_enclave_metadata_addr_valid_1[e] == tap_enclave_metadata_addr_valid_2[e]));
+        invariant (forall e : tap_enclave_id_t :: (tap_enclave_metadata_valid[e] && e != eid) ==>
+            (tap_enclave_metadata_addr_map_1[e] == tap_enclave_metadata_addr_map_2[e]));
+        invariant (forall e : tap_enclave_id_t :: (tap_enclave_metadata_valid[e] && e != eid) ==> 
+            (tap_enclave_metadata_regs_1[e] == tap_enclave_metadata_regs_2[e]));
+        invariant (forall e : tap_enclave_id_t :: (tap_enclave_metadata_valid[e] && e != eid) ==> 
+            (tap_enclave_metadata_pc_1[e] == tap_enclave_metadata_pc_2[e]));
+
+
         //-------------------------------------------------------------------//
         // Enclave state is the same except for eid (mostly). Some it is the //
         // the same for eid as well (addr_map and addr_excl).                //
         //-------------------------------------------------------------------//
+
         // valid is the same except for eid.
         invariant (forall e : tap_enclave_id_t :: (e != eid) ==>
                     (tap_enclave_metadata_valid_1[e] == tap_enclave_metadata_valid_2[e]));
+
+
         // addr valid is the same except for eid.
         invariant (forall e : tap_enclave_id_t :: 
                     (tap_enclave_metadata_valid_1[e] && tap_enclave_metadata_valid_2[e] && e != eid) ==>
@@ -275,6 +350,10 @@ procedure ProveConfidentialityPT(
         invariant (forall e : tap_enclave_id_t :: 
                     (tap_enclave_metadata_valid_1[e] && tap_enclave_metadata_valid_2[e] && e != eid) ==>
                         (tap_enclave_metadata_addr_map_1[e] == tap_enclave_metadata_addr_map_2[e]));
+        // addr_excl is the same for all eid.
+        invariant (forall e : tap_enclave_id_t :: 
+                    (tap_enclave_metadata_valid_1[e] && tap_enclave_metadata_valid_2[e]) ==>
+                        (tap_enclave_metadata_addr_excl_1[e] == tap_enclave_metadata_addr_excl_2[e]));
         // entrypoints are the same except for eid.
         invariant (forall e : tap_enclave_id_t :: 
                     (tap_enclave_metadata_valid_1[e] && tap_enclave_metadata_valid_2[e] && e != eid) ==>
@@ -291,66 +370,113 @@ procedure ProveConfidentialityPT(
         invariant (forall e : tap_enclave_id_t :: 
                     (tap_enclave_metadata_valid_1[e] && tap_enclave_metadata_valid_2[e]) ==>
                         (tap_enclave_metadata_paused_1[e] == tap_enclave_metadata_paused_2[e]));
+
+        // invariants about state sync between 2 traces.
+        // OS/NE sync.
+        invariant (current_mode == mode_untrusted) ==> 
+                    (cpu_enclave_id_1 == tap_null_enc_id ==> 
+                        cpu_enclave_id_2 == tap_null_enc_id);
+        invariant (current_mode == mode_untrusted) ==> 
+            ((cpu_enclave_id_1 != tap_null_enc_id && tap_enclave_metadata_owner_map_1[cpu_enclave_id_1] == tap_null_enc_id) ==> 
+                tap_enclave_metadata_owner_map_2[cpu_enclave_id_2] == tap_null_enc_id);
+        // due to Z3 prover's features, we add some trivial claims in the precondition of this claim.
+        invariant (current_mode == mode_untrusted && cpu_enclave_id_1 != tap_null_enc_id && cpu_enclave_id_1 != eid && tap_enclave_metadata_owner_map_1[cpu_enclave_id_1] == eid) ==> 
+            (cpu_enclave_id_1 == cpu_enclave_id_2);
+        
+        // OS/NE & PE sync: stronger.
+        invariant (forall e : tap_enclave_id_t :: 
+            (tap_enclave_metadata_valid_1[e] && tap_enclave_metadata_valid_2[e]) ==> 
+                tap_enclave_metadata_owner_map_1[e] == tap_enclave_metadata_owner_map_2[e]);
+        // In confidentiality, we keep the adversary be same.
+        invariant (forall e: tap_enclave_id_t ::
+            tap_enclave_metadata_privileged_1[e] <==> tap_enclave_metadata_privileged_2[e]);
+        // invariant (forall e : tap_enclave_id_t :: 
+        //     (tap_enclave_metadata_valid_1[e] && tap_enclave_metadata_owner_map_1[e] == eid) <==> 
+        //         (tap_enclave_metadata_valid_2[e] && tap_enclave_metadata_owner_map_2[e] == eid));
+
+        invariant (forall e : tap_enclave_id_t :: 
+                    (tap_enclave_metadata_valid_1[e] && tap_enclave_metadata_owner_map_1[e] == eid) ==> 
+                        tap_enclave_metadata_paused_1[e] == tap_enclave_metadata_paused_2[e]);
+
     {
-        if (current_mode == mode_untrusted) {
-            havoc r_proof_op, r_eid, r_pc, r_read, r_write, r_data, 
-                  l_vaddr, s_vaddr, s_data, r_pt_eid, r_pt_va, 
-                  pt_eid, pt_vaddr, pt_valid, pt_paddr, r_addr_valid, 
-                  r_addr_map, r_excl_vaddr, r_excl_map, r_bmap,
-                  r_container_valid, r_container_data, r_entrypoint, r_l_way, r_s_way;
+        havoc r_proof_op, r_eid, r_pc, r_regs, r_read, r_write, r_data, 
+                l_vaddr, s_vaddr, s_data, r_pt_eid, r_pt_va, 
+                pt_eid, pt_vaddr, pt_valid, pt_paddr, r_addr_valid, 
+                r_addr_map, r_excl_vaddr, r_excl_map, r_bmap,
+                r_container_valid, r_container_data, r_entrypoint, r_privileged, r_l_way, r_s_way;
 
+        if (current_mode == mode_untrusted) {
+            // assume false;
+            assume tap_proof_op_valid(r_proof_op);
             assume valid_regindex(r_read);
             assume valid_regindex(r_write);
             assume valid_cache_way_index(r_l_way);
             assume valid_cache_way_index(r_s_way);
+            
+            call r_addr_valid, r_addr_map, r_excl_vaddr, r_excl_map, r_entrypoint, r_privileged := LaunchInputHavoc(r_eid);
+
             // trace_1
             call RestoreContext_1();
             call observation_1, current_mode_1, enclave_dead_1, status_1 :=
-                                    ObserverStep(k_pt_observer_t, current_mode, eid, r_eid, r_proof_op, 
+                                    ObserverStep(k_mem_observer_t, current_mode, eid, r_eid, 
+                                                r_addr_valid, r_addr_map, r_excl_vaddr, r_excl_map, r_entrypoint, r_privileged, 
+                                                r_proof_op, 
                                                 r_pc, r_read, r_write, r_data, 
                                                 l_vaddr, s_vaddr, s_data,
                                                 r_pt_eid, r_pt_va,
                                                 pt_eid, pt_vaddr, pt_valid, pt_paddr,
-                                                r_addr_valid, r_addr_map, r_excl_vaddr,
-                                                r_excl_map, r_container_valid, r_container_data,
-                                                r_entrypoint, r_bmap,
+                                                r_container_valid, r_container_data, r_bmap,
                                                 r_l_way, r_s_way);
             call SaveContext_1();
 
             // trace_2
             call RestoreContext_2();
             call observation_2, current_mode_2, enclave_dead_2, status_2 :=
-                                    ObserverStep(k_pt_observer_t, current_mode, eid, r_eid, r_proof_op, 
+                                    ObserverStep(k_mem_observer_t, current_mode, eid, r_eid, 
+                                                r_addr_valid, r_addr_map, r_excl_vaddr, r_excl_map, r_entrypoint, r_privileged, 
+                                                r_proof_op, 
                                                 r_pc, r_read, r_write, r_data, 
                                                 l_vaddr, s_vaddr, s_data,
                                                 r_pt_eid, r_pt_va,
                                                 pt_eid, pt_vaddr, pt_valid, pt_paddr,
-                                                r_addr_valid, r_addr_map, r_excl_vaddr,
-                                                r_excl_map, r_container_valid, r_container_data,
-                                                r_entrypoint, r_bmap,
+                                                r_container_valid, r_container_data, r_bmap,
                                                 r_l_way, r_s_way);
             call SaveContext_2();
 
             // some sanity checks.
             assert status_1 == status_2;
             assert current_mode_1 == current_mode_2;
-            assert enclave_dead_1 == enclave_dead_2;
+            // Considering deprecate enclave dead.
             current_mode := current_mode_1;
-            enclave_dead := enclave_dead_2;
         } else {
+            // assume false;
+            // assume e_privileged;
             havoc e_proof_op;
-            assume tap_proof_op_valid_in_enclave(e_proof_op);
+            if (e_privileged) {
+                assume tap_proof_op_valid_in_privileged(e_proof_op);
 
+            } else {
+                assume tap_proof_op_valid_in_enclave(e_proof_op);
+
+            }
+
+            call r_addr_valid, r_addr_map, r_excl_vaddr, r_excl_map, r_entrypoint, r_privileged := LaunchInputHavoc(r_eid);
             // trace_1
             call RestoreContext_1();
-            call current_mode_1, load_addr_1, l_way, store_addr_1, store_data_1, s_way := 
-                        EnclaveStep(current_mode, eid, e_proof_op);
+            call current_mode_1, load_addr_1, l_way, store_addr_1, store_data_1, s_way, status_1 := 
+                            EnclaveStep(current_mode, eid, r_eid, 
+                                        r_addr_valid, r_addr_map, r_excl_vaddr, r_excl_map, r_entrypoint, r_privileged, 
+                                        r_container_valid, r_container_data,
+                                        r_regs, e_proof_op);
             call SaveContext_1();
 
             // trace_1
             call RestoreContext_2();
-            call current_mode_2, load_addr_2, l_way, store_addr_2, store_data_2, s_way := 
-                        EnclaveStep(current_mode, eid, e_proof_op);
+            call current_mode_2, load_addr_2, l_way, store_addr_2, store_data_2, s_way, status_2 := 
+                            EnclaveStep(current_mode, eid, r_eid, 
+                                        r_addr_valid, r_addr_map, r_excl_vaddr, r_excl_map, r_entrypoint, r_privileged,
+                                        r_container_valid, r_container_data,
+                                        r_regs, e_proof_op);
             call SaveContext_2();
 
             // some sanity checks.
@@ -360,6 +486,7 @@ procedure ProveConfidentialityPT(
             assume (!e_excl_vaddr[load_addr_1] || !e_excl_vaddr[load_addr_2]) ==>
                        (load_addr_1 == load_addr_2 &&
                         cpu_addr_map_1[load_addr_1] == cpu_addr_map_2[load_addr_2]);
+
             assume (!e_excl_vaddr[store_addr_1] || !e_excl_vaddr[store_addr_2]) ==>
                        (store_addr_1 == store_addr_2 && store_data_1 == store_data_2 &&
                         cpu_addr_map_1[store_addr_1] == cpu_addr_map_2[store_addr_2]);
diff --git a/AbstractPlatform/ProofCommon.bpl b/AbstractPlatform/ProofCommon.bpl
old mode 100644
new mode 100755
index 75bb7c2..8c31d2e
--- a/AbstractPlatform/ProofCommon.bpl
+++ b/AbstractPlatform/ProofCommon.bpl
@@ -16,14 +16,6 @@ var cache_valid_map_1                     : cache_valid_map_t;
 var cache_valid_map_2                     : cache_valid_map_t;
 var cache_tag_map_1                       : cache_tag_map_t;
 var cache_tag_map_2                       : cache_tag_map_t;
-var untrusted_addr_valid_1                : addr_valid_t;
-var untrusted_addr_valid_2                : addr_valid_t;
-var untrusted_addr_map_1                  : addr_map_t;
-var untrusted_addr_map_2                  : addr_map_t;
-var untrusted_regs_1                      : regs_t;
-var untrusted_regs_2                      : regs_t;
-var untrusted_pc_1                        : vaddr_t;
-var untrusted_pc_2                        : vaddr_t;
 var tap_enclave_metadata_valid_1          : tap_enclave_metadata_valid_t;
 var tap_enclave_metadata_valid_2          : tap_enclave_metadata_valid_t;
 var tap_enclave_metadata_addr_map_1       : tap_enclave_metadata_addr_map_t;
@@ -43,6 +35,12 @@ var tap_enclave_metadata_paused_2         : tap_enclave_metadata_paused_t;
 var tap_enclave_metadata_cache_conflict_1 : tap_enclave_metadata_cache_conflict_t;
 var tap_enclave_metadata_cache_conflict_2 : tap_enclave_metadata_cache_conflict_t;
 
+var tap_enclave_metadata_privileged_1     : tap_enclave_metadata_privileged_t;
+var tap_enclave_metadata_privileged_2     : tap_enclave_metadata_privileged_t;
+var tap_enclave_metadata_owner_map_1      : tap_enclave_metadata_owner_map_t;
+var tap_enclave_metadata_owner_map_2      : tap_enclave_metadata_owner_map_t;
+
+
 procedure {:inline 1} RestoreContext_1()
     modifies cpu_mem;
     modifies cpu_regs;
@@ -52,10 +50,6 @@ procedure {:inline 1} RestoreContext_1()
     modifies cpu_addr_map;
     modifies cpu_owner_map;
     modifies cache_valid_map, cache_tag_map;
-    modifies untrusted_addr_valid;
-    modifies untrusted_addr_map;
-    modifies untrusted_regs;
-    modifies untrusted_pc;
     modifies tap_enclave_metadata_valid;
     modifies tap_enclave_metadata_addr_map;
     modifies tap_enclave_metadata_addr_valid;
@@ -65,6 +59,8 @@ procedure {:inline 1} RestoreContext_1()
     modifies tap_enclave_metadata_regs;
     modifies tap_enclave_metadata_paused;
     modifies tap_enclave_metadata_cache_conflict;
+    modifies tap_enclave_metadata_privileged;
+    modifies tap_enclave_metadata_owner_map;
 {
     cpu_mem                             := cpu_mem_1;
     cpu_regs                            := cpu_regs_1;
@@ -75,10 +71,6 @@ procedure {:inline 1} RestoreContext_1()
     cpu_owner_map                       := cpu_owner_map_1;
     cache_valid_map                     := cache_valid_map_1;
     cache_tag_map                       := cache_tag_map_1;
-    untrusted_addr_valid                := untrusted_addr_valid_1;
-    untrusted_addr_map                  := untrusted_addr_map_1;
-    untrusted_regs                      := untrusted_regs_1;
-    untrusted_pc                        := untrusted_pc_1;
     tap_enclave_metadata_valid          := tap_enclave_metadata_valid_1;
     tap_enclave_metadata_addr_map       := tap_enclave_metadata_addr_map_1;
     tap_enclave_metadata_addr_valid     := tap_enclave_metadata_addr_valid_1;
@@ -88,6 +80,8 @@ procedure {:inline 1} RestoreContext_1()
     tap_enclave_metadata_regs           := tap_enclave_metadata_regs_1;
     tap_enclave_metadata_paused         := tap_enclave_metadata_paused_1;
     tap_enclave_metadata_cache_conflict := tap_enclave_metadata_cache_conflict_1;
+    tap_enclave_metadata_privileged     := tap_enclave_metadata_privileged_1;
+    tap_enclave_metadata_owner_map      := tap_enclave_metadata_owner_map_1;
 }
 
 procedure {:inline 1} SaveContext_1()
@@ -99,10 +93,6 @@ procedure {:inline 1} SaveContext_1()
     modifies cpu_addr_map_1;
     modifies cpu_owner_map_1;
     modifies cache_valid_map_1, cache_tag_map_1;
-    modifies untrusted_addr_valid_1;
-    modifies untrusted_addr_map_1;
-    modifies untrusted_regs_1;
-    modifies untrusted_pc_1;
     modifies tap_enclave_metadata_valid_1;
     modifies tap_enclave_metadata_addr_map_1;
     modifies tap_enclave_metadata_addr_valid_1;
@@ -112,6 +102,8 @@ procedure {:inline 1} SaveContext_1()
     modifies tap_enclave_metadata_regs_1;
     modifies tap_enclave_metadata_paused_1;
     modifies tap_enclave_metadata_cache_conflict_1;
+    modifies tap_enclave_metadata_privileged_1;
+    modifies tap_enclave_metadata_owner_map_1;
 {
     cpu_mem_1                             := cpu_mem;
     cpu_regs_1                            := cpu_regs;
@@ -122,10 +114,6 @@ procedure {:inline 1} SaveContext_1()
     cpu_owner_map_1                       := cpu_owner_map;
     cache_valid_map_1                     := cache_valid_map;
     cache_tag_map_1                       := cache_tag_map;
-    untrusted_addr_valid_1                := untrusted_addr_valid;
-    untrusted_addr_map_1                  := untrusted_addr_map;
-    untrusted_regs_1                      := untrusted_regs;
-    untrusted_pc_1                        := untrusted_pc;
     tap_enclave_metadata_valid_1          := tap_enclave_metadata_valid;
     tap_enclave_metadata_addr_map_1       := tap_enclave_metadata_addr_map;
     tap_enclave_metadata_addr_valid_1     := tap_enclave_metadata_addr_valid;
@@ -135,6 +123,8 @@ procedure {:inline 1} SaveContext_1()
     tap_enclave_metadata_regs_1           := tap_enclave_metadata_regs;
     tap_enclave_metadata_paused_1         := tap_enclave_metadata_paused;
     tap_enclave_metadata_cache_conflict_1 := tap_enclave_metadata_cache_conflict;
+    tap_enclave_metadata_privileged_1     := tap_enclave_metadata_privileged;
+    tap_enclave_metadata_owner_map_1      := tap_enclave_metadata_owner_map;
 }
 
 procedure {:inline 2} RestoreContext_2()
@@ -146,10 +136,6 @@ procedure {:inline 2} RestoreContext_2()
     modifies cpu_addr_map;
     modifies cpu_owner_map;
     modifies cache_valid_map, cache_tag_map;
-    modifies untrusted_addr_valid;
-    modifies untrusted_addr_map;
-    modifies untrusted_regs;
-    modifies untrusted_pc;
     modifies tap_enclave_metadata_valid;
     modifies tap_enclave_metadata_addr_map;
     modifies tap_enclave_metadata_addr_valid;
@@ -159,6 +145,8 @@ procedure {:inline 2} RestoreContext_2()
     modifies tap_enclave_metadata_regs;
     modifies tap_enclave_metadata_paused;
     modifies tap_enclave_metadata_cache_conflict;
+    modifies tap_enclave_metadata_privileged;
+    modifies tap_enclave_metadata_owner_map;
 {
     cpu_mem                             := cpu_mem_2;
     cpu_regs                            := cpu_regs_2;
@@ -169,10 +157,6 @@ procedure {:inline 2} RestoreContext_2()
     cpu_owner_map                       := cpu_owner_map_2;
     cache_valid_map                     := cache_valid_map_2;
     cache_tag_map                       := cache_tag_map_2;
-    untrusted_addr_valid                := untrusted_addr_valid_2;
-    untrusted_addr_map                  := untrusted_addr_map_2;
-    untrusted_regs                      := untrusted_regs_2;
-    untrusted_pc                        := untrusted_pc_2;
     tap_enclave_metadata_valid          := tap_enclave_metadata_valid_2;
     tap_enclave_metadata_addr_map       := tap_enclave_metadata_addr_map_2;
     tap_enclave_metadata_addr_valid     := tap_enclave_metadata_addr_valid_2;
@@ -182,6 +166,8 @@ procedure {:inline 2} RestoreContext_2()
     tap_enclave_metadata_regs           := tap_enclave_metadata_regs_2;
     tap_enclave_metadata_paused         := tap_enclave_metadata_paused_2;
     tap_enclave_metadata_cache_conflict := tap_enclave_metadata_cache_conflict_2;
+    tap_enclave_metadata_privileged     := tap_enclave_metadata_privileged_2;
+    tap_enclave_metadata_owner_map      := tap_enclave_metadata_owner_map_2;
 }
 
 procedure {:inline 2} SaveContext_2()
@@ -193,10 +179,6 @@ procedure {:inline 2} SaveContext_2()
     modifies cpu_addr_map_2;
     modifies cpu_owner_map_2;
     modifies cache_valid_map_2, cache_tag_map_2;
-    modifies untrusted_addr_valid_2;
-    modifies untrusted_addr_map_2;
-    modifies untrusted_regs_2;
-    modifies untrusted_pc_2;
     modifies tap_enclave_metadata_valid_2;
     modifies tap_enclave_metadata_addr_map_2;
     modifies tap_enclave_metadata_addr_valid_2;
@@ -206,6 +188,8 @@ procedure {:inline 2} SaveContext_2()
     modifies tap_enclave_metadata_regs_2;
     modifies tap_enclave_metadata_paused_2;
     modifies tap_enclave_metadata_cache_conflict_2;
+    modifies tap_enclave_metadata_privileged_2;
+    modifies tap_enclave_metadata_owner_map_2;
 {
     cpu_mem_2                             := cpu_mem;
     cpu_regs_2                            := cpu_regs;
@@ -216,10 +200,6 @@ procedure {:inline 2} SaveContext_2()
     cpu_owner_map_2                       := cpu_owner_map;
     cache_valid_map_2                     := cache_valid_map;
     cache_tag_map_2                       := cache_tag_map;
-    untrusted_addr_valid_2                := untrusted_addr_valid;
-    untrusted_addr_map_2                  := untrusted_addr_map;
-    untrusted_regs_2                      := untrusted_regs;
-    untrusted_pc_2                        := untrusted_pc;
     tap_enclave_metadata_valid_2          := tap_enclave_metadata_valid;
     tap_enclave_metadata_addr_map_2       := tap_enclave_metadata_addr_map;
     tap_enclave_metadata_addr_valid_2     := tap_enclave_metadata_addr_valid;
@@ -229,6 +209,8 @@ procedure {:inline 2} SaveContext_2()
     tap_enclave_metadata_regs_2           := tap_enclave_metadata_regs;
     tap_enclave_metadata_paused_2         := tap_enclave_metadata_paused;
     tap_enclave_metadata_cache_conflict_2 := tap_enclave_metadata_cache_conflict;
+    tap_enclave_metadata_privileged_2     := tap_enclave_metadata_privileged;
+    tap_enclave_metadata_owner_map_2      := tap_enclave_metadata_owner_map;
 }
 
 procedure HavocOSMem(excl_map : excl_map_t);
@@ -244,7 +226,7 @@ procedure InitOSMem(container_valid : container_valid_t, container_data : contai
                         then cpu_mem[p] == container_data[p]
                         else cpu_mem[p] == old(cpu_mem)[p]);
 
-procedure InitialHavoc()
+procedure InitialHavoc(eid: tap_enclave_id_t)
     returns (current_mode : mode_t);
 
     modifies cpu_mem;
@@ -255,10 +237,6 @@ procedure InitialHavoc()
     modifies cpu_addr_map;
     modifies cpu_owner_map;
     modifies cache_valid_map, cache_tag_map;
-    modifies untrusted_addr_valid;
-    modifies untrusted_addr_map;
-    modifies untrusted_regs;
-    modifies untrusted_pc;
     modifies tap_enclave_metadata_valid;
     modifies tap_enclave_metadata_addr_map;
     modifies tap_enclave_metadata_addr_valid;
@@ -268,20 +246,48 @@ procedure InitialHavoc()
     modifies tap_enclave_metadata_regs;
     modifies tap_enclave_metadata_paused;
     modifies tap_enclave_metadata_cache_conflict;
-
+    modifies tap_enclave_metadata_owner_map;
+    modifies tap_enclave_metadata_privileged;
+    
     ensures (current_mode == mode_untrusted);
     //----------------------------------------------------------------------//
     // global TAP invariants.                                               //
     //----------------------------------------------------------------------//
     ensures (cpu_enclave_id == tap_null_enc_id);
+    
+    // corner cases, precondition for launch
+    ensures (!tap_enclave_metadata_privileged[tap_null_enc_id]);
+
+    ensures (forall e : tap_enclave_id_t :: 
+            (tap_enclave_metadata_valid[e] && tap_enclave_metadata_privileged[e]) ==> 
+                    (tap_enclave_metadata_owner_map[e] == tap_null_enc_id));
+
+    ensures (tap_enclave_metadata_owner_map[tap_null_enc_id] == tap_null_enc_id);
+
     ensures  (forall pa : wap_addr_t, e : tap_enclave_id_t ::
                 (valid_enclave_id(e) && !tap_enclave_metadata_valid[e]) ==> 
                     (cpu_owner_map[pa] != e));
     // current pc invariants
     ensures (tap_addr_perm_x(cpu_addr_valid[cpu_pc]));
     ensures (cpu_owner_map[cpu_addr_map[cpu_pc]] == cpu_enclave_id);
+
     // enclave invariants.
-    ensures (forall e : tap_enclave_id_t :: !valid_enclave_id(e) ==> !tap_enclave_metadata_valid[e]);
+    ensures tap_enclave_metadata_valid[tap_null_enc_id];
+    ensures (forall e : tap_enclave_id_t :: 
+                special_enclave_id(e) ==> !tap_enclave_metadata_valid[e]);
+    // eid cannot be valid at init stage.
+    ensures !tap_enclave_metadata_valid[eid];
+    // randomness control: differrent traces have same ownermap at beginning.
+    // cut branches: those ensures will cost a lot
+
+    // ensures (forall e : tap_enclave_id_t :: tap_enclave_metadata_valid[e] ==> 
+    //             (tap_enclave_metadata_valid[tap_enclave_metadata_owner_map[e]]));
+    // ensures (forall e : tap_enclave_id_t :: 
+    //             (tap_enclave_metadata_owner_map[e] != eid));
+    // ensures (forall e : tap_enclave_id_t :: 
+    //             !valid_enclave_id(e) ==> 
+    //                 !tap_enclave_metadata_valid[e]);
+
     ensures (forall e : tap_enclave_id_t ::
                 tap_enclave_metadata_valid[e] ==> 
                     tap_addr_perm_x(tap_enclave_metadata_addr_valid[e][tap_enclave_metadata_pc[e]]));
@@ -300,21 +306,87 @@ procedure InitialHavoc()
     ensures (forall e : tap_enclave_id_t ::
                 tap_enclave_metadata_valid[e] ==> 
                     cpu_owner_map[tap_enclave_metadata_addr_map[e][tap_enclave_metadata_entrypoint[e]]] == e);
+    
+    // for those valid & active enclave when init, its owner is OS by default
+    ensures (forall e : tap_enclave_id_t ::
+                tap_enclave_metadata_valid[e] ==> 
+                    tap_enclave_metadata_owner_map[e] == tap_null_enc_id);
+    
     // CPU/Enclave address map invariants.
+    // mapping & addr_valid sync
     ensures (forall va : vaddr_t :: 
-                (cpu_enclave_id == tap_null_enc_id) ==> 
-                    (cpu_addr_map[va] == untrusted_addr_map[va]));
-    ensures (forall va : vaddr_t :: 
-                (cpu_enclave_id == tap_null_enc_id) ==> 
-                    tap_addr_perm_eq(cpu_addr_valid[va], untrusted_addr_valid[va]));
-    ensures (forall va : vaddr_t :: 
-                (cpu_enclave_id != tap_null_enc_id) ==> 
-                    (cpu_addr_map[va] == tap_enclave_metadata_addr_map[cpu_enclave_id][va]));
+                (cpu_addr_map[va] == tap_enclave_metadata_addr_map[cpu_enclave_id][va]));
     ensures (forall va : vaddr_t :: 
-                (cpu_enclave_id != tap_null_enc_id) ==> 
-                    tap_addr_perm_eq(cpu_addr_valid[va], tap_enclave_metadata_addr_valid[cpu_enclave_id][va]));
+                (tap_addr_perm_eq(cpu_addr_valid[va], tap_enclave_metadata_addr_valid[cpu_enclave_id][va])));
+
+    //  Apr 7, 2023.
+    //  initial state: exclusive memory consistency
+    ensures (forall e : tap_enclave_id_t, v : vaddr_t :: 
+        tap_enclave_metadata_valid[e] ==> 
+            (tap_enclave_metadata_addr_excl[e][v] <==> cpu_owner_map[tap_enclave_metadata_addr_map[e][v]] == e));
+    
+
+// launch startup stage.
+procedure LaunchHavoc(eid : tap_enclave_id_t) 
+    returns (addr_valid : addr_valid_t, 
+             addr_map : addr_map_t, 
+             excl_vaddr : excl_vaddr_t, 
+             excl_map : excl_map_t, 
+             entrypoint : vaddr_t, 
+             privilege : bool);
+             
+    ensures tap_addr_perm_x(addr_valid[entrypoint]);
+    ensures excl_map[addr_map[entrypoint]];
+    ensures excl_vaddr[entrypoint];
+    ensures (forall pa : wap_addr_t :: 
+        (excl_map[pa] ==> cpu_owner_map[pa] == tap_null_enc_id));
+    ensures (forall v : vaddr_t :: 
+        (excl_vaddr[v] ==> tap_addr_perm_v(addr_valid[v])));
+    ensures (forall v : vaddr_t :: 
+        (excl_vaddr[v] ==> excl_map[addr_map[v]]));
+    ensures (forall v1, v2 : vaddr_t :: 
+        !vaddr_alias(excl_vaddr, addr_map, v1, v2)); 
 
+// ensure the enclave's input's validity
+procedure LaunchInputHavoc(eid : tap_enclave_id_t)
+    returns (addr_valid : addr_valid_t, 
+             addr_map : addr_map_t, 
+             excl_vaddr : excl_vaddr_t, 
+             excl_map : excl_map_t, 
+             entrypoint : vaddr_t, 
+             privilege : bool);
+    ensures tap_addr_perm_x(addr_valid[entrypoint]);
+    ensures excl_map[addr_map[entrypoint]];
+    ensures excl_vaddr[entrypoint];
+    ensures (forall pa : wap_addr_t :: 
+        (excl_map[pa] ==> cpu_owner_map_1[pa] == tap_null_enc_id));
+    ensures (forall pa : wap_addr_t :: 
+        (excl_map[pa] ==> cpu_owner_map_2[pa] == tap_null_enc_id));
+    ensures !excl_map[cpu_addr_map_1[cpu_pc_1]];
+    ensures !excl_map[cpu_addr_map_2[cpu_pc_2]];
+    ensures (forall v : vaddr_t :: 
+        (excl_vaddr[v] ==> tap_addr_perm_v(addr_valid[v])));
+    ensures (forall v : vaddr_t :: 
+        (excl_vaddr[v] ==> excl_map[addr_map[v]]));
+    ensures (forall v1, v2 : vaddr_t :: 
+        !vaddr_alias(excl_vaddr, addr_map, v1, v2)); 
 
+procedure LoadHavoc(eid : tap_enclave_id_t)
+    returns (i_eid : tap_enclave_id_t);
+
+    ensures tap_enclave_metadata_valid[i_eid];
+    ensures tap_enclave_metadata_privileged[eid] ==> 
+        (i_eid == eid || tap_enclave_metadata_owner_map[i_eid] == eid);
+    ensures !tap_enclave_metadata_privileged[eid] ==>
+        (i_eid == eid);
+
+// mapping interface privided by PE.
+procedure AcquireMapping(eid : tap_enclave_id_t)
+    returns (r_vaddr : vaddr_t, r_paddr : wap_addr_t, r_valid : addr_perm_t);
+    ensures tap_enclave_metadata_privileged[tap_enclave_metadata_owner_map[eid]] ==>
+        tap_enclave_metadata_addr_excl[eid][r_vaddr] <==> cpu_owner_map[r_paddr] == eid;
+    ensures tap_enclave_metadata_privileged[eid] ==>
+        tap_enclave_metadata_addr_excl[eid][r_vaddr] <==> cpu_owner_map[r_paddr] == eid;
 
 // Uninterpreted functions to model deterministic computation.
 function uf_cpu_r0_index(opcode : word_t) : regindex_t;
@@ -325,6 +397,9 @@ axiom (forall w : word_t :: valid_regindex(uf_cpu_r1_index(w)));
 axiom (forall w : word_t :: valid_regindex(uf_cpu_r2_index(w)));
 
 function uf_mem_load_vaddr(pc : vaddr_t, op : word_t, r1 : word_t, r2 : word_t) : vaddr_t;
+
+function uf_mem_load_eid (pc : vaddr_t, op : word_t, r1 : word_t, r2 : word_t) : tap_enclave_id_t;
+
 function uf_mem_store_vaddr(pc : vaddr_t, op : word_t, l_data : word_t, r1 : word_t, r2 : word_t) : vaddr_t;
 function uf_mem_store_data(pc : vaddr_t, op : word_t, l_data : word_t, r1 : word_t, r2 : word_t) : word_t;
 function uf_cpu_pc(pc : vaddr_t, op : word_t, l_data : word_t, r1 : word_t, r2 : word_t) : vaddr_t;
@@ -334,3 +409,13 @@ function uf_observation_mem(cpu_pc : vaddr_t, l_word : word_t, r_word : word_t)
 function uf_observation_cache(hit1 : bool, hit2 : bool) : word_t;
 function uf_observation_pt(r_valid : addr_perm_t, r_paddr : wap_addr_t) : word_t;
 
+function uf_load_selector(pc : vaddr_t, op : word_t, r1 : word_t, r2 : word_t) : tap_enclave_id_t;
+
+// axiom (forall i_eid : tap_enclave_id_t, r1 : word_t, r2 : word_t :: 
+//     tap_enclave_metadata_valid[uf_load_selector(i_eid, r1, r2)]);
+// axiom (forall i_eid : tap_enclave_id_t, r1 : word_t, r2 : word_t :: 
+//     tap_enclave_metadata_privileged[i_eid] ==> 
+//         uf_load_selector(i_eid, r1, r2) == i_eid || tap_enclave_metadata_owner_map[uf_load_selector(i_eid, r1, r2)] == i_eid);
+// axiom (forall i_eid : tap_enclave_id_t, r1 : word_t, r2 : word_t :: 
+//     !tap_enclave_metadata_privileged[i_eid] ==> 
+//         uf_load_selector(i_eid, r1, r2) == i_eid);
\ No newline at end of file
diff --git a/AbstractPlatform/Types.bpl b/AbstractPlatform/Types.bpl
old mode 100644
new mode 100755
index 02721f6..1db6041
--- a/AbstractPlatform/Types.bpl
+++ b/AbstractPlatform/Types.bpl
@@ -21,6 +21,20 @@ axiom kN_regindex_t_as_int == 512;
 function valid_regindex(ri : regindex_t) : bool 
 { ri >= k0_regindex_t && ri < kN_regindex_t }
 
+// Restrict valid enclave mapping id to support finite measurement steps
+// Should be distinguished from meta_valid().
+const k0_int_t  : int;
+axiom k0_int_t == 0;
+
+const k0_enclave_id_t : int;
+axiom k0_enclave_id_t == 0;
+const kN_enclave_id_t : int;
+axiom kN_enclave_id_t == 512;
+
+const kN_enclave_id_t_as_int : int;
+axiom kN_enclave_id_t_as_int == 512;
+function valid_enclave_id_index(eid : tap_enclave_id_t) : bool
+{ eid >= k0_enclave_id_t && eid < kN_enclave_id_t }
 
 // -------------------------------------------------------------------- //
 // operating mode of the CPU.                                           //
@@ -29,7 +43,7 @@ type mode_t;
 const unique mode_untrusted : mode_t;
 const unique mode_enclave   : mode_t;
 axiom (forall m : mode_t :: m == mode_untrusted || m == mode_enclave);
-
+axiom mode_untrusted != mode_enclave;
 // -------------------------------------------------------------------- //
 // Page Tables (sort of: because we map addresses and not pages).       //
 // -------------------------------------------------------------------- //
@@ -41,8 +55,10 @@ type addr_map_t     = [vaddr_t]wap_addr_t;
 
 const k0_addr_perm_t : addr_perm_t;
 const kmax_addr_perm_t_as_int : int; 
+const kmax_privileged_t_as_int : int;
 axiom k0_addr_perm_t == 0bv5;
 axiom kmax_addr_perm_t_as_int == 31;
+axiom kmax_privileged_t_as_int == 2;
 
 // getters.
 function tap_addr_perm_p(p : addr_perm_t) : bool { p[1:0] == 1bv1 }   // Present
@@ -96,6 +112,12 @@ type tap_enclave_metadata_pc_t              = [tap_enclave_id_t]vaddr_t;
 type tap_enclave_metadata_addr_valid_t      = [tap_enclave_id_t]addr_valid_t;
 type tap_enclave_metadata_addr_excl_t       = [tap_enclave_id_t]excl_vaddr_t;
 type tap_enclave_metadata_addr_map_t        = [tap_enclave_id_t]addr_map_t;
+
+// do the enclave has privileged identity?
+// enclave control relationship (child -> parent), (OS -> OS), make requires!
+type tap_enclave_metadata_privileged_t      = [tap_enclave_id_t]bool;
+type tap_enclave_metadata_owner_map_t       = [tap_enclave_id_t]tap_enclave_id_t;
+
 // what addresses are exclusive to an enclave.
 type excl_map_t                             = [wap_addr_t]bool;
 type shared_paddr_map_t                     = [wap_addr_t]bool;
@@ -139,25 +161,48 @@ axiom (forall o : tap_proof_op_t ::
         o == tap_proof_op_pause     ||
         o == tap_proof_op_release   ||
         o == tap_proof_op_block);
+
+// failed: release, block
 function tap_proof_op_valid(o : tap_proof_op_t) : bool 
 {
-    o == tap_proof_op_compute   || o == tap_proof_op_destroy   ||
-    o == tap_proof_op_enter     || o == tap_proof_op_exit      ||
-    o == tap_proof_op_launch    || o == tap_proof_op_resume    ||
-    o == tap_proof_op_pause     || o == tap_proof_op_release   ||
+    o == tap_proof_op_compute ||
+    o == tap_proof_op_destroy ||
+    o == tap_proof_op_enter   ||
+    o == tap_proof_op_exit    ||
+    o == tap_proof_op_launch  ||
+    o == tap_proof_op_resume  ||  
+    o == tap_proof_op_pause   || 
+    o == tap_proof_op_release || 
     o == tap_proof_op_block
 }
 
 function tap_proof_op_valid_in_enclave(o : tap_proof_op_t) : bool
 {
+    // false 
+    o == tap_proof_op_pause     ||   
     o == tap_proof_op_compute   ||
-    o == tap_proof_op_exit      ||
-    o == tap_proof_op_pause
+    o == tap_proof_op_exit      
 }
 
+// compute & launch
+function tap_proof_op_valid_in_privileged (o : tap_proof_op_t) : bool
+{
+    // false
+    o == tap_proof_op_enter    ||
+    o == tap_proof_op_compute  ||
+    o == tap_proof_op_destroy  || 
+    o == tap_proof_op_exit     ||
+    o == tap_proof_op_launch   ||
+    o == tap_proof_op_resume   ||   
+    o == tap_proof_op_pause    
+}
+
+
 // -------------------------------------------------------------------- //
 // constants for enclaves.                                              //
 // -------------------------------------------------------------------- //
+type index_t = int;
+
 const tap_null_enc_id : tap_enclave_id_t;
 axiom tap_null_enc_id == 0;
 const tap_blocked_enc_id : tap_enclave_id_t;
@@ -172,20 +217,40 @@ const tap_user_def_enc_id_4 : tap_enclave_id_t;
 axiom tap_user_def_enc_id_4 == 5;
 const tap_user_def_enc_id_5 : tap_enclave_id_t;
 axiom tap_user_def_enc_id_5 == 6;
+const tap_user_def_enc_id_6 : tap_enclave_id_t;
+axiom tap_user_def_enc_id_6 == 6;
+// const tap_user_def_enc_id_head : tap_enclave_id_t;
+// axiom tap_user_def_enc_id_head == 1;
+// const tap_user_def_enc_id_tail : tap_enclave_id_t;
+// axiom tap_user_def_enc_id_tail == 6;
+
+// const tap_privil_enc_id_size : index_t;
+// axiom tap_privil_enc_id_size == 16;
+// const tap_privil_enc_id_head : tap_enclave_id_t;
+// axiom tap_privil_enc_id_head == tap_user_def_enc_id_tail + 1;
+// const tap_privil_enc_id_tail : tap_enclave_id_t;
+// axiom tap_privil_enc_id_tail == tap_privil_enc_id_head + tap_privil_enc_id_size;
+
+// function privileged_enclave_id (id: tap_thread_id_t) : bool
+// {
+//   id >= tap_privil_enc_id_head && id < tap_privil_enc_id_tail
+// } 
 
+  // strange bug: if no id_6, id_5 will be omitted?
 function valid_enclave_id(id : tap_enclave_id_t) : bool
 { 
   id != tap_null_enc_id       && id != tap_blocked_enc_id    &&
   id != tap_user_def_enc_id_1 && id != tap_user_def_enc_id_2 &&
   id != tap_user_def_enc_id_3 && id != tap_user_def_enc_id_4 &&
-  id != tap_user_def_enc_id_5
+  id != tap_user_def_enc_id_5 
+  && id != tap_user_def_enc_id_6
 }
 
 function special_enclave_id(id : tap_enclave_id_t) : bool
 {
   id == tap_blocked_enc_id    || id == tap_user_def_enc_id_1 ||
   id == tap_user_def_enc_id_2 || id == tap_user_def_enc_id_3 ||
-  id == tap_user_def_enc_id_4 || id == tap_user_def_enc_id_5
+  id == tap_user_def_enc_id_4 || id == tap_user_def_enc_id_5 
 }
 
 // -------------------------------------------------------------------- //
diff --git a/AbstractPlatform/build/PLACEHOLDER b/AbstractPlatform/build/PLACEHOLDER
old mode 100644
new mode 100755
diff --git a/AbstractPlatform/make.log b/AbstractPlatform/make.log
old mode 100644
new mode 100755
diff --git a/AbstractPlatform/times.log b/AbstractPlatform/times.log
old mode 100644
new mode 100755
diff --git a/Common/Cache.bpl b/Common/Cache.bpl
old mode 100644
new mode 100755
diff --git a/Common/CacheImpl.bpl b/Common/CacheImpl.bpl
old mode 100644
new mode 100755
index 8d0876b..d9aec3b
--- a/Common/CacheImpl.bpl
+++ b/Common/CacheImpl.bpl
@@ -21,7 +21,8 @@ implementation init_cache()
     ind := ind + 1;
   }
 }
-
+// hit:  find a hit way
+// miss: insert into repl_way
 implementation query_cache(pa : wap_addr_t, repl_way : cache_way_index_t)
   returns (hit : bool, hit_way : cache_way_index_t)
 {
diff --git a/Common/Common.bpl b/Common/Common.bpl
old mode 100644
new mode 100755
diff --git a/Common/Makefile b/Common/Makefile
old mode 100644
new mode 100755
index 434a993..64055de
--- a/Common/Makefile
+++ b/Common/Makefile
@@ -1,4 +1,5 @@
-BOOGIEOPT:=/z3opt:smt.RELEVANCY=0 /z3opt:smt.CASE_SPLIT=0 /errorLimit:1
+BOOGIE := boogie
+BOOGIEOPT:=/proverOpt:O:smt.RELEVANCY=0 /proverOpt:O:smt.CASE_SPLIT=0 /errorLimit:1
 
 BUILD=build
 CACHE_TARGET:=$(BUILD)/Cache.xml
diff --git a/Common/Types.bpl b/Common/Types.bpl
old mode 100644
new mode 100755
index bcfe4f7..4b7a938
--- a/Common/Types.bpl
+++ b/Common/Types.bpl
@@ -1,7 +1,9 @@
 // -------------------------------------------------------------------- //
 // address types.                                                       //
 // -------------------------------------------------------------------- //
-type vaddr_t = bv32;
+// type vaddr_t = bv32;
+// type vaddr_t = bv17;
+type vaddr_t = bv16;
 type wap_addr_t = bv22;
 type word_t  = bv32;
 
@@ -9,13 +11,33 @@ type word_t  = bv32;
 // constants and functions for vaddr_t                                  //
 // -------------------------------------------------------------------- //
 const kmax_vaddr_t : vaddr_t;
-axiom kmax_vaddr_t == 4294967295bv32;
+// axiom kmax_vaddr_t == 4294967295bv32;
+// axiom kmax_vaddr_t == 262144bv32;
+// axiom kmax_vaddr_t == 131071bv17;
+axiom kmax_vaddr_t == 65535bv16;
+
+// axiom kmax_vaddr_t == 65536bv32;
+// axiom kmax_vaddr_t == 32768bv32;
+
 const kmax_vaddr_t_as_int : int;
-axiom kmax_vaddr_t_as_int == 4294967295;
+// axiom kmax_vaddr_t_as_int == 4294967295;
+
+// axiom kmax_vaddr_t_as_int == 262144;
+// axiom kmax_vaddr_t_as_int == 131071;
+axiom kmax_vaddr_t_as_int == 65535;
+// axiom kmax_vaddr_t_as_int == 32767;
+
+
 const k0_vaddr_t : vaddr_t;
-axiom k0_vaddr_t == 0bv32;
+// axiom k0_vaddr_t == 0bv17;
+axiom k0_vaddr_t == 0bv16;
+// axiom k0_vaddr_t == 0bv32;
+
 const k1_vaddr_t : vaddr_t;
-axiom k1_vaddr_t == 1bv32;
+// axiom k1_vaddr_t == 1bv17;
+axiom k1_vaddr_t == 1bv16;
+// axiom k1_vaddr_t == 1bv32;
+
 function {:bvbuiltin "bvshl"} LSHIFT_va(p1: vaddr_t, p2: vaddr_t) : vaddr_t;
 function {:bvbuiltin "bvadd"} PLUS_va(p1: vaddr_t, p2: vaddr_t) : vaddr_t;
 function {:bvbuiltin "bvsub"} MINUS_va(p1: vaddr_t, p2: vaddr_t) : vaddr_t;
@@ -98,5 +120,9 @@ axiom (forall w : word_t :: word2int(w) >= 0 && word2int(w) <= kmax_word_t_as_in
 
 function vaddr2int(va : vaddr_t) : int;
 axiom (forall v1, v2 : vaddr_t :: (v1 != v2) ==> (vaddr2int(v1) != vaddr2int(v2)));
-axiom (forall w : vaddr_t :: vaddr2int(w) >= 0 && vaddr2int(w) <= kmax_vaddr_t_as_int);
+axiom (forall w : vaddr_t :: vaddr2int(w) >= 0 && vaddr2int(w) < kmax_vaddr_t_as_int);
+
+function bool2int(bl : bool) : int;
+axiom (forall bl : bool ::  bl ==>  bool2int(bl) == 1);
+axiom (forall bl : bool :: !bl ==>  bool2int(bl) == 0);
 
diff --git a/Common/build/PLACEHOLDER b/Common/build/PLACEHOLDER
old mode 100644
new mode 100755
diff --git a/LICENSE b/LICENSE
old mode 100644
new mode 100755
diff --git a/Makefile b/Makefile
old mode 100644
new mode 100755
index bc2e4d6..5beac96
--- a/Makefile
+++ b/Makefile
@@ -1,4 +1,4 @@
-BOOGIEOPT:=/z3opt:smt.RELEVANCY=0 /z3opt:smt.CASE_SPLIT=0 /errorLimit:1
+BOOGIEOPT:=/proverOpt:O:smt.relevancy=0 /proverOpt:O:smt.case_split=0 /errorLimit:1
 BUILD=build
 COMMON:=Common
 TAP=AbstractPlatform
diff --git a/README.md b/README.md
old mode 100644
new mode 100755
diff --git a/SGX/Hardware/sgx.bpl b/SGX/Hardware/sgx.bpl
old mode 100644
new mode 100755
diff --git a/SGX/Makefile b/SGX/Makefile
old mode 100644
new mode 100755
index 0d0646f..6b5ff13
--- a/SGX/Makefile
+++ b/SGX/Makefile
@@ -1,4 +1,4 @@
-BOOGIEOPT:=/z3opt:smt.RELEVANCY=0 /z3opt:smt.CASE_SPLIT=0 /errorLimit:1
+BOOGIEOPT:=/proverOpt:O:smt.relevancy=0 /proverOpt:O:smt.case_split=0 /errorLimit:1
 BUILD=build
 
 SGX_PROOF_TARGET=$(BUILD)/SGXProof.xml
diff --git a/SGX/Proof.bpl b/SGX/Proof.bpl
old mode 100644
new mode 100755
diff --git a/SGXRefinementProof.bpl b/SGXRefinementProof.bpl
old mode 100644
new mode 100755
diff --git a/Sanctum/CPU/CPU.bpl b/Sanctum/CPU/CPU.bpl
old mode 100644
new mode 100755
diff --git a/Sanctum/Common/Machine.bpl b/Sanctum/Common/Machine.bpl
old mode 100644
new mode 100755
diff --git a/Sanctum/Common/Prelude.bpl b/Sanctum/Common/Prelude.bpl
old mode 100644
new mode 100755
diff --git a/Sanctum/Common/Types.bpl b/Sanctum/Common/Types.bpl
old mode 100644
new mode 100755
diff --git a/Sanctum/Host/OS.bpl b/Sanctum/Host/OS.bpl
old mode 100644
new mode 100755
diff --git a/Sanctum/MMU/AbstractSanctumMMU/AbstractRISCVMMU/AbstractRISCVMMU.bpl b/Sanctum/MMU/AbstractSanctumMMU/AbstractRISCVMMU/AbstractRISCVMMU.bpl
old mode 100644
new mode 100755
diff --git a/Sanctum/MMU/AbstractSanctumMMU/AbstractRISCVMMU/AbstractRISCVMMUImpl.bpl b/Sanctum/MMU/AbstractSanctumMMU/AbstractRISCVMMU/AbstractRISCVMMUImpl.bpl
old mode 100644
new mode 100755
diff --git a/Sanctum/MMU/AbstractSanctumMMU/AbstractSanctumMMU.bpl b/Sanctum/MMU/AbstractSanctumMMU/AbstractSanctumMMU.bpl
old mode 100644
new mode 100755
diff --git a/Sanctum/MMU/AbstractSanctumMMU/AbstractSanctumMMUImpl.bpl b/Sanctum/MMU/AbstractSanctumMMU/AbstractSanctumMMUImpl.bpl
old mode 100644
new mode 100755
diff --git a/Sanctum/MMU/Common/Common.bpl b/Sanctum/MMU/Common/Common.bpl
old mode 100644
new mode 100755
index eeaac25..2a551e8
--- a/Sanctum/MMU/Common/Common.bpl
+++ b/Sanctum/MMU/Common/Common.bpl
@@ -36,7 +36,7 @@ function {:inline} pte1valid(mem: mem_t, base: ppn_t, vpn1: vpn1_t) : bool
 function {:inline} is_mapping_valid(mem: mem_t, base: ppn_t, vaddr: vaddr_t ) : bool
 {
     // TODO: check for permissions. Handle big pages.
-    // Read the first-level, ensure its valid.
+    // Read the first-level, ensures its valid.
     bv2bool(pte2valid(load_pte1(mem, base, vaddr2vpn1(vaddr)))) &&
     // Read the second-level, return its valid.
     bv2bool(pte2valid(
@@ -50,7 +50,7 @@ function {:inline} is_mapping_valid(mem: mem_t, base: ppn_t, vaddr: vaddr_t ) :
 function {:inline} is_translation_valid(mem: mem_t, base: ppn_t, access : riscv_access_t, vaddr: vaddr_t ) : bool
 {
     // TODO: check for permissions. Handle big pages.
-    // Read the first-level, ensure its valid.
+    // Read the first-level, ensures its valid.
     bv2bool(pte2valid(load_pte1(mem, base, vaddr2vpn1(vaddr)))) &&
     // Read the second-level, return its valid.
     bv2bool(pte2valid(
diff --git a/Sanctum/MMU/ConcreteSanctumMMU/ConcreteRISCVMMU/ConcreteRISCVMMU.bpl b/Sanctum/MMU/ConcreteSanctumMMU/ConcreteRISCVMMU/ConcreteRISCVMMU.bpl
old mode 100644
new mode 100755
diff --git a/Sanctum/MMU/ConcreteSanctumMMU/ConcreteRISCVMMU/ConcreteRISCVMMUImpl.bpl b/Sanctum/MMU/ConcreteSanctumMMU/ConcreteRISCVMMU/ConcreteRISCVMMUImpl.bpl
old mode 100644
new mode 100755
diff --git a/Sanctum/MMU/ConcreteSanctumMMU/ConcreteSanctumMMU.bpl b/Sanctum/MMU/ConcreteSanctumMMU/ConcreteSanctumMMU.bpl
old mode 100644
new mode 100755
diff --git a/Sanctum/MMU/ConcreteSanctumMMU/ConcreteSanctumMMUImpl.bpl b/Sanctum/MMU/ConcreteSanctumMMU/ConcreteSanctumMMUImpl.bpl
old mode 100644
new mode 100755
diff --git a/Sanctum/MMU/MMU.bpl b/Sanctum/MMU/MMU.bpl
old mode 100644
new mode 100755
diff --git a/Sanctum/MMU/MMUImpl.bpl b/Sanctum/MMU/MMUImpl.bpl
old mode 100644
new mode 100755
diff --git a/Sanctum/MMU/MMUProof.bpl b/Sanctum/MMU/MMUProof.bpl
old mode 100644
new mode 100755
diff --git a/Sanctum/Makefile b/Sanctum/Makefile
old mode 100644
new mode 100755
index af828e1..ef79af7
--- a/Sanctum/Makefile
+++ b/Sanctum/Makefile
@@ -1,4 +1,5 @@
-BOOGIEOPT:=/z3opt:smt.RELEVANCY=0 /z3opt:smt.CASE_SPLIT=0 /errorLimit:1
+BOOGIE := boogie
+BOOGIEOPT:=/proverOpt:O:smt.relevancy=0 /proverOpt:O:smt.case_split=0 /errorLimit:1
 MMU:=MMU
 CPU:=CPU
 HOST:=Host
diff --git a/Sanctum/Measurement/Measurement.bpl b/Sanctum/Measurement/Measurement.bpl
old mode 100644
new mode 100755
diff --git a/Sanctum/Monitor/MeasurementHelper.bpl b/Sanctum/Monitor/MeasurementHelper.bpl
old mode 100644
new mode 100755
diff --git a/Sanctum/Monitor/MeasurementHelperImpl.bpl b/Sanctum/Monitor/MeasurementHelperImpl.bpl
old mode 100644
new mode 100755
diff --git a/Sanctum/Monitor/Monitor.bpl b/Sanctum/Monitor/Monitor.bpl
old mode 100644
new mode 100755
diff --git a/Sanctum/Monitor/MonitorImpl.bpl b/Sanctum/Monitor/MonitorImpl.bpl
old mode 100644
new mode 100755
diff --git a/Sanctum/Proof.bpl b/Sanctum/Proof.bpl
old mode 100644
new mode 100755
diff --git a/Sanctum/RefinementProof/EnclaveEntryExit.bpl b/Sanctum/RefinementProof/EnclaveEntryExit.bpl
old mode 100644
new mode 100755
diff --git a/Sanctum/RefinementProof/EnclaveEntryExitImpl.bpl b/Sanctum/RefinementProof/EnclaveEntryExitImpl.bpl
old mode 100644
new mode 100755
diff --git a/Sanctum/RefinementProof/EnclaveLaunchDestroy.bpl b/Sanctum/RefinementProof/EnclaveLaunchDestroy.bpl
old mode 100644
new mode 100755
diff --git a/Sanctum/RefinementProof/EnclaveLaunchDestroyImpl.bpl b/Sanctum/RefinementProof/EnclaveLaunchDestroyImpl.bpl
old mode 100644
new mode 100755
diff --git a/Sanctum/RefinementProof/InitImpl.bpl b/Sanctum/RefinementProof/InitImpl.bpl
old mode 100644
new mode 100755
diff --git a/Sanctum/RefinementProof/InitRefinement.bpl b/Sanctum/RefinementProof/InitRefinement.bpl
old mode 100644
new mode 100755
diff --git a/Sanctum/RefinementProof/LoadStore.bpl b/Sanctum/RefinementProof/LoadStore.bpl
old mode 100644
new mode 100755
diff --git a/Sanctum/RefinementProof/LoadStoreImpl.bpl b/Sanctum/RefinementProof/LoadStoreImpl.bpl
old mode 100644
new mode 100755
diff --git a/Sanctum/RefinementProof/Makefile b/Sanctum/RefinementProof/Makefile
old mode 100644
new mode 100755
diff --git a/Sanctum/RefinementProof/Monitor.bpl b/Sanctum/RefinementProof/Monitor.bpl
old mode 100644
new mode 100755
diff --git a/Sanctum/RefinementProof/MonitorImpl.bpl b/Sanctum/RefinementProof/MonitorImpl.bpl
old mode 100644
new mode 100755
diff --git a/Sanctum/RefinementProof/RefinementCommon.bpl b/Sanctum/RefinementProof/RefinementCommon.bpl
old mode 100644
new mode 100755
diff --git a/Sanctum/RefinementProof/SanctumRefinement.bpl b/Sanctum/RefinementProof/SanctumRefinement.bpl
old mode 100644
new mode 100755
diff --git a/Sanctum/RefinementProof/Templates/EnclaveEntryExit.bpl b/Sanctum/RefinementProof/Templates/EnclaveEntryExit.bpl
old mode 100644
new mode 100755
diff --git a/Sanctum/RefinementProof/Templates/EnclaveLaunchDestroy.bpl b/Sanctum/RefinementProof/Templates/EnclaveLaunchDestroy.bpl
old mode 100644
new mode 100755
diff --git a/Sanctum/RefinementProof/Templates/InitRefinement.bpl b/Sanctum/RefinementProof/Templates/InitRefinement.bpl
old mode 100644
new mode 100755
diff --git a/Sanctum/RefinementProof/Templates/LoadStore.bpl b/Sanctum/RefinementProof/Templates/LoadStore.bpl
old mode 100644
new mode 100755
diff --git a/Sanctum/RefinementProof/Templates/Monitor.bpl b/Sanctum/RefinementProof/Templates/Monitor.bpl
old mode 100644
new mode 100755
diff --git a/Sanctum/RefinementProof/Templates/RefinementRelation.bpl b/Sanctum/RefinementProof/Templates/RefinementRelation.bpl
old mode 100644
new mode 100755
diff --git a/Sanctum/RefinementProof/Templates/SanctumRefinement.bpl b/Sanctum/RefinementProof/Templates/SanctumRefinement.bpl
old mode 100644
new mode 100755
diff --git a/Sanctum/RefinementProof/build/PLACEHOLDER b/Sanctum/RefinementProof/build/PLACEHOLDER
old mode 100644
new mode 100755
diff --git a/Sanctum/Utils/Utils.bpl b/Sanctum/Utils/Utils.bpl
old mode 100644
new mode 100755
diff --git a/Sanctum/Utils/UtilsImpl.bpl b/Sanctum/Utils/UtilsImpl.bpl
old mode 100644
new mode 100755
diff --git a/Sanctum/build/PLACEHOLDER b/Sanctum/build/PLACEHOLDER
old mode 100644
new mode 100755
diff --git a/SanctumRefinementProof.bpl b/SanctumRefinementProof.bpl
old mode 100644
new mode 100755
